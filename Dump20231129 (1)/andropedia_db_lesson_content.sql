-- MySQL dump 10.13  Distrib 8.0.34, for macos13 (arm64)
--
-- Host: localhost    Database: andropedia_db
-- ------------------------------------------------------
-- Server version	8.0.32

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!50503 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `lesson_content`
--

DROP TABLE IF EXISTS `lesson_content`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `lesson_content` (
  `id` int NOT NULL AUTO_INCREMENT,
  `courseNumber` int NOT NULL,
  `themeNumber` int NOT NULL,
  `levelNumber` int NOT NULL,
  `uniqueLevelId` int NOT NULL,
  `uniqueLevelContentId` int NOT NULL,
  `uniqueThemeId` int NOT NULL,
  `language` text NOT NULL,
  `lastUpdateDate` date NOT NULL,
  `imageFirst` blob,
  `textTitle` text NOT NULL,
  `textFirst` text,
  `CodeFragmentFirst` text,
  `imageSecond` blob,
  `textSecond` text,
  `CodeFragmentSecond` text,
  `imageThird` blob,
  `textThird` text,
  `CodeFragmentThird` text,
  `imageFourth` blob,
  `textFourth` text,
  `CodeFragmentFourth` text,
  `imageFifth` blob,
  `textFifth` text,
  `CodeFragmentFifth` text,
  `imageSixth` blob,
  `textSixth` text,
  `CodeFragmentSixth` text,
  `imageSeventh` blob,
  `textSeventh` text,
  `CodeFragmentSeventh` text,
  `imageEighth` blob,
  `textEighth` text,
  `CodeFragmentEighth` text,
  `imageNinth` blob,
  `textNinth` text,
  `CodeFragmentNinth` text,
  `imageTenth` blob,
  `textTenth` text,
  `CodeFragmentTenth` text,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=134 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `lesson_content`
--

LOCK TABLES `lesson_content` WRITE;
/*!40000 ALTER TABLE `lesson_content` DISABLE KEYS */;
INSERT INTO `lesson_content` VALUES (1,1,1,1,20,1,3,'rus','2023-11-01',NULL,'Знакомство с andropedia','1.=Знакомство с  Andropedia=\r\nЕсли вы читаете эти строки, то поздравляю! Вы находитесь в самом лучшем приложение по изучению Android разработки. \r\nЭтот курс не рассчитан на определенную аудиторию, так как программированием может заняться каждый человек, потому что ,программирование - это гибкая сфера, которой можно обучиться в любом возрасте. \r\nСамое главное, что вы должны иметь - это большое желание учиться. \r\n2. =Что даст вам этот курс?= \r\nВ этом курсе вы освоите базовые навыки для создания приложения под операционную систему Android, но также вы можете купить подписку, в которой вы более углубленно изучите все нюансы создания приложения, а также вы сможете создавать свои приложения при помощи наших курсов. После окончания этого курса вы сможете самостоятельно создавать приложения различного уровня сложности.\r\n3. =Наш телеграм канал= \r\nТакже у нас есть свои Телеграмм каналы. В одном мы анансируем обновления и выставляем интересную информацию о приложении. Также вы можете предлогать свои идеи для развития проекта, а во втором вы можете найти единомышленников для более интересного обучения. А также вы можете задавать или отвечать на вопросы.\r\n Удачи!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(2,1,1,2,21,2,3,'rus','2023-11-01',NULL,'Почему kotlin','Для создания приложений вам понадобится использовать один из языков программирования , а именно kotlin или java. \r\nВ этом уроке я хотел бы рассказать , почему мы выбрали котлин вместо java .\r\nИспользование Kotlin вместо Java имеет несколько преимуществ, которые делают его предпочтительным выбором для разработки Android-приложений:\r\n\r\n1.=Краткость и выразительность=: Kotlin предлагает более краткий и лаконичный синтаксис по сравнению с Java. Он обладает мощными функциональными возможностями, расширениями функций, лямбда-выражениями и другими синтаксическими улучшениями, что делает код более читабельным, понятным и поддерживаемым.\r\n\r\n2.=Безопасность и надежность=: Kotlin стремится предоставить более безопасное программирование. Он предлагает нулевую безопасность (null safety) на уровне языка, что помогает предотвратить ошибки NullPointerException, которые являются одними из наиболее распространенных ошибок в Java-приложениях. Кроме того, Kotlin старается предотвратить другие распространенные ошибки программирования, такие как ошибки при работе с коллекциями.\r\n\r\n3.=Интероперабельность с Java=: Kotlin полностью совместим с Java, что означает, что вы можете использовать библиотеки и фреймворки Java в своих Kotlin-проектах без проблем. Вы можете постепенно переносить свой Java-код в Kotlin, не переписывая всю кодовую базу сразу.\r\n\r\n4.=Поддержка расширений и аннотаций=: Kotlin предлагает мощную систему расширений, которая позволяет добавлять новые функции к существующим классам без изменения их кода. Это помогает улучшить модульность и повторное использование кода. Кроме того, Kotlin поддерживает аннотации на уровне языка, что делает их более легкими в использовании и позволяет сделать код более чистым и выразительным.\r\n\r\n5.=Активная поддержка от Google=: Kotlin был официально поддержан в качестве языка разработки для Android Google в 2017 году. Это означает, что Google активно продвигает и поддерживает Kotlin, предоставляя инструменты и ресурсы для разработчиков, а также интеграцию с Android Studio.\r\n\r\nВ целом, Kotlin предлагает более современный и удобный язык программирования, который способствует повышению производительности разработчика, уменьшению количества ошибок.\r\nНаглядный пример кратности - это класс, который хранит в себе поля , то есть класс с информацией (data class)   :','%%//Код написанный на java%%\r\n##public class Person{\r\n\r\n   ##,,,private String **name**;\r\n   ##,,,private int **age**;\r\n   ##,,,private int **weight**;\r\n\r\n   ##,,,public Person(String **name**, int **age**, int **weight**) {\r\n       ##,,,,,,this.**name** = **name**;\r\n       ##,,,,,,this.**age** = **age**;\r\n       ##,,,,,,this.**weight** = **weight**;\r\n   ##,,,}\r\n\r\n   ##,,,public Person() {\r\n   ##,,,}\r\n\r\n   ##,,,public String getName() {\r\n       ##,,,,,,return **name**;\r\n   ##,,,}\r\n\r\n   ##,,,public void setName(String **name**) {\r\n       ##,,,,,,this.**name** = **name**;\r\n   ##,,,}\r\n\r\n   ##,,,public int getAge() {\r\n       ##,,,,,,return **age**;\r\n   ##,,,}\r\n\r\n   ##,,,public void setAge(int **age**) {\r\n       ##,,,,,,this.**age** = **age**;\r\n   ##,,,}\r\n\r\n   ##,,,public int getWeight() {\r\n       ##,,,,,,return **weight**;\r\n   ##,,,}\r\n\r\n   ##,,,public void setWeight(int **weight**) {\r\n       ##,,,,,,this.**weight** = **weight**;\r\n   ##,,,}\r\n##}\r\n%%//Код написанный на Kotlin%%\r\n##data class Personl(\r\n    ##,,,val **name**: String,\r\n    ##,,,val **age**: Int,\r\n    ##,,,val **weight**: Int\r\n)',NULL,'Тут мы используем переменные , классы и типы данных , но если вам неизвестно эти понятия  , то не бойтесь , так как в следующих уроках мы все обьясним. А этот фрагмент кода был просто примером\r\nЕсли вы хотите почитать больше о разницы использования kotlin и java, то вот вам ссылка https://habr.com/ru/companies/otus/articles/580738/',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(3,1,1,3,22,3,3,'rus','2023-11-01',NULL,'Android studio','1. =Что такое Android Studio?=\r\n\r\nДля создание приложения нужно специальное приложение под названием Andoid Studio. Android Studio - это интегрированная среда разработки (IDE) для работы с платформой Android. Проще говоря, это программа, которая компилирует наш код, и на выходе мы получем приложение. В этом уроке мы скачаем и ознакомимся с этой средой разработки.\r\n\r\n 2. =Скачивание Android Studio.=\r\n\r\nПервым делом перейдите по это ссылке: \"Ссылка на скачиваение\" нажмите Скачать и ждите. После скачивания нажмите на файл, который вы скачали и у вас выйдет окно, в котором нажимаем на Next(ы) после чего в конце нажимаем на Install и Finish. После этого опять ждем скачивание и после у вас откроется Andoid Studio, и если вам будет предложено скачать что либо, то скачиваем и после того как мы все скачали, у нас выходи окно [фото] в котором нажимаем New Project, после выбираем Empty Views Activity и нажимаем Next. И у нас выйдет окно Фото, в котором мы прописывем в поле Name названия нашего приложения. В Save Location прописываем, куда мы хотим сохранить этот проект. В поле Language мы выбираем Kotlin. А почему Котлин? Мы объясним в следующих уроках. А в других полях, о которых мы не говорили, вы можете оставить так, как вам поставила Android Studio. После того как мы заполнили все поля, нажимаем Finish. после ждем, пока весь проект загрузится. Поздравляю: Вы успешно скачали Android Studio!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(4,1,1,4,23,4,3,'rus','2023-11-01',NULL,'Эмулятор','1.=Эмулятор=\r\nЭмулятор в Android Studio - это инструмент, который позволяет разработчикам создавать и запускать виртуальные устройства Android на своих компьютерах. Он представляет собой программное обеспечение, которое эмулирует аппаратные и программные характеристики реального устройства Android.\r\n\r\nЭмулятор в Android Studio обладает множеством функций, которые помогают разработчикам тестировать и отлаживать свои приложения перед запуском на реальных устройствах. С его помощью можно эмулировать различные версии операционной системы Android, разные разрешения экрана, конфигурации устройства и даже симулировать различные условия сети, такие как медленное соединение или отсутствие сети.\r\n\r\nЭмулятор в Android Studio основан на виртуализации процессора и графики компьютера, что позволяет достаточно точно эмулировать поведение реального устройства Android. Он обеспечивает доступ к функциональным кнопкам, сенсорному вводу, камере, микрофону и другим устройствам, которые обычно присутствуют на мобильных устройствах Android.\r\n\r\nИспользование эмулятора в Android Studio может быть очень полезным для разработчиков, так как они могут проверить и протестировать свои приложения на различных конфигурациях устройств без необходимости физического наличия каждого отдельного устройства.\r\n\r\n2. =Создание эмулятора=\r\nВ правом верхнем углу можно увидеть значок \"Device Manager\" (это изображение смартфона с зеленым андроидом внизу) нажимаем на нее . Вы также можете открыть Device Manager из меню \"Tools\" -> \"Device Manager\".\r\n\r\nВ открывшемся окне Device Manager нажмите кнопку \"CreateDevice\" .\r\n\r\nВыберите тип устройства, которое вы хотите эмулировать. Например, вы можете выбрать \"Phone\" и затем выбрать конкретную модель телефона из списка доступных опций. Нажмите \"Next\" .\r\n\r\nВыберите версию операционной системы Android для вашего эмулятора. Если нужной версии нет в списке, нажмите \"Download\" рядом с необходимой версией, чтобы загрузить ее. Нажмите \"Next\".\r\n\r\nНастройте дополнительные параметры для вашего эмулятора, такие как имя устройства, ориентацию экрана и т. д. Нажмите \"Finish\", чтобы создать эмулятор.\r\n\r\nВернитесь в окно Device Manager, где вы увидите список созданных эмуляторов. Чтобы запустить эмулятор, щелкните правой кнопкой мыши по нему и выберите \"Start\" .\r\n\r\nОжидайте, пока эмулятор загрузится. После загрузки вы сможете запустить ваше приложение на эмуляторе, нажав на кнопку \"Run\" (это зеленая кнопка в виде треугольника в правом верхнем углу ) в Android Studio .\r\n\r\nТеперь у вас есть эмулятор Android, на котором вы можете тестировать и запускать свои приложения, разработанные в Android Studio.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(5,1,2,5,24,5,4,'rus','2023-11-01',NULL,'Manifest','1. =Что такое манифест (AndroidManifest.xml)=\r Манифест (AndroidManifest.xml) — это специальный XML-файл, неотъемлемая часть каждого Android-приложения.\r  В нем содержатся основные сведения о настройках, таких как имя пакета, список компонентов (Activity, Service, BroadcastReceiver), разрешения, конфигурационные и другие метаданные.\r  Манифест играет важную роль в разработке Android-приложений, так как представляет информацию о приложении и реализует его поведение.\r \r 2. =Структура манифеста=\r Манифест состоит из корневого элемента manifest, в котором обнаруживаются другие элементы, такие как application, activity, service, receiver, providerи т.д. \r Каждый из элементов определяет различные компоненты и их свойства.','##<manifest xmlns android=httpschemas.android.comapkresandroid\r     ##,,,package=com.example.myapp \r \r     %%!-- Основные сведения о приложении --%%\r     ##,,,application\r         ##,,,,,,androidallowBackup=true\r         ##,,,,,,androidicon=@drawableapp_icon\r         ##,,,,,,androidlabel=@stringapp_name\r         ##,,,,,,androidtheme=@styleAppTheme \r \r         %%!-- Описание Activity --%%\r         ##,,,,,,activity\r             ##,,,,,,,,,androidname=.MainActivity\r             ##,,,,,,,,,androidlabel=@stringapp_name \r             ##,,,,,,,,,intent-filter\r                 ##,,,,,,,,,,,,action androidname=android.intent.action.MAIN \r                 ##,,,,,,,,,,,,category androidname=android.intent.category.LAUNCHER \r             ##,,,,,,,,,intent-filter\r        ##,,,,,,activity\r \r         %%!-- Другие компоненты (Service, BroadcastReceiver, ContentProvider) --%%\r \r     ##,,,application\r ##</manifest>',NULL,'3. =Основные элементы манифеста=\r\n\r\nmanifest Корневой элемент манифеста, содержит атрибуты package(имя пакета приложений) и versionCode(версия приложения).\r\napplication Описывает приложение и его компоненты. Содержит атрибуты, такие как androidallowBackup(разрешение резервного места), androidicon(иконка приложений), androidlabel(имя приложения) и т.д.\r\nactivity Описывает Activity (окно) приложения. Содержит атрибуты, такие как androidname(имя класса Activity), androidlabel(название Activity для отображения в списке приложений) и элементы intent-filterдля указаний и категорий, относящихся к Activity.\r\nservice Описывает службы, выполняющие длительные операции в фоновом режиме.\r\nreceiver Описывает BroadcastReceiver, который прослушивает и обнаруживает обнаружение событий (например, обнаруживает SMS, изменение состояния батареи и т.д.).\r\nprovider Описывает ContentProvider, который предоставляет доступ к данным приложениям других приложений.\r\n4. =Разрешения= (разрешения) \r\nМанифест также используется для объявления разрешений (разрешений), которые должны быть получены для выполнения действий или доступа к ресурсу устройства (например, доступ к интернету, чтение конфликтов, использование камер и т.д.).','##<uses-permission androidname=android.permission.INTERNET />\r ##<uses-permission androidname=android.permission.CAMERA />\r ##<uses-permission androidname=android.permission.READ_CONTACTS />\r !-- Другие разрешения --',NULL,'5. =Совместимость и настройки= \r\nВ манифесте также можно указать информацию о приложении с распространенной версией Android, ориентацию экрана, темы и стили, а также другие конфигурационные.\r\n\r\n6. =Заключение= \r\nМанифест — это важный файл в Android-разработке, который содержит основные сведения о приложении и его компонентах. Настройка манифеста позволяет поведение определять приложения, запрашивать разрешение, управлять совместимостью и многое другое. Понимание манифеста - ключевой элемент разработки Android-приложений.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(6,1,2,6,25,6,4,'rus','2023-11-01',NULL,'Gradle Script','Gradle - это мощная система сборки, используемая для управления процессом компиляции, зависимостями и конфигурациями проекта Android. \r\nВ этом уроке мы рассмотрим Gradle Scripts с подробными комментариями, чтобы вы понимали, что делает каждая часть кода.\r\n\r\n1. =build.gradle (Project)=\r\n','%%// Определение версий плагинов и зависимостей%%\r\n##buildscript {\r\n    ##,,,ext {\r\n        ##,,,,,,kotlin_version = ;;\'1.8.0\';;\r\n    ##}\r\n    ##,,,dependencies {\r\n        // Зависимости для плагинов\r\n        ##,,,,,,classpath ;;\"com.google.dagger:hilt-android-gradle-plugin:2.43.2\";;\r\n        ##,,,,,,classpath ;;\"androidx.navigation:navigation-safe-args-gradle-plugin:2.6.0-alpha08\";;\r\n        ##,,,,,,classpath ;;\"org.jetbrains.kotlin:kotlin-gradle-plugin:1.8.0\";;\r\n        ##,,,,,,classpath ;;\'androidx.navigation:navigation-safe-args-gradle-plugin:2.5.3\';;\r\n        ##,,,,,,classpath ;;\"org.jetbrains.kotlin:kotlin-serialization:1.8.0\";;\r\n    ##,,,}\r\n##}\r\n\r\n%%// Плагины, применяемые ко всем проектам%%\r\n##plugins {\r\n    ##,,,id ;;\'com.android.application\' version \'8.0.2\';; apply false\r\n    ##,,,id ;;\'com.android.library\' version \'8.0.2\';; apply false\r\n    ##,,,id ;;\'org.jetbrains.kotlin.android\' version \'1.8.20\';; apply false\r\n##}',NULL,'Файл build.gradle (Project) для проекта содержит настройки и зависимости, общие для всех модулей. Здесь вы определяете версии плагинов и зависимостей, используемых во всем проекте.\r\n2. =build.gradle (Module)=','%%// Определение используемых плагинов%%\r\n##plugins {\r\n    ##,,,id ;;\'com.android.application\';;\r\n    ##,,,id ;;\'org.jetbrains.kotlin.android\';;\r\n##}\r\n\r\n%%// Настройка параметров приложения Android%%\r\n##android {\r\n    ##,,,namespace ;;\'com.example.AppName\';;\r\n    ##,,,compileSdk 33\r\n\r\n    ##,,,defaultConfig {\r\n        ##,,,,,,applicationId ;;\"com.example.andropediagits\";;\r\n        ##,,,,,,minSdk [[24[[\r\n        ##,,,,,,targetSdk [[33[[\r\n        ##,,,,,,versionCode [[1[[\r\n        ##,,,,,,versionName ;;\"1.0\";;\r\n        ##,,,,,,testInstrumentationRunner ;;\"com.example.andropediagits.HiltTestRunner\";;\r\n    ##,,,}\r\n\r\n    %%// Дополнительные настройки сборки и компиляции%%\r\n    %%// ...%%\r\n\r\n    %%// Включение функциональности viewBinding%%\r\n    ##,,,buildFeatures {\r\n        ##,,,,,,viewBinding true\r\n    ##,,,}\r\n##}\r\n\r\n%%// Зависимости проекта%%\r\n##dependencies {\r\n    %%// Зависимости%%\r\n    %%// ...%%\r\n##}',NULL,'Файл build.gradle(Module) для модуля определяет настройки, связанные с конкретным модулем. Здесь вы указываете зависимости, параметры сборки и другие настройки.\r\n3. =settings.gradle=','%%// Определение репозиториев для плагинов Gradle и зависимостей%%\r\n##pluginManagement {\r\n    ##,,,repositories {\r\n        ##,,,,,,google()\r\n        ##,,,,,,mavenCentral()\r\n        ##,,,,,,gradlePluginPortal()\r\n    ##,,,}\r\n##}\r\n\r\n%%// Настройка управления зависимостями%%\r\n##dependencyResolutionManagement {\r\n    ##,,,repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)\r\n    ##,,,repositories {\r\n        ##,,,,,,google()\r\n        ##,,,,,,mavenCentral()\r\n        ##,,,,,,maven { url ;;\"https://jitpack.io\";; }\r\n        ##,,,,,,jcenter()\r\n    ##,,,}\r\n##}\r\n\r\n%%// Назначение имени корневого проекта%%\r\n##rootProject.name = AppName\r\n\r\n%%// Включение модулей в проект%%\r\n##include ;;\':app\';;',NULL,'Файл settings.gradle определяет, какие модули включены в ваш проект. Он также управляет репозиториями для плагинов и зависимостей.\r\nЗаключение\r\n\r\nGradle Scripts являются неотъемлемой частью разработки Android-проектов. \r\nПонимание каждой части кода и комментариев, предоставленных выше, поможет вам эффективно управлять зависимостями, настройками и структурой вашего проекта.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(7,1,2,7,26,7,4,'rus','2023-11-01',NULL,'Создание layout','Чтобы создать XML-файл в папке layout в Android Studio, выполните следующие шаги:\r\n\r\n Найдите папку res. Разверните ее и найдите папку layout.\r\n\r\nЩелкните правой кнопкой мыши на папке layout и выберите \"New\" в контекстном меню, а затем выберите \"Layout resource file\" .\r\n\r\nВ появившемся диалоговом окне \"New Android Resource File\" , укажите имя XML-файла в поле \"File name\" . Например, если вы хотите создать файл с именем my_layout.xml, введите это имя в поле.\r\n\r\nВ поле \"Root element\"  укажите корневой элемент для вашего макета. Например, если вы хотите использовать LinearLayout в качестве корневого элемента, введите LinearLayout в это поле.\r\n\r\nНажмите кнопку \"OK\" для создания XML-файла.\r\n\r\nПосле выполнения этих шагов новый XML-файл будет создан в папке layout. Вы можете открыть его и начать редактировать, добавлять элементы макета и настраивать их атрибуты с помощью редактора макетов Android Studio.\r\n\r\nТакже layout автоматически создается во время создания фрагмента или активити  ',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(8,1,2,88,107,8,4,'rus','2023-11-01',NULL,'Ресурсы android studio','1.=Ресурсы=\r\nВ Android Studio ресурсы (resources) - это все непрограммный контент, используемый вашим приложением, такой как изображения, макеты интерфейса, строки, цвета, стили, анимации и многое другое. Ресурсы представляют собой файлы, которые хранятся в специальных папках внутри вашего проекта и доступны во время выполнения приложения.\r\n\r\nИспользование ресурсов в Android Studio предоставляет следующие преимущества:\r\n\r\n1.=Локализация=: Ресурсы позволяют вам создавать различные версии контента для разных языков и регионов. Вы можете легко локализовать строки, макеты и другие ресурсы, чтобы ваше приложение было доступно на разных языках.\r\n\r\n2.=Адаптивность=: Ресурсы позволяют создавать адаптивные интерфейсы, которые могут изменяться в зависимости от размера экрана и ориентации устройства. Вы можете создавать разные версии макетов и изображений для разных устройств, чтобы ваше приложение выглядело и работало оптимально на различных устройствах.\r\n\r\n3.=Управление стилями и темами=: Ресурсы позволяют создавать стили и темы, которые могут быть применены ко всем компонентам интерфейса вашего приложения. Это упрощает изменение внешнего вида приложения, применение единого стиля к различным элементам и обеспечение единообразного пользовательского опыта.\r\n\r\n4.=Легкая замена контента=: Использование ресурсов позволяет легко заменять или обновлять контент вашего приложения без необходимости изменения кода. Например, вы можете легко заменить изображение, изменив только файл ресурса, без изменения кода, который использует это изображение.\r\n\r\n5.=Оптимизация ресурсов=: Android Studio предоставляет инструменты для оптимизации ресурсов, такие как сжатие изображений, чтобы уменьшить размер приложения и повысить его производительность.\r\n\r\nРесурсы в Android Studio хранятся в специальных папках, таких как \"res/drawable\" для изображений, \"res/layout\" для макетов интерфейса, \"res/values\" для строк и других значений и т. д. Вы можете создавать и управлять ресурсами с помощью ресурсного редактора в Android Studio или напрямую в файлах ресурсов в коде проекта.\r\n\r\n \r\n\r\nПолучение ресурсов из папки:','//Получение во Fragment\r\n##%%//Строку%%\r\n##getString(R.string.**your_name**)\r\n##%%// картинку%%\r\n##context.getDrawable(R.drawable.**image**)\r\n##%%//цвет%%\r\n##context.getColor(R.color.**red**)\r\n##%%//Получение в Activity%%\r\n##%%//Строку %%\r\n##R.string.**your_name**\r\n##%%// картинку%%\r\n##R.drawable.**image**\r\n##%%//цвет%%\r\n##R.color.**red**',NULL,'Внимание!  При создание элемента в ресурсах , мы не можем использовать в названиях большие буквы, пробелы и различные спец символы по типу ?!%',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(9,1,2,8,27,9,4,'rus','2023-11-01',NULL,'Мотивация','\"Лучшее — враг хорошего\" – эта мудрая поговорка гласит о том, что постоянное стремление к совершенству или идеалу может отвлечь от реализации хороших и достижимых результатов.\r\n\r\nПри переучивании опытных специалистов из других областей на программистов, можно заметить интересную тенденцию. Люди, уже имеющие опыт работы в разных сферах, проявляют большой энтузиазм и готовы активно обучаться, стремясь стать программистами. И чем больше у них опыта вне IT, тем более преданными они становятся учебе. В свою очередь, студенты иногда проявляют небрежность и неохоту к учебе.\r\n\r\nОдна из основных потребностей, присущих всем нам, это желание жить комфортно и иметь стабильный доход. Такое стремление присуще большинству людей, и многие пытаются достичь этой цели путем профессионального роста и карьерного развития. Мы хотим стать выдающимися специалистами, получить признание, уважение и возможность зарабатывать хорошо – это звучит привлекательно.\r\n\r\nТем не менее, распространенный план достижения успеха часто ошибочен, так как не учитывает реальные условия жизни, особенно конкуренцию.\r\n\r\nКонкуренция.\r\nВ сфере работы и профессионального развития существует жесткая конкуренция. Лучшие специалисты получают основную часть всех доходов. Топ-5% специалистов зарабатывают половину всех денег, а топ-20% - 80% всех доходов. Различные компании ищут наилучших кандидатов, однако также существуют организации, которые стремятся сэкономить и ищут более дешевых сотрудников. Для успешной борьбы с конкуренцией, необходимо стремиться стать одним из лучших специалистов, приобретать качественный опыт работы и активно развиваться.\r\n\r\nПроигравший не получит ничего.\r\nКак во время учебы, так и после нее, существует высокая конкуренция на рынке труда. Например, если выпускается 1000 юристов, а доступны всего 40 вакансий, только 40 из них найдут работу по своей специальности, а остальные останутся без работы или найдут работу не связанную с профессией. И даже если вы являетесь лучшим выпускником, но у вас нет опыта работы, может оказаться сложно конкурировать с теми, кто уже имеет опыт и связи в отрасли.\r\n\r\nУ вас нет ничего.\r\nПосле окончания университета у вас есть только диплом, который, в сущности, может оказаться не таким ценным для работодателя. Высшее образование не гарантирует успеха, и в наше время множество людей обладают высшим образованием. Намного важнее опыт работы и практические навыки, которые вы получите на реальной работе.\r\n\r\nДля успешной карьеры необходимо стремиться к непрерывному самообучению, активно искать возможности для получения опыта работы и стремиться стать лучшими в своей области. Конкуренция может быть жесткой, но успех возможен для тех, кто будет настойчивым и готов преодолевать трудности на пути к своим целям.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(10,1,3,9,28,10,5,'rus','2023-11-01',NULL,'Классы ','В этом уроке мы познакомимся с основами классов в языке программирования Kotlin.\r\n Классы - это основные строительные блоки объектно-ориентированного программирования, позволяющие описывать состояние и поведение объектов.\r\n Мы научимся определять классы, создавать объекты, добавлять свойства и методы, а также использовать конструкторы.\r\n\r\nОпределение класса:\r\nКлассы в Kotlin определяются с помощью ключевого слова class, за которым следует имя класса. Имя класса должно начинаться с заглавной буквы.\r\n\r\nПример:','class Person {\r\n    ##,,,%%// Тело класса будет добавлено в следующих шагах%%\r\n##}',NULL,'Добавление свойств:\r\nСвойства определяют состояние объекта. Они представляют собой переменные, которые хранят данные объекта.\r\n\r\nПример:','##class Person {\r\n    ##,,,var **name**: String = ;;\"\";;\r\n    ##,,,var **age**: Int = [[0[[\r\n##}',NULL,'Добавление методов:\r\nМетоды определяют поведение объекта. Они представляют собой функции, которые могут выполнять действия над данными объекта.\r\n\r\nПример:','##class Person {\r\n    ##,,,var **name**: String = ;;\"\";;\r\n    ##,,,var **age**: Int = [[0[[\r\n\r\n    ##,,,fun ^^sayHello^^() {\r\n        ##,,,,,,println(;;\"Hello, my name is $name and I am $age years old.\";;)\r\n    ##,,,}\r\n##}',NULL,'Создание объектов:\r\nЧтобы использовать класс, мы должны создать объект этого класса. Объект - это экземпляр класса, который содержит данные и поведение, определенные в классе.\r\n\r\nПример:','##fun ^^main^^() {\r\n    ##,,,val **person1** = Person()\r\n    ##,,,**person1**.**name** = \"Alice\"\r\n    ##,,,**person1**.**age** = [[30[[\r\n    ##,,,**person1**.sayHello() %%// Выведет: \"Hello, my name is Alice and I am 30 years old.\"%%\r\n\r\n    ##,,,val **person2** = Person()\r\n    ##,,,**person2**.**name** = \"Bob\"\r\n    ##,,,**person2**.**age** = [[25[[\r\n    ##,,,**person2**.sayHello() %%// Выведет: \"Hello, my name is Bob and I am 25 years old.\"%%\r\n##,,,}',NULL,'Первичный конструктор:\r\nКлассы могут иметь первичный конструктор, который определяет, какие аргументы необходимо передать при создании объекта.\r\n\r\nПример:','##class Person(firstName: String, personAge: Int) {\r\n    ##,,,var **name**: String = firstName\r\n    ##,,,var **age**: Int = personAge\r\n\r\n    ##,,,fun ^^sayHello^^() {\r\n        ##,,,,,,println(\"Hello, my name is $**name** and I am $**age** years old.\")\r\n    ##,,,}\r\n##}\r\n\r\n##fun ^^main^^() {\r\n    ##,,,val **person** = Person(;;\"Alice\";;, [[30[[)\r\n    ##,,,**person**.sayHello() %%// Выведет: \"Hello, my name is Alice and I am 30 years old.\"%%\r\n##}',NULL,'Теперь вы знакомы с основами классов в Kotlin!\r\n Классы позволяют создавать структуры данных и определять поведение объектов, что делает ваш код более организованным и понятным.\r\n В следующих уроках мы рассмотрим более продвинутые концепции ООП в Kotlin. Удачи!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(11,1,3,10,29,11,5,'rus','2023-11-01',NULL,'Константы','Константа - это переменная, которую мы объявляем с ключевым словом val, и которая имеет фиксированное значение, которое не может быть изменено после инициализации.\r\n\r\nМожно привести пример из реальной жизни:\r\n(Фото мороженого) \r\nДопустим, у нас есть мороженое и мы хотим определить константу для максимальной температуры хранения мороженого, чтобы быть уверенными, что оно не растает. Нам нужно установить эту температуру и удостовериться, что она не изменится, чтобы мороженое всегда было в безопасности.\r\n\r\nПрограммный пример:','// Объявляем константу для максимальной температуры хранения мороженого (в градусах Цельсия)\r\nconst val **MAX_ICE_CREAM_TEMPERATURE**: Int = -[[10[[\r\n##fun ^^main^^() {\r\n    \r\n\r\n    ##,,,%%// Текущая температура окружающей среды%%\r\n    ##,,,val **currentTemperature** = -[[5[[\r\n\r\n    ##,,,%%// Проверяем, безопасно ли хранить мороженое при текущей температуре%%\r\n    ##,,,if (**currentTemperature** <= **MAX_ICE_CREAM_TEMPERATURE**) {\r\n        ##,,,,,,println(;;\"Мороженое безопасно хранить.\";;)\r\n    ##,,,} else {\r\n        ##,,,,,,println(;;\"Температура слишком высока! Мороженое растает.\";;)\r\n    ##,,,}\r\n##}',NULL,'Мы объявляем константу MAX_ICE_CREAM_TEMPERATURE, которая устанавливает максимальную температуру, при которой мороженое безопасно хранить (-10 градусов Цельсия). Затем мы проверяем текущую температуру окружающей среды(если темпреатура ниже или равна нашему значинию из константы, то тогда выводим сообщения о благоприятном условии хранения мороженого , а иначе выводим сообщение о неблагоприятном условии)\r\nПравила написания константы:\r\nКак вы заметили мы обьвляем константу непривычным способом , а именно : все буквы заглавные и пробелы заменябтся \'_\'.\r\nЭто связанно с правилом написания константы . Вот правила написания:\r\nИменование: Имя константы должно быть понятным и описывающим ее назначение. Используйте верблюжью нотацию (camelCase) или знак подчеркивания (snake_case) для разделения слов в имени константы.\r\n\r\nЗаглавные буквы: В некоторых языках, таких как Kotlin и Java, принято писать имена констант заглавными буквами. Это помогает отличить константы от обычных переменных.\r\n\r\nРазделение слов: Если имя константы состоит из нескольких слов, используйте знак подчеркивания или заглавные буквы для разделения слов. Например, MY_CONSTANT, PI_VALUE, MAX_LENGTH.\r\n\r\nНеизменяемость: Константу необходимо проинициализировать единожды и значение не должно изменяться в процессе выполнения программы.\r\n\r\nТипы данных: Укажите тип данных, если язык программирования требует явного указания типа. В противном случае, тип может быть выведен автоматически.\r\n\r\nОбласть видимости: Константы должны объявляться в нужной области видимости, чтобы они были доступны там, где они используются.  \r\n\r\nЗаключение\r\n\r\nТаким образом расмотрев константы мы можем придти к выводу,что константы в Kotlin позволяют нам использовать и хранить постоянные значения, которые не меняются в процессе выполнения программы. Они предоставляют нам удобный способ управлять и использовать такие значения, что делает код более надежным и легким для понимания.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(12,1,3,11,30,12,5,'rus','2023-11-01',NULL,'Локализация','Для локализации приложения в Android Studio вы можете использовать ресурсы строки и файлы ресурсов. Вот шаги, которые вам понадобятся для локализации приложения:\r\n\r\nСоздайте директории ресурсов для каждого языка:\r\n\r\nВ папке res создайте новую папку с именем values-<язык>, где <язык> - это код языка (например, values-en для английского языка).\r\nСоздайте аналогичные папки для других языков, которые вы хотите поддерживать (например, values-es для испанского языка).\r\nОбычно вы также создаете папку values без указания конкретного языка, которая будет содержать значения по умолчанию.\r\nОткройте файл strings.xml в каждой папке values-<язык> и добавьте строки, которые нужно локализовать. Например:','xml\r\n%%<!-- values/strings.xml -->%%\r\n##^^<resources>^^\r\n    ##^^<string^^ name=;;\"app_name\";;^^>^^Мое приложение^^</string>^^\r\n    ##^^<string^^ name=;;\"welcome_message\";;^^>^^Добро пожаловать в наше приложение^^</string>^^\r\n##^^</resources>^^\r\n##xml\r\n##%%<!-- values-en/strings.xml -->%%\r\n##^^<resources>^^\r\n    ##^^<string^^ name=;;\"app_name\";;^^>^^My App^^</string>^^\r\n    ##^^<string^^ name=;;\"welcome_message\";;^^>^^Welcome to my app!^^</string>^^\r\n##^^</resources>^^\r\n##xml\r\n##%%<!-- values-es/strings.xml -->%%\r\n##^^<resources>^^\r\n    ##^^<string^^ name=;;\"app_name\";;^^>^^Mi Aplicación^^</string>^^\r\n    ##^^<string^^ name=;;\"welcome_message\";;^^>^^¡Bienvenido a mi aplicación!</string>^^\r\n##^^</resources>^^\r\nВ каждом файле strings.xml вы можете задать соответствующие локализованные значения для строк.\r\n\r\nВ коде вашего приложения используйте строки из ресурсов с помощью метода getString(). Например:\r\n\r\nkotlin\r\n##val **appName** = getString(R.string.**app_name**)\r\n##val **welcomeMessage** = getString(R.string.**welcome_message**)\r\n##xml\r\n##android:text=;;\"@string/welcome_message\";;',NULL,'Это позволит вашему приложению автоматически использовать правильные локализованные значения в зависимости от установленного языка устройства.\r\n\r\n(Опционально) Проверьте настройки локали устройства в эмуляторе или реальном устройстве. Вы можете изменить язык и регион в настройках системы, чтобы убедиться, что ваше приложение корректно отображает локализованные значения.\r\n\r\nВ результате ваше приложение будет поддерживать различные языки, и строки будут автоматически заменяться на соответствующие локализованные значения в зависимости от языка устройства.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(13,1,3,12,31,13,5,'rus','2023-11-01',NULL,'Модификаторы доступа','В котлин есть модификаторы доступа, которые определяют уровень видимости классов, функций, свойств и других элементов программы. Они определяют, откуда и как можно обращаться к этим элементам. Kotlin предоставляет четыре основных модификатора доступа:\r\n\r\npublic (по умолчанию):\r\nфото public \r\nЭто наименее строгий уровень доступа и применяется, если модификатор доступа явно не указан.\r\nЭлементы с модификатором доступа public доступны из любого места в программе, включая из других пакетов.\r\nprivate:\r\nфото private\r\nЭлементы с модификатором доступа private видны только в пределах того же класса, в котором они были объявлены.\r\nОни не доступны из других классов даже внутри того же пакета.\r\nprotected:\r\nфото protected:\r\nЭлементы с модификатором доступа protected доступны в пределах того же класса и его подклассов (наследников).\r\nОни также доступны внутри того же пакета.\r\ninternal:\r\nфото internal:\r\nЭлементы с модификатором доступа internal доступны внутри того же модуля (модуль - это группа связанных файлов компиляции).\r\nЭтот модификатор недоступен для Java, поскольку Kotlin модифицирует байт-код, чтобы поддерживать internal.\r\nВот примеры использования модификаторов доступа:','class Example {\r\n    ##,,,private var **privateVariable**: String = ;;\"Private variable\";;\r\n    ##,,,var **publicVariable**: String = ;;\"Public variable\";;\r\n    ##,,,protected var **protectedVariable**: String = ;;\"Protected variable\";;\r\n    ##,,,internal var **internalVariable**: String = ;;\"Internal variable\";;\r\n\r\n    ##,,,private fun ^^privateFunction^^() {\r\n        ##,,,,,,println(;;\"Private function\";;)\r\n    ##,,,}\r\n\r\n    ##,,,fun ^^publicFunction^^() {\r\n        ##,,,,,,println(;;\"Public function\";;)\r\n    ##,,,}\r\n\r\n    ##,,,protected fun ^^protectedFunction^^() {\r\n        ##,,,,,,println(;;\"Protected function\";;)\r\n    ##,,,}\r\n\r\n    ##,,,internal fun ^^internalFunction^^() {\r\n        ##,,,,,,println(;;\"Internal function\";;)\r\n    ##,,,}\r\n##}',NULL,'Модификаторы доступа играют важную роль в объектно-ориентированном программировании и вот несколько плюсов их использования:\r\nИнкапсуляция:\r\nМодификаторы доступа позволяют достичь принципа инкапсуляции, который заключается в том, что данные и методы, работающие с ними, должны быть объединены в классе и доступ к ним должен быть ограничен извне. Таким образом, можно скрыть детали реализации и предоставить публичные методы (публичный интерфейс), через которые взаимодействует внешний код с объектами класса.\r\n\r\nБезопасность:\r\nМодификаторы доступа обеспечивают безопасность кода, предотвращая несанкционированный доступ к частям программы, которые не должны быть изменены или использованы извне. Таким образом, можно избежать непредсказуемого поведения и ошибок.\r\n\r\nКонтроль доступа:\r\nМодификаторы доступа позволяют легко контролировать, какие части кода могут использовать определенные элементы программы. Например, некоторые элементы могут быть доступны только внутри класса, другие - только внутри пакета или подкласса, а некоторые могут быть доступны для всего проекта.\r\n\r\nПоддержка чистой архитектуры:\r\nМодификаторы доступа позволяют создавать чистые и модульные системы, в которых различные компоненты программы тесно связаны только через их публичные интерфейсы, и не зависят от деталей реализации.\r\n\r\nУлучшение понимания кода:\r\nПравильное использование модификаторов доступа делает код более понятным и позволяет другим разработчикам легче понимать, какие части программы являются основными, а какие служат для внутренней реализации.\r\n\r\nТак как мы еще не проходили ООП, и вам может быть не понятно для чего нужно ООП и что такое ООП вообще, но не бойтесь) У нас есть отдельная тема по этому поводу, в которой мы раскажем все об ООП.\r\n Но пока кратко скажу, ООП нужно - для улучшения организации, переиспользования, инкапсуляции, наследования, полиморфизма, читаемости и моделирования реального мира.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(14,1,3,13,32,14,5,'rus','2023-11-01',NULL,'Переменные','В прошлых уроках мы разобрались, как скачать android studio и как запустить свой проект ,тем самым создав приложение , но для создания более интересных и трудных приложения знаний только андроида мало , и поэтому в ближайших уроков мы будем изучать приемущественно котлин.И \r\nИ начинаем мы с темы- Переменные\r\nПеременная- это местов памяти,используемое для хранения данных.Переменные могут хранить различные типы значений, такие как числа, строки, булевы значения и другие объекты.\r\n\r\nВ Kotlin существует два типа переменных: изменяемые(mutable) и неизменяемые (immutable).\r\n\r\n\r\n\r\nМутабельные переменные объявляются спомощью ключевого слова var. Значение изменяемой переменной может быть изменено послеинициализации.Пример.','\r\nvar **x** = [[5[[\r\n\r\n##**x** = [[10[[',NULL,'Неизменяемые переменные объявляются спомощью ключевого словаvar. Значение неизменяемой переменной присваивается только один раз и не может быть изменено после инициализации.\r\nПример:\r\n','##val **y** = [[3[[',NULL,'При объявлении переменных в Kotlin можно явно указать тип\r\nнапример:\r\n','##var **name**: String = ;;\"John\";;\r\n\r\n##val **age**: Int = [[25[[.',NULL,'Однако в большинстве случаев Kotlin может автоматически указать тип переменной на основе присвоенного ей значения.В таких случаях нет необходимости явно указывать тип переменной:\r\n','##var **name** = ;;\"John\";; %%// Kotlin самопределяет тип String.%%\r\n\r\n##val **age** = [[25[[ %%// Kotlinопределяет тип Int.%%\r\n',NULL,'Переменные в Kotlin можно изменять или присваивать именованные значенияв любом месте кода,если они находятся в области видимости. Это облегчает управление и изменение данных в программе.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(15,1,3,14,33,15,5,'rus','2023-11-01',NULL,'Различные операции с переменными',' С переменными можно выполнять различные операции \r\nВот небольшой список операций:\r\nАрифметические операции:\r\n\r\nСложение (+)\r\nВычитание (-)\r\nУмножение (*)\r\nДеление (/)\r\nВзятие остатка (%)\r\nОперации сравнения:\r\n\r\nРавенство (==)\r\nНеравенство (!=)\r\nБольше (>)\r\nМеньше (<)\r\nБольше или равно (>=)\r\nМеньше или равно (<=)\r\nЛогические операции:\r\n\r\nЛогическое И (&&)\r\nЛогическое ИЛИ (||)\r\nЛогическое НЕ (!)\r\nОперации присваивания:\r\n\r\nПрисваивание (=)\r\nСоставное присваивание (например, +=, -=, *=, /=, %=)\r\nОперации с битами (для целочисленных типов):\r\n\r\nПобитовое И (and)\r\nПобитовое ИЛИ (or)\r\nПобитовое Исключающее ИЛИ (xor)\r\nПобитовый сдвиг влево (shl)\r\nПобитовый сдвиг вправо (shr)\r\nБеззнаковый побитовый сдвиг вправо (ushr)\r\nПобитовое отрицание (inv)\r\nОперации инкремента и декремента:\r\n\r\nИнкремент (++)\r\nДекремент (--)\r\nОперации для работы со строками:\r\n\r\nКонкатенация (+)\r\nМетоды работы со строками (например, substring(), length, startsWith(), endsWith() и т.д.)\r\nОперации для работы с коллекциями (списки, множества и т.д.):\r\n\r\nДобавление элемента (add())\r\nУдаление элемента (remove())\r\nПоиск элемента (contains())\r\nОбъединение коллекций (union(), plus())\r\nИнтерсекция коллекций (intersect())\r\nЭто далеко не полный список, но эти операции покрывают большую часть основных операций, которые можно выполнять с переменными в Kotlin.\r\n\r\nЯ хочу сейчас показать небольшой пример, но для простаты я сделаю это не в активити , а в файле. Вот как можно создать файл:\r\nпоказы в фото(создание и запуск )\r\nАрифметические операции:',' fun ^^main^^() {\r\n    ##,,,val **num1**: Int = [[10[[\r\n    ##,,,val **num2**: Int = [[5[[\r\n\r\n    ##,,,val **sum** = **num1** + **num2**\r\n    ##,,,println(;;\"Сумма: $sum\";;)\r\n\r\n    ##,,,val **difference** = **num1** - **num2**\r\n    ##,,,println(;;\"Разница: $difference\";;)\r\n\r\n    ##,,,val **product** = **num1** * **num2**\r\n    ##,,,println(;;\"Произведение: $product\";;)\r\n\r\n    ##,,,val **quotient** = **num1** / **num2**\r\n    ##,,,println(;;\"Частное: $quotient\";;)\r\n\r\n    ##,,,val **remainder** = **num1** % **num2**\r\n    ##,,,println(;;\"Остаток от деления: $remainder\";;)\r\n##}',NULL,'Операции сравнения:','##fun ^^main^^() {\r\n    ##,,,val **num1**: Int = [[10[[\r\n    ##,,,val **num2**: Int = [[5[[\r\n\r\n    ##,,,val **isEqua**l = **num1** == **num2**\r\n    ##,,,println(;;\"Числа равны: $isEqual\";;)\r\n\r\n    ##,,,val **isNotEqual** = **num1** != **num2**\r\n    ##,,,println(;;\"Числа не равны: $isNotEqual\";;)\r\n\r\n    ##,,,val **isGreater** = **num1** > **num2**\r\n    ##,,,println(;;\"Первое число больше второго: $isGreater\";;)\r\n\r\n    ##,,,val **isLess** = **num1** < **num2**\r\n    ##,,,println(;;\"Первое число меньше второго: $isLess\";;)\r\n\r\n    ##,,,val **isGreaterOrEqual** = **num1** >= **num2**\r\n    ##,,,println(;;\"Первое число больше или равно второму: $isGreaterOrEqual\";;)\r\n\r\n    ##,,,val **isLessOrEqual** = **num1** <= **num2**\r\n    ##,,,println(;;\"Первое число меньше или равно второму: $isLessOrEqual\";;)\r\n##}',NULL,'Логические операции:','##fun ^^main^^() {\r\n    ##,,,val **a**: Boolean = true\r\n    ##,,,val **b**: Boolean = false\r\n\r\n    ##,,,val **resultAnd** = **a** && **b**\r\n    ##,,,println(;;\"Логическое И: $resultAnd\";;)\r\n\r\n    ##,,,val **resultOr** = **a** || **b**\r\n    ##,,,println(;;\"Логическое ИЛИ: $resultOr\";;)\r\n\r\n    ##,,,val **resultNotA** = !a\r\n    ##,,,println(;;\"Логическое НЕ для a: $resultNotA\";;)\r\n\r\n    ##,,,val **resultNotB** = !b\r\n    ##,,,println(;;\"Логическое НЕ для b: $resultNotB\";;)\r\n##}',NULL,'Операции присваивания:','##fun ^^main^^() {\r\n    ##,,,var **x**: Int = [[5[[\r\n\r\n    ##,,,x += 3 %%// x = x + 3%%\r\n    ##,,,println(;;\"x после сложения: $x\";;)\r\n\r\n    ##,,,x -= 2 %%// x = x - 2%%\r\n    ##,,,println(;;\"x после вычитания: $x\";;)\r\n\r\n    ##,,,x *= 4 %%// x = x * 4%%\r\n    ##,,,println(;;\"x после умножения: $x\";;)\r\n\r\n    ##,,,x /= 2 %%// x = x / 2%%\r\n    ##,,,println(;;\"x после деления: $x\";;)\r\n\r\n    ##,,,x %= 3 %%// x = x % 3%%\r\n    ##,,,println(;;\"x после взятия остатка: $x\";;)\r\n##}',NULL,'Операции инкремента и декремента:','##fun ^^main^^() {\r\n    ##,,,var **x**: Int = [[5[[\r\n\r\n    ##,,,x++\r\n    ##,,,println(;;\"Значение x после инкремента: $x\";;)\r\n\r\n    ##,,,x--\r\n    ##,,,println(;;\"Значение x после декремента: $x\";;)\r\n##}',NULL,'Операции для работы со строками:','##fun ^^main^^() {\r\n    ##,,,val **firstName** = ;;\"John\";;\r\n    ##,,,val **lastName** = ;;\"Doe\";;\r\n\r\n    ##,,,val **fullName** = **firstName** + \" \" + **lastName**\r\n    ##,,,println(;;\"Полное имя: $fullName\";;)\r\n\r\n    ##,,,val **greetings** = ;;\"Hello, \";;.plus(**firstName**).plus(;;\"!\";;)\r\n    ##,,,println(greetings)\r\n\r\n    ##,,,val **message** = ;;\"The length of the full name is ${fullName.length} characters.\";;\r\n    ##,,,println(message)\r\n##}',NULL,'Операции для работы с коллекциями:\r\nМы расмотрим уже в теме про коллекции',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(16,1,3,15,34,16,5,'rus','2023-11-01',NULL,'Типы данных','=Данные в переменных=\r\nВ Kotlin есть набор встроенных типов, которые представляют числа. Для целых чисел существует четыре типа с разными размерами и, следовательно, разными диапазонами значений.\r\n\r\n|Тип  |Размер (биты)|Минимальное значение	      |Максимальное значение              |\r\n|     |             |                                 |                                   |\r\n|Byte |8	    |-128	                      |127                                |\r\n|Short|16	    |-32768	                      |32767                              |\r\n|Int  |32	    |-2,147,483,648 (-231)	      |2,147,483,647 (231 - 1)            |\r\n|Long |64	    |-9,223,372,036,854,775,808 (-263)|9,223,372,036,854,775,807 (263 - 1)|\r\n\r\nДля действительных чисел в Kotlin есть типы с плавающей точкой Float и Double. Типы с плавающей точкой различаются своим десятичным разрядом, то есть количеством десятичных цифр, которые они могут хранить. Float является одинарно точным, а Double обеспечивает двойную точность.\r\n\r\n|Тип   |Размер (биты)|Значимые биты|Биты экспоненты|Разряды|\r\n|      |             |             |               |       |\r\n|Float |32	     |24	   |8	           |6-7    |\r\n|Double|64	     |53	   |11	           |15-16  |\r\n\r\nВы можете инициализировать переменные Double и Float числами, имеющими дробную часть. Она должна быть отделена от целой части точкой (.). Для переменных, инициализированных дробными числами, компилятор автоматически определяет тип Double. \r\nОбратите внимание, что в отличие от некоторых других языков, в Kotlin нет неявных преобразований для чисел. Например, функция с Double параметром может вызываться только для Double, но не для Float, Int или других числовых значений.\r\n\r\nТакже в есть тип данных String, этот тип данных предназначен для работы со строками . \r\nИнтересный факт(Этот класс является неизменяемым(immutable) и это значит,что после того, как вы создадите переменную с этим типо данных, то уже нельза будет поменять значение и если вы все таки поменяли значение, то эта переменная пересоздается и добавляется ваше новое значение)\r\nпример работы со строками :','val **text** = ;;\"Hello, Kotlin\";;\r\n##println(**text**.length) %%// Вывод: 14%%\r\n##println(**text**.toUpperCase()) %%// Вывод: HELLO, KOTLIN%%\r\n##println(**text**.substring([[7[[)) %%// Вывод: Kotlin%%',NULL,'В классе String нет явного ограничения на максимальное значение или размер строки, но на практике, размер строки в Kotlin ограничен доступной оперативной памятью вашего устройства. Если вы пытаетесь создать или использовать очень большую строку, которая превышает доступную память, может возникнуть исключение OutOfMemoryError.\r\nНо если вам требуется хранить или обрабатывать очень большие объемы текста или данных, возможно, вам потребуется разделить их на более мелкие части или использовать специализированные структуры данных или библиотеки, которые оптимизированы для работы с большими объемами данных. \r\n\r\n=Boolean=\r\nтип Boolean представляет логический тип данных, который может принимать два значения: true и false. Boolean используется для представления логических условий, выполнения проверок и управления потоком программы.\r\nВот небольшой пример использования Boolean:\r\n','##val **x** = [[5[[\r\n##val **y** = [[10[[\r\n##val **isEqual** = **x** == **y** %%// Сравнение на равенство%%\r\n##println(**isEqual**) %%// Вывод: false%%\r\n\r\n##val **isGreater** = **x** > **y** %%// Сравнение на больше%%\r\n##println(**isGreater**) %%// Вывод: false%%\r\n\r\n##val **isLessOrEqual** = **x** <= **y** %%// Сравнение на меньше или равно%%\r\n##println(**isLessOrEqual**) %%// Вывод: true%%',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(17,1,3,16,35,17,5,'rus','2023-11-01',NULL,'Функции','Что такое функции?\r\nФункции - это блоки кода, которые выполняют определенные действия или вычисления.\r\n Они позволяют разбить программу на мелкие логические единицы, которые можно вызывать из других частей программы. \r\nФункции облегчают чтение, понимание и сопровождение кода.\r\n\r\n=Объявление функций=\r\nФункции объявляются с использованием ключевого слова fun, за которым следует имя функции, а затем список параметров в скобках. \r\nВозвращаемый тип функции указывается после имени функции и двоеточия.','%%// Пример функции без параметров и без возвращаемого значения%%\r\n##fun ^^sayHello^^() {\r\n    ##,,,println(;;\"Hello, Kotlin!\";;)\r\n##}\r\n\r\n##%%// Пример функции с параметрами и возвращаемым значением%%\r\n##fun ^^sum^^(a: Int, b: Int): Int {\r\n    ##,,,return a + b\r\n##}',NULL,'=Вызов функций=\r\nДля вызова функции необходимо указать ее имя, а также передать аргументы, если функция принимает параметры.\r\n Если функция возвращает значение, его можно сохранить в переменной или использовать в других выражениях.','##fun ^^main^^() {\r\n    ##,,,^^sayHello^^() %%// Вызов функции без параметров и возвращаемого значения%%\r\n\r\n    ##,,,val **result** = ^^sum^^(5, 3) %%// Вызов функции с параметрами и возвращаемым значением%%\r\n    ##,,,println(;;\"Сумма равна: $result\";;)\r\n##}',NULL,'=Параметры функций=\r\nФункции могут принимать ноль или более параметров.\r\n Параметры - это значения, которые передаются в функцию при ее вызове и используются внутри функции для выполнения операций.','##fun ^^greetUser^^(**name**: String) {\r\n    ##,,,println(;;\"Hello, $name!\";;)\r\n##}\r\n\r\n##fun ^^multiply^^(a: Int, b: Int): Int {\r\n    ##,,,return a * b\r\n##}',NULL,'=Возвращаемые значения=\r\nФункции могут возвращать значения с помощью оператора return. \r\nЕсли функция возвращает значение, то необходимо указать его тип после двоеточия в объявлении функции.\r\n Если функция не должна ничего возвращать, используется тип Unit.','##%%// Функция с возвращаемым значением%%\r\n##fun ^^multiply^^(a: Int, b: Int): Int {\r\n    ##,,,return a * b\r\n##}\r\n\r\n##%%// Функция без возвращаемого значения (тип Unit может быть опущен)%%\r\n##fun ^^printMessage^^(**message**: String) {\r\n    ##,,,println(**message**)\r\n##}',NULL,'=Значения по умолчанию для параметров=\r\nПараметры функций могут иметь значения по умолчанию, что позволяет вызывать функцию с неполным набором аргументов.','##fun ^^printInfo^^(**name**: String, **age**: Int = [[30[[) {\r\n    ##,,,println(;;\"Name: $name, **Age**: $age\";;)\r\n}\r\n\r\n##fun ^^main^^() {\r\n    ##,,,printInfo(;;\"Alice\";;) %%// Возраст не указан, используется значение по умолчанию (30)%%\r\n    ##,,,printInfo(;;\"Bob\";;, [[25[[) %%// Указаны имя и возраст%%\r\n##}',NULL,'=Перегрузка функций=\r\nВ Kotlin можно объявлять несколько функций с одним и тем же именем, но с разными параметрами (перегрузка функций).','##%%// Функция для сложения целых чисел%%\r\n##fun ^^sum^^(a: Int, b: Int): Int {\r\n    ##,,,return a + b\r\n##}\r\n\r\n##%%// Функция для сложения дробных чисел%%\r\n##fun ^^sum^^(a: Double, b: Double): Double {\r\n    ##,,,return a + b\r\n##}\r\n\r\n##fun ^^main^^() {\r\n    ##,,,val **intResult** = ^^sum^^([[5[[, [[3[[) %%// Вызов функции с Int параметрами%%\r\n    ##,,,val **doubleResult** = ^^sum^^([[2.5[[, [[3.7[[) %%// Вызов функции с Double параметрами%%\r\n    ##,,,println(;;\"Sum of integers: $intResult\";;)\r\n    ##,,,println(;;\"Sum of doubles: $doubleResult\";;)\r\n##}',NULL,'=Заключение=\r\nФункции - это важный инструмент в языке программирования Kotlin. \r\nОни помогают разбивать код на логические блоки, делают программы более модульными и улучшают повторное использование кода.\r\nПри написании своих программ, обязательно используйте функции для улучшения структуры и организации кода.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(18,1,3,17,36,18,5,'rus','2023-11-01',NULL,'Lateinit','В данном уроке мы расмотрим ключевое слово lateinit, которое используется для отложенной инициализации переменных, то есть для объявления переменных, которые не нужно инициализировать сразу при объявлении, но которые должны быть проинициализированы до того, как к ним обратятся впервые. Обратите внимание, что lateinit может использоваться только для переменных с неизменяемым типом и только для типов, которые не допускают значения null.\r\n\r\nВот пример использования lateinit:\r\nфото (lateinit)\r\n','class Example {\r\n    ,,,##%%// Переменная с отложенной инициализацией%%\r\n    ,,,##lateinit var **lateInitializedString**: String\r\n\r\n    ,,,##%%// Функция, которая будет вызвана для инициализации переменной%%\r\n    ,,,##fun ^^initializeString^^() {\r\n        ,,,,,,##**lateInitializedString** = ;;\"Это значение будет проинициализировано позже\";;\r\n    ,,,##}\r\n\r\n    ,,,##%%// Функция, которая использует переменную с отложенной инициализацией%%\r\n    ,,,##fun ^^printString^^() {\r\n        ,,,,,,##println(**lateInitializedString**)\r\n    ,,,##}\r\n##}\r\n\r\n##fun ^^main^^() {\r\n    ,,,##val **example** = Example()\r\n    \r\n    ,,,##%%// Вызываем функцию для инициализации переменной%%\r\n    ,,,##**example**.initializeString()\r\n    \r\n    ,,,##%%// Вызываем функцию, которая использует переменную с отложенной инициализацией%%\r\n    ,,,##**example**.printString()\r\n##}',NULL,'В данном примере у нас есть класс Example с переменной lateInitializedString, которая объявлена с использованием lateinit. Мы определяем функцию initializeString(), которая инициализирует эту переменную значением. Затем у нас есть функция printString(), которая выводит значение переменной, если она была проинициализирована, или выводит сообщение о том, что переменная не была инициализирована, если она осталась неинициализированной.\r\n\r\nОбратите внимание, что если вы попытаетесь воспользоваться переменной до того, как она будет инициализирована , то у вас может возникнуть исключение UninitializedPropertyAccessException.\r\nДля избежания этой проблемы можно использовать условный оператор :','##class Example {\r\n    ##,,,lateinit var **lateInitializedString**: String\r\n\r\n    ##,,,fun initializeString() {\r\n        ##**,,,,,,lateInitializedString** = \"Это значение будет проинициализировано позже\"\r\n    ##,,,}\r\n\r\n    ##,,,fun printString() {\r\n        ##,,,,,,if (::**lateInitializedString**.isInitialized) {\r\n            ##,,,,,,,,,println(**lateInitializedString**)\r\n        ##,,,,,,} else {\r\n            ##,,,,,,,,,println(\"Переменная lateInitializedString не была инициализирована\")\r\n        ##,,,,,,}\r\n    ##,,,}\r\n##}\r\n\r\n##fun main() {\r\n    ,,,##val **example** = Example()\r\n    ,,,##**example**.initializeString()\r\n    ,,,##**example**.printString()\r\n##}',NULL,'Хоть мы и не проходили условные операторы , но я решил показать вам как можно исключить появления исключения и также я показал очень простой пример, а именно я просто проверяю\r\n (если)if(::lateInitializedString.isInitialized) и тут с помощью isInitialized, которое дает нам true если инициализирована и false в противном случае . Если нам пришло true мы просто выводим переменную, а если false, то выводим предупреждение  println(\"Переменная lateInitializedString не была инициализирована\")\r\n\r\nВы  еще могли заметить, что мы используем \'::\', это позволяет проверить статус инициализации переменной, без \'::\' мы бы не смогли вызвать isInitialized\r\n(фото lateinit это зло)\r\nНа первый взгляд использоание lateinit не несет в себе ничего плохого , но бывают такие случаи, когда lateinit может привести к багу, который потом будет трудно обнаружить и поэтому использовать lateinit рекомендуется использовать только в крайних случаях или когда вы уверены, что все безопасно.\r\nМожно сделать итог: использовать lateinit нужно только в необходимых случаях или когда все безопасно , а если нет необходимости lateinit , то тогда лучше использовать поле nullable',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(19,1,4,18,37,19,6,'rus','2023-11-01',NULL,'Безопасные вызовы и оператор elvis','=Введение в Null Safety=\r\n\r\nKotlin предоставляет механизм Null Safety для более безопасной работы с null значениями. Null Safety помогает предотвратить ошибки NullPointerException, которые часто возникают при работе с null.\r\n\r\nШаг 2: =Объявление nullable и non-nullable переменных=\r\n\r\nNullable переменные: Обозначаются с помощью ? после типа данных. Такие переменные могут содержать значение null.\r\nNon-nullable переменные: Обозначаются без ? и не могут содержать null. Компилятор обеспечивает безопасность на этапе компиляции, чтобы такие переменные не принимали null.\r\nПример объявления переменных:','##val **nullableVariable**: String? = null\r\n##val **nonNullableVariable**: String = \"Hello\"',NULL,'=Шаг 3: Безопасные вызовы (Safe calls)=\r\n\r\nБезопасные вызовы позволяют вызывать методы или обращаться к свойствам nullable переменных без опасения получения ошибки NullPointerException.\r\n\r\nСинтаксис безопасного вызова:\r\n\r\n\r\nnullableVariable?.методИлиСвойство\r\nПример безопасного вызова:','##val **name**: String? = null\r\n##val **length** = name?.length',NULL,'=Шаг 4: Оператор Элвис (Elvis operator)=\r\n\r\nОператор Элвис позволяет устанавливать значение по умолчанию для nullable переменных, если они содержат null.\r\n\r\nСинтаксис оператора Элвис:','##val **result** = nullableVariable ?: значение_по_умолчанию',NULL,'Пример оператора Элвис:\r\n','##val **name**: String? = null\r\n##val **result** = name ?: \"Гость\"',NULL,'=Шаг 5: Smart Casts (Умные приведения)=\r\n\r\nKotlin использует умные приведения, чтобы автоматически преобразовывать nullable переменные в non-nullable после проверки на null.\r\n\r\nПример умного приведения:','##fun ^^printLength^^(str: String?) {\r\n    ##if (str != null) {\r\n        ##println(\"Длина строки: ${str.length}\") // str автоматически преобразуется в non-nullable\r\n    ##} else {\r\n        ##println(\"Строка равна null\")\r\n    ##}\r\n##}',NULL,'=Шаг 6: Оператор Non-null утверждения (Non-null assertion operator)=\r\n\r\nОператор Non-null утверждения позволяет явно указать, что переменная не содержит null. Однако его использование следует ограничивать, так как неправильное применение может привести к NullPointerException.Оператор Non-null стоит использовать только в тех случаях, когда вы на 100% уверены ,что вам не придет null\r\n\r\nСинтаксис оператора Non-null утверждения:','##val **nonNullableVariable**: String = nullableVariable!!',NULL,'=Шаг 7: Заключение=\r\n\r\nNull Safety в Kotlin - это мощный инструмент для предотвращения ошибок NullPointerException. ',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(20,1,4,19,38,20,6,'rus','2023-11-01',NULL,'Оператор when','=Оператор when=\r\n\r\nОператор when в Kotlin является универсальным инструментом для замены множественных условных операторов (if-else, switch(java)) в других языках программирования. Он позволяет проверять различные значения переменных и выполнять соответствующие действия в зависимости от значений.\r\n\r\nСинтаксис оператора when:','##when (переменная) {\r\n    ##значение1 -> действие1\r\n    ##значение2 -> действие2\r\n    ##%%// ...%%\r\n    ##else -> действие_по_умолчанию\r\n##}',NULL,'Примеры оператора when:','##val **dayOfWeek** = 3\r\n##when (**dayOfWeek**) {\r\n    ##1 -> println(\"Понедельник\")\r\n    ##2 -> println(\"Вторник\")\r\n    ##3 -> println(\"Среда\")\r\n    ##4, 5 -> println(\"Четверг или Пятница\")\r\n    ##in 6..7 -> println(\"Выходные дни\")\r\n    ##else -> println(\"Неизвестный день\")\r\n##}',NULL,'В приведенном примере dayOfWeek имеет значение 3, поэтому выполнится блок кода для соответствующего значения, и будет выведено \"Среда\".\r\n\r\nМожно использовать различные типы данных в операторе when, такие как числа, строки, перечисления и даже проверять на условия.\r\n\r\n=Шаг 2: Операторы диапазона=\r\n\r\nОператоры диапазона позволяют создавать последовательности значений.\r\n\r\nОператор ..:\r\n\r\nОператор \'..\' создает диапазон чисел включительно.\r\n\r\n','##val **range** = 1..5\r\n##println(**range**) %%// Выведет: 1..5%%',NULL,'Оператор until:\r\n\r\nСоздает диапазон чисел не включая верхнюю границу.','##val **range** = 1 until 5\r\n##println(**range**) %%// Выведет: 1 until 5%%',NULL,'Применение операторов диапазона:\r\n\r\nСначала вам может быть не понятно, как и где использовать операторы диапазона, но в будущем при изучение циклов и списков , а также, при решение других задач, мы будет активно пользоваться этими операторами на практике.\r\n\r\n=Заключение:=\r\n\r\nМы изучили другие важные конструкции в Kotlin: оператор when и операторы диапазона . Эти конструкции позволяют сделать ваш код более удобным и эффективным. При применении этих конструкций в своих программных проектах вы сможете написать более гибкий и устойчивый код.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(21,1,4,20,39,21,6,'rus','2023-11-01',NULL,'Операторы сравнения и взаимодействия операторов','=Введение в операторы сравнения=\r\n\r\nОператоры сравнения - это инструменты, позволяющие сравнивать значения и определять, какое из них больше, меньше, равно или не равно другому. Они играют важную роль в условных выражениях, где решения принимаются на основе результатов этих сравнений.\r\n\r\n=Операторы сравнения=\r\n\r\nВ Kotlin используются следующие операторы сравнения:\r\n\r\n> (больше): Проверяет, является ли значение слева от оператора больше значения справа.\r\n< (меньше): Проверяет, является ли значение слева от оператора меньше значения справа.\r\n>= (больше или равно): Проверяет, является ли значение слева от оператора больше или равно значению справа.\r\n<= (меньше или равно): Проверяет, является ли значение слева от оператора меньше или равно значению справа.\r\n== (равно): Проверяет, равны ли значения справа и слева от оператора.\r\n!= (не равно): Проверяет, не равны ли значения справа и слева от оператора.\r\nПримеры операторов сравнения:','\r\n##val **x** = 5\r\n##val **y** = 10\r\n\r\n##println(**x** > **y**)  %%// false%%\r\n##println(**x** < **y**)  %%// true%%\r\n##println(**x** >= **y**) %%// false%%\r\n##println(**x** <= **y**) %%// true%%\r\n##println(**x** == **y**) %%// false%%\r\n##println(**x** != **y**) %%// true%%',NULL,' =Логические операторы=\r\n\r\nЛогические операторы позволяют объединять или инвертировать условия для более сложных проверок. В Kotlin используются следующие логические операторы:\r\n\r\n&& (логическое \"и\" - AND): Возвращает true, если оба условия истинны.\r\n|| (логическое \"или\" - OR): Возвращает true, если хотя бы одно из условий истинно.\r\n! (логическое отрицание - NOT): Инвертирует значение условия.\r\nПримеры логических операторов:','##val **a** = true\r\n##val **b** = false\r\n\r\n##println(**a** && **b**) %%// false%%\r\n##println(**a** || **b**) %%// true%%\r\n##println(!**a**)     %%// false%%\r\n##println(!**b**)     %%// true%%\r\n',NULL,'=Комбинирование операторов сравнения и логических операторов=\r\n\r\nВажное применение операторов сравнения и логических операторов заключается в комбинировании их для выполнения сложных условий. Это позволяет строить множественные проверки и принимать различные решения в зависимости от различных условий.\r\n\r\nПример комбинирования операторов:','##val **age** = 25\r\n\r\n##if (**age** >= 18 && **age** <= 60) {\r\n    ##println(\"Вы взрослый и работоспособный\")\r\n##} else if (**age** > 60) {\r\n    ##println(\"Вы пенсионер\")\r\n##} else {\r\n    ##println(\"Вы несовершеннолетний\")\r\n##}',NULL,'В этом примере программа проверяет возраст и выводит разные сообщения, в зависимости от значения переменной age. Если возраст находится в диапазоне от 18 до 60 лет включительно, выводится сообщение \"Вы взрослый и работоспособный\". Если возраст больше 60 лет, выводится сообщение \"Вы пенсионер\". В противном случае выводится сообщение \"Вы несовершеннолетний\".\r\n\r\n =Заключение=\r\n\r\nОператоры сравнения и логические операторы являются мощными инструментами для программирования условных выражений. Они позволяют',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(22,1,4,21,40,22,6,'rus','2023-11-01',NULL,'Тернарный оператор','=Введение в тернарный оператор=\n														\nТернарный оператор - это специальный вид условного обозначения, который позволяет уменьшить код, заменяя плоскую if-elseконструкцию на более компактную форму.\n\nПримеры использования тернарного оператора:\nПрисвоение максимального значения из двух значений чисел:','##val **a** = 15\n##val **b** = 8\n##val **max** = if (**a** > **b**) **a** else **b**\n##println(**a**)%%//15%%',NULL,'Вывод сообщений в зависимости от результата проверки:','##val **isRaining** = true\n##val **weather** = if (**isRaining**) \"Пойдет дождь\" else \"Солнечно\"\n##println(weather)%%//Пойдет дождь%%',NULL,' =Преимущества и ограничения тернарного оператора=\n\nпреимущества тернарного оператора:\n\nКраткий и лаконичный синтаксис, который делает код более читабельным и компактным.\nУдобен, когда требуется просто и быстро установить значение на основе условий.\n ограничения тернарного оператора:\n\nНе рекомендуется для сложных условий с множественными ветвлениями.\nНе подходит, если требуется выполнение нескольких действий в различных ветках.\n\n=Вывод=\n\nТернарный оператор - это удобный инструмент в Kotlin для точных измерений и определения значений переменных. Ученики должны понимать, как использовать тернарный оператор и когда он уместен для упрощения кода. Попросите создать собственные примеры использования тернарного оператора для закрепления материала.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(23,1,4,22,41,23,6,'rus','2023-11-01',NULL,'Условные выражения','=Условные выражения=\n\nУсловные выражения - это конструкции, которые вы будете видеть и использовать в каждом проекте , они позволяют программе принимать решения в зависимости от выполнения определенных условий. В Kotlin для создания условных выражений используются ключевые слова if, else if и else.\n\n=Основной синтаксис условного выражения if=\n\nНаиболее простой вид условного выражения в Kotlin - это if. Он выполняет код внутри блока, если указанное условие истинно (true). Если условие ложно (false), код в блоке if пропускается.','##if (условие) {\n    ##%%// Код, который выполняется, если условие истинно(true)%%\n##}',NULL,'Пример использования if','##val **age** = 20\n\n##if (**age** >= 18) {\n    ##println(\"Вы совершеннолетний\")\n##}',NULL,'В этом примере, если значение переменной age равно или больше 18, то выведется сообщение \"Вы совершеннолетний\". Если age меньше 18, блок if будет пропущен, и ничего не будет выведено.',NULL,NULL,'=Использование else=\n\nКонструкция else добавляется после блока if для выполнения альтернативных действий, когда условие в if ложно.','##if (условие) {\n    ##%%// Код, который выполняется, если условие истинно%%\n##} else {\n    ##%%// Код, который выполняется, если условие ложно%%\n##}',NULL,'Пример использования else','##val **number** = 5\n\n##if (**number** % 2 == 0) {\n    ##println(\"Число $number четное\")\n##} else {\n    ##println(\"Число $number нечетное\")\n##}',NULL,'Здесь программа проверяет, является ли число number четным или нечетным. Если число делится на 2 без остатка, то выводится сообщение \"Число $number четное\", в противном случае выводится \"Число $number нечетное\".\n =Использование else if=\n\nКогда вам нужно проверить несколько альтернативных условий, используется else if.','##if (условие1) {\n    ##%%// Код, который выполняется, если условие1 истинно%%\n##} else if (условие2) {\n    ##%%// Код, который выполняется, если условие2 истинно%%\n##} else {\n    ##%%// Код, который выполняется, если ни одно из условий не истинно%%\n##}',NULL,'Пример использования else if','##if (**score** >= 90) {\n    ##println(\"Отлично!\")\n##} else if (**score** >= 80) {\n    ##println(\"Хорошо\")\n##} else if (**score** >= 70) {\n    ##println(\"Удовлетворительно\")\n##} else {\n    ##println(\"Неудовлетворительно\")\n##}',NULL,'В этом примере программа выводит разные сообщения в зависимости от значения переменной score.\n=Использование if как выражения=\n\nВ Kotlin, if также может быть использован как выражение, возвращающее значение.','##val **result** = if (условие) {\n    ##%%// Возвращаемое значение, если условие истинно%%\n##} else {\n    ##%%// Возвращаемое значение, если условие ложно%%\n##}\', \'Пример использования if как выражения\', \'##val **number** = 10\n##val **result** = if (**number** > 0) {\n    ##\"Положительное\"\n##} else {\n    ##\"Отрицательное\"\n##}\n\n##println(result)',NULL,'=Заключение=\n Условные выражения - это важный инструмент для программирования, который позволяет программам принимать решения и выполнять различные действия в зависимости от условий. Умение писать условные выражения является фундаментальным навыком для каждого программиста.',NULL,NULL,NULL,NULL),(24,1,4,23,42,24,6,'rus','2023-11-01',NULL,'Deprecated','Когда вам приходится работать с различными библиотеками или фреймворками в программировании, иногда вы можете столкнуться с термином \"Deprecated\" . Deprecated - это пометка, которая указывает на то, что определенный элемент (метод, функция, класс, свойство и т. д.) устарел и может быть удален из будущих версий программного обеспечения. Такие элементы больше не рекомендуются к использованию, поскольку могут быть заменены или устранены из кодовой базы в будущем.\n\nПометка Deprecated используется для того, чтобы предупредить разработчиков о том, что определенный элемент более не является предпочтительным или рекомендуемым. Вместо этого, разработчики должны использовать альтернативные способы, которые предоставляются в новых версиях библиотеки или фреймворка.\n\nПри использовании Deprecated элемента компилятор или среда разработки может выдавать предупреждение или сообщение об использовании устаревшего элемента. Но код все еще будет работать до тех пор, пока элемент не будет полностью удален из кодовой базы.\n\nПример использования Deprecated в Kotlin:','##@Deprecated(\"This function is deprecated. Use newFunction() instead.\")\n##fun ^^oldFunction^^() {\n    ##%%// Код старой функции%%\n##}\n\n##fun ^^newFunction^^() {\n    ##%%// Код новой функции\n##}',NULL,'В этом примере у нас есть функция oldFunction(), которая помечена как Deprecated с помощью аннотации @Deprecated. В сообщении аннотации указано, что эта функция устарела, и вместо нее следует использовать newFunction(). Когда разработчики будут использовать oldFunction(), компилятор или среда разработки выдаст предупреждение о том, что функция устарела и рекомендуется использовать newFunction().\n\nКогда вы сталкиваетесь с элементами, помеченными как Deprecated, важно обратить внимание на предупреждения и переключиться на рекомендуемые альтернативы. Это поможет обеспечить поддержку вашего кода в будущих версиях программного обеспечения и избежать проблем, связанных с использованием устаревших элементов.\nКак заменить Deprecated элемент \nОбычно, с \"Deprecated\" вы будете сталкиваться, когда вы вызываете какой-либо элемент, и этот элемент будет зачеркнут, тем самым обозначаясь \"Deprecated\". Для того чтобы заменить устаревший элемент, просто воспользуйтесь Гуглом, введите название элемента и слово \"Deprecated\", и переходите по любой ссылке, и меняйте устаревший элемент.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(25,1,5,24,43,25,7,'rus','2023-11-01',NULL,'Бесконечные циклы и ограничения','=Бесконечные циклы и ограничения=\nВ этом уроке мы рассмотрим бесконечные циклы и ограничения, связанные с их использованием. Бесконечные циклы - это циклы, которые выполняются бесконечно долго, до тех пор, пока не будет явно прервано выполнение программы или не будет выполнено какое-либо условие для выхода из цикла.\n\n=Бесконечные циклы=\nБесконечные циклы могут быть полезны, когда вы хотите создать программу, которая будет работать непрерывно и выполнять определенные действия или служить сервером, который ждет запросов от клиентов.\n Однако, использование бесконечных циклов требует осторожности, чтобы избежать зацикливания программы и потери производительности.\n\nПример бесконечного цикла:','##fun ^^main^^() {\n    ##while (true) {\n       ##println(\"Этот цикл выполняется бесконечно\")\n    ##}\n##}',NULL,'=Ограничения бесконечных циклов=\nОграничения связанные с бесконечными циклами:\n\nПроизводительность: Бесконечные циклы могут привести к высокому использованию процессора и памяти, что может снизить производительность программы или даже вызвать зависание.\n\nЗацикливание: Ошибки в условиях выхода из цикла или отсутствие условия выхода вообще может привести к зацикливанию программы, когда она не будет выполняться дальше и потреблять все ресурсы.\n\nПрерывание программы: Для завершения программы с бесконечным циклом, вы должны явно прервать ее выполнение, например, используя комбинацию клавиш (например, Ctrl+C) или другой механизм завершения программы.\n\n=Использование ограничений=\nДля избежания проблем, связанных с бесконечными циклами, рекомендуется использовать условия выхода из цикла, основанные на определенных событиях или значениях. \nЭто может быть условие завершения задачи, достижение определенного значения или время выполнения.\n\nПример с использованием условия выхода:','##fun ^^main^^() {\n    ##var **counter** = 0\n    ##val **maxCount** = 10\n\n    ##while (**counter** < **maxCount**) {\n        ##println(\"Цикл выполняется. Счетчик: $counter\")\n        ##**counter**++\n    ##}\n##}',NULL,'В этом примере мы используем цикл while, который будет выполняться до тех пор, пока значение счетчика counter меньше maxCount. Когда counter достигает maxCount, цикл завершается.\n\n=Заключение=\nБесконечные циклы могут быть полезны в некоторых ситуациях, но их использование должно быть обосновано и осторожно настроено, чтобы избежать проблем с производительностью и зацикливанием программы.\n Используйте условия выхода из цикла, чтобы контролировать его выполнение и предотвратить его бесконечное исполнение.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(26,1,5,25,44,26,7,'rus','2023-11-01',NULL,'Вложенные циклы в Kotlin','В этом уроке мы рассмотрим вложенные циклы на языке программирования Kotlin и научимся использовать их для обхода двумерных структур данных, таких как матрица, и для выполнения повторяющихся операций в программах других циклов.\n\n=Что такое вложенные циклы?=\nВложенные циклы - это циклы, находящиеся внутри другого цикла. Полный итерационный цикл внешнего цикла. Таким образом, каждая итерация внешних циклов будет сочетаться со всеми итерациями внутренних циклов.\n\nПримеры использования вложенных циклов\nПример 1: Вложенные циклы для вывода таблицы умножения','##fun ^^main^^() {\n    ##for (i in 1..5) {\n        ##for (j in 1..5) {\n            ##print(\"${i * j}\\t\")\n        ##}\n        ##println()\n    ##}\n##}',NULL,'=Объяснение кода:=\n\nВо внешнем цикле for (i in 1..5)переменная iитерируется по значениям от 1 до 5 (включительно).\n\nВнутри внешнего цикла у нас есть вложенный цикл for (j in 1..5). Переменная jитерируется также по значениям от 1 до 5 (включительно).\n\nКаждая итерация внутреннего цикла выводит результат умножения i * jс табулированием ( \\t) после каждого значения. Например, для i = 1внутреннего цикла прохождения значения jот 1 до 5, выводя результаты умножения 1 * 1, 1 * 2, ..., 1 * 5.\n\nКогда завершается выполнение внутреннего цикла, у нас есть оператор println(), который включает перевод строки для вывода таблицы каждой следующей строки.\n\nВ настоящее время наблюдается умножение числа от 1 до 5.\n\nВывод: 1    2    3    4    5    \n2    4    6    8    10    \n3    6    9    12    15    \n4    8    12    16    20    \n5    10    15    20    25    Пример 2: Вложенные циклы для обхода двумерного массива','##fun ^^main^^() {\n    ##val **matrix** = arrayOf(\n        ##intArrayOf(1, 2, 3),\n        ##intArrayOf(4, 5, 6),\n        ##intArrayOf(7, 8, 9)\n    ##)\n\n    ##for (row in matrix) {\n        ##for (element in row) {\n            ##print(\"$element\\t\")\n        ##}\n        ##println()\n    ##}\n##}',NULL,'=Объяснение кода:=\n\nМы объявляем двумерный массив matrix, который содержит три строки и три столбца.\n\nВо внешнем цикле for (row in matrix)переменная rowитерируется по строке массива matrix.\n\nВ вложенном цикле for (element in row)переменная elementитерируется по элементу каждой строки массива.\n\nКаждая итерация вложенного цикла выводит элемент elementс табуляцией после него.\n\nПосле завершения вложенного цикла, у нас есть оператор println(), который включает перевод строки для вывода каждой строки двумерного массива на новую строку.\n\nВывод: 1    2    3    \n4    5    6    \n7    8    9   =Заключение=\nВложенные циклы требуют большого количества инструментов для обхода двумерных структурных данных и выполнения',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(27,1,5,26,45,27,7,'rus','2023-11-01',NULL,'Прерывание циклов','Прерывание циклов позволяет прервать выполнение цикла досрочно при возникновении определенного условия. Это может быть полезно, когда вы хотите остановить выполнение цикла, когда достигнуто определенное состояние или выполнено определенное условие. В Kotlin для прерывания циклов можно использовать две основные конструкции: break и continue.\n\n=Прерывание с помощью break:=\nКлючевое слово break используется для немедленного выхода из цикла, даже если условие продолжения цикла остается истинным. Как только программа достигает оператора break, она выходит из цикла и продолжает выполнение кода за его пределами.\nПример использования break:\n','##fun ^^main^^() {\n    ##for (i in 1..10) {\n        ##if (i == 5) {\n            ##break %%// Прерываем цикл, если значение i равно 5%%\n        ##}\n        ##println(\"Текущее значение i: $i\")\n    ##}\n\n    ##println(\"Цикл завершен.\")\n##}',NULL,'В этом примере цикл for будет выполняться с i от 1 до 10. Когда i становится равным 5, цикл прерывается с помощью оператора break, и программа переходит к строке \"Цикл завершен.\".\n\n=Вывод программы:=','Текущее значение i: 1\nТекущее значение i: 2\nТекущее значение i: 3\nТекущее значение i: 4\nЦикл завершен.',NULL,'=Пропуск итерации с помощью continue:=\nКлючевое слово continue используется для пропуска текущей итерации цикла и перехода к следующей итерации. Когда программа достигает оператора continue, она сразу же переходит к следующей итерации, минуя оставшуюся часть текущей итерации.\n=Пример использования continue:=','##fun ^^main^^() {\n    ##for (i in 1..5) {\n        ##if (i == 3) {\n            ##continue %%// Пропускаем итерацию, если значение i равно 3%%\n        ##}\n        ##println(\"Текущее значение i: $i\")\n    ##}\n\n    ##println(\"Цикл завершен.\")\n##}',NULL,'В этом примере цикл for будет выполняться с i от 1 до 5. Когда i становится равным 3, программа пропускает итерацию с помощью оператора continue, и следующая итерация начинается с i равным 4.\n\n=Вывод программы:=','Текущее значение i: 1\nТекущее значение i: 2\nТекущее значение i: 4\nТекущее значение i: 5\nЦикл завершен.',NULL,'Обратите внимание, что continue пропускает только текущую итерацию, и остальные итерации выполняются как обычно.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(28,1,5,27,46,28,7,'rus','2023-11-01',NULL,'Цикл do-while','Do-while в Kotlin - это цикл, который выполняет определенный блок кода, пока заданное условие истинно. Однако, в отличие от цикла while, do-while гарантирует, что блок кода выполнится хотя бы один раз, даже если условие с самого начала ложно.','##fun ^^main^^() {\n    ##var **counter** = 1\n\n    ##// Цикл do-while будет выполняться, пока значение counter меньше или равно 5\n    ##do {\n        ##println(\"Значение счетчика: $counter\")\n        ##**counter**++ // Увеличиваем значение счетчика на 1 перед следующей итерацией\n    ##} while (**counter** <= 5)\n\n    ##println(\"Цикл завершен.\")\n##}',NULL,'В этом примере у нас также есть переменная counter, которая инициализируется значением 1. Однако в отличие от цикла while, здесь мы используем цикл do-while, и поэтому блок кода внутри цикла выполнится один раз, даже если значение counter равно 6.\n\nПри запуске программы вы получите следующий вывод:','Значение счетчика: 1\nЗначение счетчика: 2\nЗначение счетчика: 3\nЗначение счетчика: 4\nЗначение счетчика: 5\nЦикл завершен.',NULL,'Обратите внимание, что код внутри цикла выполнился один раз, даже если условие counter <= 5 стало ложным после первой итерации.\n\n=Когда лучше использовать do-while, а когда while=\n\nЦиклы do-while и while оба представляют собой инструменты для повторения кода в зависимости от определенных условий. Выбор между этими циклами зависит от конкретной задачи и требований к поведению программы.\n\nЦикл do-while лучше использовать, когда вы хотите, чтобы блок кода выполнился хотя бы один раз, даже если условие ложно с самого начала. То есть, если код внутри цикла должен быть выполнен перед проверкой условия. Например, когда вы запрашиваете ввод у пользователя и хотите убедиться, что пользователь введет хотя бы одно значение, можно использовать do-while.\n\n=Пример:=','##fun ^^main^^() {\n    ##var **input**: String?\n\n    ##%%// Цикл do-while, чтобы запросить ввод пользователя хотя бы один раз\n    ##do {\n        ##println(\"Введите свое имя: \")\n        ##**input** = readLine()\n    ##} while (**input**.isNullOrBlank())\n\n    ##println(\"Привет, $input!\")\n##}',NULL,'В этом примере у нас есть цикл do-while, который предназначен для запроса ввода имени пользователя. Приложение будет запрашивать ввод имени снова и снова до тех пор, пока пользователь не введет непустую строку (не нажмет только \"Enter\"). Заметьте, что цикл do-while гарантирует, что код внутри будет выполнен хотя бы один раз, независимо от того, выполнится ли условие input.isNullOrBlank() (пустая строка или нет).\nЦикл while, с другой стороны, лучше использовать, когда вы хотите, чтобы выполнение блока кода зависело только от условия. Если условие с самого начала не выполняется, то код внутри цикла не выполнится ни разу. Это удобно, когда у вас уже есть значение, которое удовлетворяет условию, и вы хотите повторять код до тех пор, пока условие не перестанет выполняться.\n=Пример:=','##fun ^^main^^() {\n    ##var **counter** = 1\n\n    ##%%// Цикл while, чтобы вывести значения счетчика от 1 до 5%%\n    ##while (**counter** <= 5) {\n        ##println(\"Значение счетчика: $counter\")\n        ##**counter**++\n    ##}\n##}',NULL,'do while прекрасно подходит, когда вы хотите, чтобы блок кода выполнился хотя бы один раз, даже если условие ложно с самого начала.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(29,1,5,28,47,29,7,'rus','2023-11-01',NULL,'Цикл for','=Введение=\n В программировании циклы являются мощным инструментом для многократного выполнения определенных действий или блоков кода. \nОни позволяют нам автоматизировать повторяющиеся задачи и обрабатывать большие объемы данных эффективно. \nЦиклы позволяют программам выполнять код многократно до тех пор, пока определенное условие не станет ложным.\nИ начиная изучать циклы, мы начнем с такого цикла, как for:\nЦикл for - это один из наиболее распространенных и полезных циклов в языке Kotlin. Он предназначен для повторения блока кода определенное количество раз или для обхода элементов в коллекциях и массивах. В этом уроке мы рассмотрим синтаксис цикла for и его применение для различных задач.\n\n\n\n=Синтаксис цикла for в Kotlin имеет следующую форму:=','##for (элемент in итерируемый_объект) {\n    ##%%// Блок кода, который будет повторяться%%\n##}',NULL,'Элемент: это переменная, которая будет принимать значения каждого элемента в итерируемом объекте на каждой итерации цикла.\nитерируемый_объект: это объект, который можно перебирать, такой как массив, коллекция или диапазон.\n=Использование для обхода элементов массива:=','##fun ^^main^^() {\n     		##val **numbers** = arrayOf(1, 2, 3, 4, 5)\n    ##%%// Обход элементов массива с помощью цикла for%%\n    ##for (number in **numbers**) {\n        ##println(number)\n    ##}\n##}',NULL,'=Вывод команды := 1\n2\n3\n4\n5   В этом примере у нас есть массив numbers(Пока мы не проходили массивы и, поэтому, для простоты, поясню это просто: переменная - которая хранит в себе несколько значений.И для того чтобы объявить массив мы используем arrayOf и помещаем туда значения), и мы используем цикл for для обхода всех его элементов. На каждой итерации значение элемента присваивается переменной number, и оно выводится на экран.\n=Без цикла for нам бы пришлось вывоодить весь массив вручную:=','##println(numbers[0])\n    ##println(numbers[1])\n    ##println(numbers[2])\n    ##println(numbers[3])\n    ##println(numbers[4])\'',NULL,'И представте, если бы в массиве было бы 1000 элементов \nОбратите внимание: Мы выводим numbers[0], это связанно с тем, что весь счет в массивах происходит с нуля\n=Использование для работы с диапазонами=','##fun ^^main^^() {\n    ##%%// Обход чисел от 1 до 5 с помощью цикла for%%\n    ##for (i in 1..5) {\n        ##println(i)\n    ##}\n##}',NULL,'=Вывод команды := 1\n2\n3\n4\n5   В этом примере мы используем оператор диапазона .. для создания диапазона чисел от 1 до 5, а затем используем цикл for для обхода всех чисел в этом диапазоне.\n\n=Использование для работы с коллекциями=','##fun ^^main^^() {\n    ##val **names** = arrayOf(\"Alice\", \"Bob\", \"Charlie\")\n\n    ##%%// Обход элементов списка с помощью цикла for%%\n    ##for (name in **names**) {\n        ##println(\"Hello, $name!\")\n    ##}\n##}',NULL,'=Вывод команды :=   Hello, Alice!\nHello, Bob!\nHello, Charlie!  В этом примере у нас есть список names, и мы используем цикл for для обхода всех его элементов (строк). На каждой итерации мы выводим приветствие для каждого имени.\n\n=Заключение:=\n\nЦикл for является мощным инструментом для обхода коллекций, массивов и диапазонов в Kotlin. Он позволяет выполнять повторяющиеся операции с элементами данных и упрощает код, делая его более компактным и читаемым. Освоение цикла for, дает эффективно работать с данными в своих программных проектах.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(30,1,5,29,48,30,7,'rus','2023-11-01',NULL,'Цикл while','=Введение=\n\nЦикл while- это один из фундаментальных циклов на языке программирования Kotlin. Он выполняет блок кода, пока указанное условие достоверности (правда). В этом уроке мы рассмотрим синтаксис цикла whileи его применение для различных задач.\n\n\n=Синтаксис цикла whileв Kotlin имеет следующую форму:=','##while (условие) {\n    ##%%// Блок кода, который будет выполняться, пока условие истинно%%\n##}',NULL,'Условие: это выражение, вычисляемое в логическом значении (истина или ложь). Пока условия достоверности (true), блок кода внутри while будет выполняться.\nПримеры использования цикла while:\n\n=Цикл while для счетчика=','##fun ^^main^^() {\n    ##var **count** = 1\n\n    ##%%// Цикл while с использованием счетчика%%\n    ##while (**count** <= 5) {\n        ##println(\"Счетчик: $count\")\n        ##**count**++\n    ##}\n##}',NULL,'=Объяснение:=\n\nМы объявляем переменную count и устанавливаем начальное значение равное 1.\nДалее мы циклируем whileдля проверки условий count <= 5.\nПока условие count <= 5достоверно (правда), блок кода внутри цикла будет выполняться.\nВнутри цикла мы выводим значение счетчика на экран и увеличиваем его на 1 с помощью операции count++.\nЦикл увеличен до тех пор, пока значение счетчика countменьше или равно 5.\nРезультат выполнения:','Счетчик: 1\nСчетчик: 2\nСчетчик: 3\nСчетчик: 4\nСчетчик: 5',NULL,'=Заключение:=\n\nЦикл while предоставляет возможность повторять выполнение блока кода на основе условий. Он позволяет создавать устойчивые циклы или выполнять блок кода до тех пор, пока сохраняется достоверность. По мере изучения программирования, цикл whileстановится полезным для работы с полезными и пользовательскими вкладами.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(31,1,5,30,49,31,7,'rus','2023-11-01',NULL,'Цикл for-each','Цикл for-eachя вляется из обычного обхода элементов или массива на языке программирования Kotlin.\n В этом уроке вы узнаете, как использовать цикл for-each, чтобы перебирать элементы коллекции и массива.\n\n=Что такое цикл for-each?=\nЦикл for-each(или цикл for inв некоторых других случаях) обеспечивает удобный и лаконичный способ обхода элементов коллекции или массива без явного использования индексов. \nЭтот цикл автоматически проходит по элементу в коллекции или массиве, что получает чтение и понимание кода.\n\n=Синтаксис циклаfor-each=\nВот общий синтаксис цикла for-eachв Kotlin:','##for (element in collection) {\n    ##%%// Код, выполняемый для каждого элемента в коллекции%%\n##}',NULL,'element- это переменная, в которую попадает элемент коллекции или массива для каждой итерации цикла.\ncollection- это коллекция или массив, по которой происходит итерация.\nПримеры использования циклаfor-each\n=Пример 1: Итерация по списку чисел=','##fun ^^main^^() {\n    ##val **numbers** = listOf(1, 2, 3, 4, 5)\n\n    ##%%// Итерация по списку и вывод каждого элемента%%\n    ##for (number in numbers) {\n        ##println(number)\n    ##}\n##}',NULL,'=Вывод:=','1\n2\n3\n4\n5',NULL,'=Пример 2: Итерация по массиву строк=','##fun ^^main^^() {\n    ##val **colors** = arrayOf(\"Red\", \"Green\", \"Blue\", \"Yellow\")\n\n    ##%%// Итерация по массиву и вывод каждой строки%%\n    ##for (color in **colors**) {\n        ##println(color)\n    ##}\n##}',NULL,'=Вывод:=','##Red\n##Green\n##Blue\n##Yellow',NULL,'=Пример 3: Итерация по строке (символам)=','##fun ^^main^^() {\n    ##val **text** = \"Hello, Kotlin!\"\n\n    ##%%// Итерация по строке и вывод каждого символа%%\n    ##for (char in **text**) {\n        ##println(char)\n    ##}\n##}',NULL,'=Вывод:=','##H\n##e\n##l\n##l\n##o\n##,\n \n##K\n##o\n##t\n##l\n##i\n##n\n##!',NULL,'=Заключение=\nЦикл for-each— это простой и удобный способ обхода элементов или массива на языке программирования Kotlin.\n Он позволяет установить действие для каждого элемента коллекции без выявления наличия индексов.',NULL,NULL,NULL,NULL,NULL,NULL,NULL),(32,1,5,31,50,32,7,'rus','2023-11-01',NULL,'Понимание ключевого слова override','Ключевое слово override в языке программирования Kotlin используется для переопределения методов и свойств из родительских классов или интерфейсов. \nПри переопределении вы можете предоставить новую реализацию для метода или свойства, уже определенного в родительском классе или интерфейсе.\n Это одна из ключевых возможностей ООП, которая позволяет создавать более гибкие и расширяемые программы.\n\n=Переопределение методов:=\nДля того чтобы переопределить метод из родительского класса, следует выполнить следующие шаги:\n\n=1.1. Создайте базовый класс с методом, который вы хотите переопределить:=\n','##open class Animal {\n   ##open fun ^^makeSound^^() {\n        ##println(\"Animal makes a sound\")\n    ##}\n##}',NULL,'=1.2. Создайте класс-наследник (подкласс), который будет переопределять метод:=','##class Dog : Animal() {\n    ##override fun ^^makeSound^^() {\n        ##println(\"Dog barks\")\n    ##}\n##}',NULL,'=1.3. В основной программе, создайте объект класса-наследника и вызовите переопределенный метод:\n=','##fun ^^main^^() {\n    ##val **dog** = Dog()\n    ##**dog**.^^makeSound^^() %%// Выведет: \"Dog barks\"%%\n##}',NULL,'Переопределение свойств:\nКроме методов, вы также можете переопределить свойства (поля) из родительских классов. Для этого также используется ключевое слово override.\n\n=2.1. Создайте базовый класс с свойством:=\n','##open class Person {\n    ##open val **name**: String = \"John Doe\"\n##}',NULL,'=2.2. Создайте класс-наследник, переопределяющий свойство:=','##class Student : Person() {\n    ##override val **name**: String = \"Alice\"\n##}',NULL,'2.3. =В основной программе, создайте объект класса-наследника и обратитесь к переопределенному свойству:=','h;##fun ^^main^^() {\n    ##val **student** = Student()\n    ##println(**student**.name) %%// Выведет: \"Alice\"%%\n##}',NULL,'=Правила для использования override:=\nМетод или свойство, которое вы хотите переопределить, должно быть открытым (open) в базовом классе или интерфейсе, чтобы его можно было переопределить в подклассе.\nКласс-наследник (подкласс) должен использовать ключевое слово override, чтобы указать, что он переопределяет метод или свойство.\n=Предотвращение переопределения:=\nЕсли вы хотите запретить дальнейшее переопределение метода или свойства в классах-наследниках, вы можете использовать ключевое слово final перед объявлением метода или свойства в родительском классе.\nТеперь вы знаете основы переопределения в Kotlin с помощью ключевого слова override. Это поможет вам создавать более гибкие и масштабируемые классы в вашем коде. Удачи!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(33,1,6,32,51,33,8,'rus','2023-11-01',NULL,'=Введение в коллекции=','=Что такое коллекции:= \nКоллекции - это контейнеры, которые позволяют хранить и управлять группами элементов одного или разных типов данных. \n В Kotlin, стандартная библиотека предоставляет различные типы коллекций, которые обеспечивают удобные методы для работы с данными. \n \n=Виды коллекций в Kotlin:= \nKotlin предоставляет несколько типов коллекций: \n \nList (список): упорядоченный набор элементов, может содержать повторяющиеся значения. \nSet (множество): упорядоченный набор уникальных элементов без повторений. \nMap (отображение): пары ключ-значение, где каждый ключ уникален. \nMutable (изменяемые) и Immutable (неизменяемые) коллекции: Mutable коллекции позволяют изменять и добавлять элементы, в то время как Immutable коллекции предоставляют только операции для чтения данных. \n=Объявление коллекций:= \nДля объявления коллекций, используйте функции-конструкторы соответствующих типов:','##val list: List<Int> = listOf(1, 2, 3, 4, 5) \n##val set: Set<String> = setOf(\"apple\", \"banana\", \"orange\") \n##val map: Map<String, Int> = mapOf(\"one\" to 1, \"two\" to 2, \"three\" to 3)',NULL,'=Доступ к элементам коллекций:= \nДля доступа к элементам коллекций, используйте методы get() или оператор индексации []:','##val fruits = listOf(\"apple\", \"banana\", \"orange\") \n##val firstFruit = fruits.get(0) %%// Получение первого элемента (значение будет \"apple\")%% \n##val secondFruit = fruits[1] %%// Получение второго элемента (значение будет \"banana\")%%',NULL,'=Изменение коллекций:= \nMutable коллекции позволяют изменять и добавлять элементы:','##val mutableList = mutableListOf(1, 2, 3) \n##**mutableList**.add(4) %%// Добавление элемента (теперь список содержит [1, 2, 3, 4])%% \n \n##val mutableSet = mutableSetOf(\"apple\", \"banana\", \"orange\") \n##**mutableSet**.remove(\"banana\") %%// Удаление элемента (теперь множество содержит [\"apple\", \"orange\"])%% \n \n##val mutableMap = mutableMapOf(\"one\" to 1, \"two\" to 2) \n##mutableMap[\"three\"] = 3 %%// Добавление пары ключ-значение (теперь отображение содержит [\"one\" to 1, \"two\" to 2, \"three\" to 3])%%',NULL,'=Итерация по коллекциям:= \nДля итерации (перебора) элементов коллекций, используйте цикл for или функцию высшего порядка forEach: \n','##val numbers = listOf(1, 2, 3, 4, 5) \n##for (number in numbers) { \n    ##println(number) %%// Вывод каждого элемента на экран%% \n##} \n \n##fruits.forEach { fruit -> \n    ##println(fruit) %%// Вывод каждого элемента на экран с использованием forEach%% \n##}',NULL,'=Фильтрация коллекций:= \nДля фильтрации элементов в коллекциях, используйте метод filter:','##val numbers = listOf(1, 2, 3, 4, 5) \n##val evenNumbers = numbers.filter { it % 2 == 0 } // Получение только четных чисел (значение будет [2, 4])',NULL,'=Заключение:= \nВ этом уроке вы узнали, что такое коллекции и как работать с ними в Kotlin.  \nВы научились объявлять коллекции различных типов, получать доступ к элементам, изменять коллекции, выполнять итерацию и фильтрацию. \n Коллекции представляют мощный инструмент для организации и обработки данных, и они являются неотъемлемой частью разработки приложений на Kotlin.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(34,1,6,33,52,34,8,'rus','2023-11-01',NULL,'=Что такое массивы:=','Массивы - это упорядоченные наборы элементов одного типа данных. Они позволяют хранить несколько значений одного типа в одной переменной и обращаться к каждому элементу по его индексу.\n=Объявление массива:=В Kotlin, массивы могут быть объявлены с помощью функции arrayOf(), которая позволяет создать массив с изначально заданными элементами. Например:\n','##val numbers = arrayOf(1, 2, 3, 4, 5)',NULL,'=Доступ к элементам массива:Элементы массива нумеруются с нуля. Для доступа к элементу по его индексу, используйте квадратные скобки с индексом внутри. Например:','##val firstElement = numbers[0] %%// Получение первого элемента (значение будет равно 1)%%',NULL,'=Изменение элементов массива:=\nВы можете изменить элементы массива, просто присвоив новое значение по его индексу. Например:','##**numbers**[2] = 10 %%// Замена третьего элемента на значение 10%%',NULL,'=Длина массива:=Чтобы узнать длину массива (количество элементов в нем), используйте свойство size. Например:','##val length = numbers.size %%// Получение длины массива (значение будет равно 5)%%',NULL,'=Итерация по массиву:=\nИтерация (перебор) по массиву позволяет выполнить определенные действия с каждым элементом. Вы можете использовать цикл for для этой цели. Например:','##for (number in **numbers**) {    ##println(number) %%// Вывод каждого элемента массива на экран%%\n##}',NULL,'=Использование индекса при итерации:=Иногда вам может понадобиться знать текущий индекс элемента во время итерации. Вы можете использовать метод indices для получения диапазона индексов массива.\n Например:','##for (index in numbers.indices) {    ##println(\"Элемент с индексом $index: ${numbers[index]}\")\n##}',NULL,'=Использование функции высшего порядка для обработки массива:=В Kotlin, функции высшего порядка, такие как forEach, map, filter, позволяют выполнять операции над массивом без явного использования циклов. Например:','##**numbers**.forEach { number ->\n    ##println(number) %%// Вывод каждого элемента массива на экран с использованием forEach%%##}',NULL,'=Заключение:=\nВ этом уроке вы узнали, что такое массивы и как их использовать в Kotlin. Вы можете создавать, изменять и обращаться к элементам массива с помощью индексов. Также, вы научились выполнять итерацию по массиву с помощью циклов и функций высшего порядка. \nМассивы являются важным инструментом для хранения и обработки данных в программировании, и это только начало вашего путешествия в изучении этой темы.',NULL,NULL,NULL,NULL,NULL,NULL,NULL),(35,1,6,34,53,35,8,'rus','2023-11-01',NULL,'=Введение в View Binding=','=Часть 1 Введение=В этом уроке мы рассмотрим, что такое View Binding, как его использовать для удобного доступа к элементам пользовательского интерфейса и как это помогает избежать ошибок, связанных с использованием findViewById.\n=Часть 2 Что такое View Binding=\nView Binding - это механизм, предоставляемый Android для связывания компонентов пользовательского интерфейса (View) с кодом. Он автоматически создает ссылки на все элементы интерфейса, что позволяет обращаться к ним без явного использования findViewById.\n=Часть 3 Подключение View Binding=\nВключите View Binding в своем проекте, добавив следующую строку в файле build.gradle (app)\nФОТО GRADLE После того как вы включили View Binding не забудьте синхронизировать \nAndroid Studio автоматически создаст классы связывания для ваших макетов.=Часть 4 Использование View Binding=\nПредположим, у вас есть макет с именем activity_main.xml. Android Studio автоматически создаст для него класс ActivityMainBinding.\nПример использования View Binding','##class MainActivity  AppCompatActivity() {\n    ##private var binding: ActivityMainBinding? = null\n    ##override fun ^^onCreate^^(savedInstanceState Bundle) {        ##super.^^onCreate^^(savedInstanceState)\n        ##**binding** = ActivityMainBinding.inflate(layoutInflater)        ##val view = binding?.root\n        ##setContentView(**view**)\n        ##**binding**?.textView.text = Hello, View Binding!    ##}\n##override fun ^^onDestroy^^() {\n        ##super.^^onDestroy^^()        ##**binding** = null\n    ##}##}',NULL,'Вы можете заметить, что мы в onDestroy делаем binding = null, это нужно для избежания утечек памяти, связанных с View Binding, при уничтожении активности. Это освобождает ресурсы, связанные с элементами пользовательского интерфейса, чтобы избежать удержания ссылок и утечек памяти.\n =Использование View Binding с apply:=\napply - это функция расширения, которая позволяет вам применить несколько операций к объекту внутри блока, используя ссылку на этот объект (в данном случае, binding).','##import android.os.Bundle##import androidx.appcompat.app.AppCompatActivity\n##import com.example.yourapp.databinding.ActivityExampleBinding\n##class MainActivity  : AppCompatActivity() { ##private var binding: ActivityMainBinding? = null\n    ##override fun ^^onCreate^^(savedInstanceState: Bundle?) {\n        ##super.^^onCreate^^(savedInstanceState)        ##val binding = ActivityMainBinding.inflate(layoutInflater)\n        ##setContentView(**binding**?.root)\n        ##**binding**?.apply {            ##textViewTitle.text = \"Welcome to View Binding\"\n            ##buttonSubmit.setOnClickListener {                ##// Действие при нажатии на кнопку\n            ##}        ##}\n    ##}##}',NULL,'В этом примере, apply позволяет нам настроить элементы пользовательского интерфейса textViewTitle и buttonSubmit без необходимости повторно указывать binding. для каждой операции.\n=Использование View Binding с with:=\nwith - это функция, которая позволяет вам вызвать методы объекта без необходимости указания имени объекта для каждого вызова.','##private fun ^^yourFun^^() = with(binding!!) {\n         ##textViewTitle.text = \"Welcome to View Binding\"                ##buttonSubmit.setOnClickListener {\n                    ##// Действие при нажатии на кнопку                ##}\n    ##}',NULL,'=Часть 5 Преимущества View Binding=\nУлучшает производительность, так как нет необходимости искать элементы по ID.Безопасен компилятор проверяет существование элементов во время компиляции.\nУменьшает вероятность ошибок, связанных с неправильными ID элементов.=Часть 6 Заключение=\nView Binding - это мощный инструмент, который упрощает работу с пользовательским интерфейсом в Android. Он обеспечивает безопасность, производительность и удобство при доступе к элементам интерфейса.\n Используйте View Binding, чтобы сделать ваш код более чистым и избежать распространенных ошибок.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(36,1,6,35,54,36,8,'rus','2023-11-01',NULL,'Использование множеств (Set)','Введение в множества (Set)=\nМножество (Set) - это коллекция в языке программирования Kotlin, которая содержит уникальные элементы без повторений и не имеет определенного порядка элементов. Множество - отличный выбор, когда вам необходимо хранить уникальные значения и быстро проверять наличие элемента.\n=1. Объявление множества=\nДля объявления множества в Kotlin используется ключевое слово setOf или mutableSetOf:','//Неизменяемое (immutable) множество##val immutableSet = setOf(1, 2, 3, 4, 5)\n //Изменяемое (mutable) множество\n##val mutableSet = mutableSetOf(\"apple\", \"banana\", \"orange\")',NULL,'=2. Операции с множествами=','//Добавление элемента в изменяемое множество\nmutableSet.add(\"grape\")//Удаление элемента из изменяемого множества\nmutableSet.remove(\"banana\")\n//Проверка наличия элемента в множестве\n##if (**immutableSet**.contains(3)) {\n    ##println(\"Множество содержит элемент 3.\")##} else {\n    ##println(\"Множество не содержит элемент 3.\")##}',NULL,'=3. Обход элементов множества=\nДля обхода элементов множества можно использовать цикл for-each:','##val set = setOf(\"apple\", \"banana\", \"orange\")\n##for (element in **set**) {    ##println(element)\n##}',NULL,'=4. Операции над множествами=В Kotlin для работы с множествами предоставляются различные операции, такие как объединение, пересечение, разность и др.\n','//Объединение двух множеств\n##val set1 = setOf(1, 2, 3)##val set2 = setOf(3, 4, 5)\n##val unionSet = set1.union(**set2**)\n##println(**unionSet**)  //Вывод [1, 2, 3, 4, 5]//Пересечение двух множеств\n##val intersectionSet = set1.intersect(set2)\n##println(intersectionSet)  //Вывод [3]//Разность двух множеств\n##val differenceSet = set1.subtract(set2)\n##println(**differenceSet**)  //Вывод [1, 2]',NULL,'=5. Размер и очистка множества=','//Для получения размера множества используйте свойство size.\n##val size = setOf(1, 2, 3).size\n##println(\"Размер множества $size\")  //Вывод Размер множества 3//Чтобы очистить все элементы из изменяемого множества, используйте метод clear().\n\n##**mutableSet**.clear()',NULL,'=6. Пример использования=','##fun ^^main^^() {\n    ##val fruits = mutableSetOf(apple, banana, orange)\n    // Добавление элемента в множество    ##**fruits**.add(\"grape\")\n    // Проверка наличия элемента в множестве\n    ##if (**fruits**.contains(\"apple\")) {\n        ##println(\"Множество содержит яблоко.\")    ##}\n     //Удаление элемента из множества\n    ##**fruits**.remove(\"banana\")\n     //Вывод всех элементов множества    ##for (fruit in **fruits**) {\n        ##println(fruit)\n    ##}\n     //Размер множества    ##println(\"Размер множества ${fruits.size}\")\n     //Очистка множества\n    ##**fruits**.clear()##}',NULL,'Вот и всё! Теперь вы знакомы с основами работы с множествами в Kotlin. \nМножества предоставляют эффективный способ хранения уникальных данных и решения различных задач, связанных с проверкой наличия элементов, объединением или пересечением множеств. Успешного программирования!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(37,1,6,36,55,37,8,'rus','2023-11-01',NULL,'=Использование отображений (Map)=','=Введение в отображения (Map):=\nОтображение (Map) - это коллекция в языке программирования Kotlin, которая представляет собой ассоциативный массив, состоящий из пар \"ключ-значение\". \nКаждому уникальному ключу соответствует определенное значение. \nОтображения позволяют эффективно хранить и получать значения, обеспечивая доступ по ключу за константное время.\n\n=1. Объявление и инициализация отображений:=\nДля объявления отображения в Kotlin используется ключевое слово \"mapOf\" для неизменяемого (immutable) отображения и \"mutableMapOf\" для изменяемого (mutable) отображения.','%%// Неизменяемое отображение (ключи и значения не могут быть изменены)%%\nval immutableMap = mapOf(1 to \"один\", 2 to \"два\", 3 to \"три\")\n\n%%// Изменяемое отображение (ключи и значения могут быть изменены)%%\nval mutableMap = mutableMapOf(\"apple\" to 1, \"banana\" to 2, \"orange\" to 3)',NULL,'=2. Добавление и удаление элементов в изменяемом отображении:=','%%// Добавление новой пары \"ключ-значение\"%%\nmutableMap[\"grape\"] = 4\n\n%%// Удаление пары по ключу%%\nmutableMap.remove(\"banana\")',NULL,'=3. Доступ к значениям по ключу:=','%%// Получение значения по ключу%%\nval value = mutableMap[\"apple\"]\n\n%%// Проверка наличия ключа в отображении%%\nif (\"orange\" in mutableMap) {\n    println(\"Отображение содержит ключ \"orange\".\")\n}',NULL,'=4. Итерация по отображению:=','val map = mapOf(\"apple\" to 1, \"banana\" to 2, \"orange\" to 3)\n\n%%// Итерация по парам \"ключ-значение\"%%\nfor ((key, value) in map) {\n    println(\"Ключ: $key, Значение: $value\")\n}\n\n%%// Итерация только по ключам%%\nfor (key in map.keys) {\n    println(\"Ключ: $key\")\n}\n\n%%// Итерация только по значениям%%\nfor (value in map.values) {\n    println(\"Значение: $value\")\n}',NULL,'=5. Размер и очистка отображения:=','val size = map.size\nprintln(\"Размер отображения: $size\")\n\nmutableMap.clear()',NULL,'=6. Пример использования:=','fun ^^main^^() {\n    val fruitsMap = mutableMapOf(\"apple\" to 1, \"banana\" to 2, \"orange\" to 3)\n\n    %%// Добавление новой пары \"ключ-значение\"%%\n    fruitsMap[\"grape\"] = 4\n\n    %%// Получение значения по ключу%%\n    val appleValue = fruitsMap[\"apple\"]\n    println(\"Значение для ключа \"apple\": $appleValue\")\n\n    %%// Проверка наличия ключа в отображении%%\n    if (\"orange\" in fruitsMap) {\n        println(\"Отображение содержит ключ \"orange\".\")\n    }\n\n    %%// Удаление пары по ключу%%\n    fruitsMap.remove(\"banana\")\n\n    %%// Итерация по отображению%%\n    for ((key, value) in fruitsMap) {\n        println(\"Ключ: $key, Значение: $value\")\n    }\n\n    %%// Размер отображения%%\n    println(\"Размер отображения: ${fruitsMap.size}\")\n\n    %%// Очистка отображения%%\n    fruitsMap.clear()\n}',NULL,'Отображения (Map) - это удобный и мощный инструмент в Kotlin для работы с ассоциативными данными.\n Они позволяют эффективно хранить и получать значения по ключу. \nНадеюсь, этот урок поможет вам лучше понять, как использовать отображения в Kotlin. Успешного программирования!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(38,1,6,37,56,38,8,'rus','2023-11-01',NULL,'=Использование списков (List) в Kotlin=','=Что такое список (List) в Kotlin:=\nСписок (List) в Kotlin - это упорядоченная коллекция элементов, которая может содержать дубликаты.\n Списки предоставляют удобные методы для работы с данными, такие как добавление, удаление, доступ к элементам по индексу, итерация и многое другое.\n\n=Объявление и создание списка:=\nДля создания списка в Kotlin, используйте функцию-конструктор listOf() или mutableListOf() для неизменяемых и изменяемых списков соответственно.\n','##%%// Неизменяемый список (List)%%\n##val fruits = listOf(\"apple\", \"banana\", \"orange\")\n\n##%%// Изменяемый список (MutableList)%%\n##val mutableFruits = mutableListOf(\"apple\", \"banana\", \"orange\")',NULL,'=Доступ к элементам списка:=\nДля доступа к элементам списка используйте квадратные скобки с индексом или функцию get().','##val firstFruit = fruits[0] %%// Значение будет \"apple\"%%\n##val secondFruit = fruits.get(1) %%// Значение будет \"banana\"%%',NULL,'=Добавление и удаление элементов:=\nДля изменяемых списков можно добавлять и удалять элементы.','##mutableFruits.add(\"grape\") %%// Добавление элемента \"grape\" в список%%\n##mutableFruits.remove(\"banana\") %%// Удаление элемента \"banana\" из списка%%',NULL,'=Итерация по списку:=\nДля перебора элементов списка можно использовать цикл for или функцию высшего порядка forEach.','##for (fruit in fruits) {\n    ##println(fruit) %%// Вывод каждого элемента на экран%%\n##}\n\n##fruits.forEach { fruit ->\n   ##println(fruit) %%// Вывод каждого элемента на экран с помощью forEach%%\n##}',NULL,'=Фильтрация списка:=\nДля фильтрации элементов списка можно использовать функцию filter.','##val longFruits = mutableFruits.filter { it.length > 5 } %%// Получение фруктов с именем длиннее 5 символов%%',NULL,'=Сортировка списка:=\nДля сортировки элементов списка можно использовать функцию sorted().','##val sortedFruits = mutableFruits.sorted() %%// Сортировка фруктов по алфавиту%%',NULL,'=Заключение:=\nТеперь мы знаем, что такое список (List) и как использовать его для хранения и управления упорядоченными коллекциями элементов.\n Списки предоставляют удобные методы для добавления, удаления, доступа, итерации, фильтрации и сортировки данных.\n Вы также узнали о неизменяемых и изменяемых списках, которые обеспечивают гибкость в работе с данными в зависимости от ваших требований.\nСписки являются важным инструментом в разработке приложений на Kotlin и используются повсеместно для работы с данными в упорядоченном формате.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(39,1,6,38,57,39,8,'rus','2023-11-01',NULL,'=Многомерные массивы=','=Что такое многомерные массивы:=Многомерные массивы - это массивы, в которых каждый элемент сам является массивом. \nОни позволяют организовать данные в виде таблицы или матрицы с несколькими измерениями.\n=Объявление многомерных массивов:=В Kotlin, многомерные массивы могут быть объявлены с помощью функции arrayOf(), в которой указываются вложенные массивы. Например, чтобы создать двумерный массив:','##val matrix = arrayOf(\n    ##arrayOf(1, 2, 3),    ##arrayOf(4, 5, 6),\n    ##arrayOf(7, 8, 9)##)',NULL,'=Доступ к элементам многомерных массивов:=\nДля доступа к элементам многомерных массивов используйте квадратные скобки с индексами для каждого измерения. Например:','##val value = **matrix**[1][2] %%// Получение значения элемента во втором ряду и третьем столбце (значение будет равно 6)%%',NULL,'=Изменение элементов многомерных массивов:=Изменение элементов многомерных массивов осуществляется аналогично одномерным массивам. Просто присвойте новое значение элементу по его индексу. Например:','##**matrix**[0][1] = 10 %%// Замена значения элемента в первом ряду и втором столбце на 10%%',NULL,'=Длина многомерных массивов:=\nМногомерные массивы имеют длины в каждом измерении. Чтобы узнать длину многомерного массива в определенном измерении, используйте свойство size для каждого уровня вложенности. Например:','##val rows = matrix.size %%// Получение количества строк в многомерном массиве (значение будет равно 3)%%\n##val columns = **matrix**[0].size %%// Получение количества столбцов в первом ряду (значение будет равно 3)%%',NULL,'=Итерация по многомерным массивам:=Для итерации по многомерным массивам, используйте вложенные циклы. Например, для двумерного массива:','##for (row in **matrix**) {\n    ##for (element in row) {        ##println(element) %%// Вывод каждого элемента многомерного массива на экран%%\n    ##}##}',NULL,'=Заключение:=\nВ этом уроке вы узнали, что такое многомерные массивы и как с ними работать в Kotlin. Многомерные массивы позволяют хранить данные в виде таблицы или матрицы с несколькими измерениями. Вы научились создавать, изменять, получать доступ к элементам и выполнять итерацию по многомерным массивам.\n Многомерные массивы - это полезный инструмент для работы с данными в различных задачах, таких как математические вычисления, обработка изображений, игровое программирование и многое другое.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(40,1,6,39,58,40,8,'rus','2023-11-01',NULL,'=Операции над массивами=','В Kotlin, массивы предоставляют различные методы и операции, которые позволяют упростить обработку данных в массивах. В этом уроке мы рассмотрим основные операции над массивами, такие как сортировка, фильтрация, поиск элементов и другие.\n\n=1. Сортировка массивов:=\nДля сортировки элементов в массиве можно использовать метод sort(), который сортирует массив в возрастающем порядке:','##val numbers = arrayOf(5, 2, 8, 1, 4)\n##numbers.sort()\n##println(numbers.contentToString()) %%// Вывод: [1, 2, 4, 5, 8]%%',NULL,'Вы также можете использовать метод sortDescending() для сортировки в убывающем порядке.\n\n=2. Фильтрация массивов:=\nДля фильтрации элементов в массиве можно использовать метод filter(), который возвращает новый массив с элементами, соответствующими заданному условию:','##val numbers = arrayOf(5, 2, 8, 1, 4)\n##val filteredNumbers = numbers.filter { it > 3 }\n##println(filteredNumbers.contentToString()) %%// Вывод: [5, 8, 4]%%',NULL,'=3. Поиск элементов в массивах:=\nДля поиска элемента в массиве можно использовать методы find() и indexOf():','##val numbers = arrayOf(5, 2, 8, 1, 4)\n##val element = numbers.find { it == 8 } %%// Поиск элемента со значением 8%%\n##println(\"Искомый элемент: $element\") %%// Вывод: Искомый элемент: 8%%\n\n##val index = numbers.indexOf(1) %%// Поиск индекса элемента со значением 1%%\n##println(\"Индекс элемента: $index\") %%// Вывод: Индекс элемента: 3%%',NULL,'=4. Преобразование массивов:=\nДля преобразования элементов в массиве можно использовать метод map(), который возвращает новый массив с результатами применения заданной операции к каждому элементу:','##val numbers = arrayOf(5, 2, 8, 1, 4)\n##val squaredNumbers = numbers.map { it * it }\n##println(squaredNumbers.contentToString()) %%// Вывод: [25, 4, 64, 1, 16]%%',NULL,'=5. Редукция массивов:=\nДля свертки элементов в массиве можно использовать метод reduce(), который применяет операцию к элементам массива и возвращает единственное значение:','##val numbers = arrayOf(5, 2, 8, 1, 4)\n##val sum = numbers.reduce { acc, value -> acc + value }\n##println(\"Сумма элементов: $sum\") %%// Вывод: Сумма элементов: 20%%',NULL,'=6. Проверка условий:=\nМассивы предоставляют также методы для проверки условий, например, методы all(), any() и none():','##val numbers = arrayOf(5, 2, 8, 1, 4)\n##val allGreaterThanZero = numbers.all { it > 0 } %%// Проверка, что все элементы больше нуля%%\n##val anyEqualToZero = numbers.any { it == 0 } %%// Проверка, что есть хотя бы один элемент равный нулю\n##val noneNegative = numbers.none { it < 0 } %%// Проверка, что нет отрицательных элементов%%\n##println(\"Все элементы больше нуля: $allGreaterThanZero\") %%// Вывод: Все элементы больше нуля: true%%\n##println(\"Есть элемент, равный нулю: $anyEqualToZero\") %%// Вывод: Есть элемент, равный нулю: false%%\n##println(\"Нет отрицательных элементов: $noneNegative\") %%// Вывод: Нет отрицательных элементов: true%%',NULL,'=Заключение:=\nВ этом уроке мы рассмотрели основные операции над массивами в Kotlin. Вы научились сортировать массивы, фильтровать элементы, искать элементы, преобразовывать массивы и выполнять редукцию. Эти операции помогут вам эффективно обрабатывать данные в массивах и решать различные задачи программирования.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(41,1,6,40,59,41,8,'rus','2023-11-01',NULL,'=Отличия между массивами и коллекциями и их применение=','В Kotlin массивы и коллекции варьируются в двух вариантах хранения и управления наборами элементов.\n В этом уроке мы рассмотрели основные различия между ними и рекомендации по выбору наилучшего выбора для особых ситуаций.\n\n=Где лучше использовать массивы и коллекции:=\n\nМассивы хорошо подходят, когда нам необходимо получить фиксированный набор элементов и быстро получить доступ к элементу по индексу.\nКоллекции лучше, когда требуется гибкая структура данных, которая может изменяться в процессе выполнения программы или когда у нас есть элементы разных типов, которые необходимо хранить вместе.\nЕсли вы знаете точное количество элементов и не предполагаете его изменения, массивы могут быть более эффективными с точки зрения сбора данных и производительности.\n\n\n\nРазберем несколько практических примеров, чтобы лучше понять, где лучше использовать массивы и коллекции.\n\nПример с массивами: Представим, что у нас есть задача создать простую функцию, которая включает в себя широкий массив массивов чисел.\nВ таком случае, массивы потребовали и быстрого доступа к элементу по индексу, что делает их подходящим выбором для такой задачи:\nкотлин','##fun ^^findMaxValue^^(numbers: IntArray): Int {\n    ##var max = numbers[0]\n    ##for (num in numbers) {\n        ##if (num > max) {\n            ##max = num\n        ##}\n    ##}\n    ##return max\n##}\n\n##fun ^^main^^() {\n    ##val numbers = intArrayOf(5, 10, 2, 8, 3)\n    ##val maxValue = ^^findMaxValue^^(numbers)\n    ##println(\"Максимальное значение: $maxValue\") %%// Выводит \"Максимальное значение: 10\"%%\n##}',NULL,'Пример с коллекцией: у нас есть приложение для сбора задач, и нам нужно сохранить список задач пользователя.\n В этом случае, сбор коллекции лучше, так как пользователь может включить или исключить задачу, что включает в себя сбор размера коллекции:\nкотлин','##data class Task(val id: Int, val title: String, val description: String)\n\n##fun ^^main^^() {\n    ##val tasks = mutableListOf(\n        ##Task(1, \"Помыть посуду\", \"Вымыть все тарелки и стаканы\"),\n        ##Task(2, \"Сделать покупки\", \"Купить продукты на ужин\")\n    ##)\n\n    ##// Добавление новой задачи\n    ##val newTask = Task(3, \"Постирать белье\", \"Постирать и повесить белье\")\n    ##tasks.add(newTask)\n\n    ##// Удаление задачи\n    ##tasks.removeAt(1)\n\n    ##// Вывод всех оставшихся задач\n    ##for (task in tasks) {\n        ##println(\"${task.id}: ${task.title}\")\n    ##}\n##}',NULL,'В прошлом мы использовали mutableListOf, чтобы создать изменяемый список задач.\n Мы добавили новые наборы и удалили одну из них, что показывает, насколько высока гибкость управления данными.\n\nОсобые ситуации Set. MapНапример, для подсчета частоты встречаемости элементов можно Map:\nкотлин','##fun ^^main^^() {\n    ##val names = listOf(\"Alice\", \"Bob\", \"Alice\", \"Charlie\", \"Bob\", \"Alice\")\n    ##val nameFrequencyMap = mutableMapOf<String, Int>()\n\n    ##for (name in names) {\n        ##nameFrequencyMap[name] = nameFrequencyMap.getOrDefault(name, 0) + 1\n    ##}\n\n    ##for ((name, frequency) in nameFrequencyMap) {\n        ##println(\"$name: $frequency\")\n    ##}\n##}',NULL,'Для подсчета частоты встречаемости каждого имени в списке Map.\n\nИтак, в выборе типов массивов и коллекций необходимо учитывать задачи и необходимость изменения размера данных в процессе выполнения программ. \nМассивы требуют быстрой доступности по индексу и расчету для фиксированных наборов данных, тогда как взыскание скорости гибкости и использования в управлении данными, что определяет их вероятность выбора в большинстве случаев.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(42,1,6,41,60,42,8,'rus','2023-11-01',NULL,'=Функции высшего порядка=','=Что такое функции высшего порядка?=\n\nФункции высшего порядка (Higher-Order Functions, HOF) - это функции, которые принимают другие функции в качестве аргумента или возвращают их как результат.\n В Kotlin функции считают \"гражданами первого класса\", что означает, что они могут быть переданы как данные, присвоены переменным и возвращены из других функций.\n\nПримеры функций высшего порядка:\n\nmap() : Применяет функцию и список, применяет эту функцию к каждому элементу списка и возвращает новый список с результатами.\n\nfilter() : Применяет функцию и список, возвращает новый список, возвращает только те элементы, для которых требуется функция возвращает true.\n\nreduce() : Применяет функцию, список и начальное значение (аккумулятор).\n Последовательно применяет функцию списка элементов, используя аккумулятор, и возвращает итоговое значение аккумулятора.\n\n=Преимущества использования функций высшего порядка:=\n\nУменьшение дублирования кода и улучшение его читаемости.\nУпрощение работы с коллекциями данных и алгоритмами.\nПовышение гибкости и расширяемости кода.\nПримеры использования функций особого порядка:\n','##%%// Пример map() - удвоение каждого элемента списка%%\n##val numbers = listOf(1, 2, 3, 4, 5)\n##val doubledNumbers = numbers.map { it * 2 }\n##println(doubledNumbers) %%// Output: [2, 4, 6, 8, 10]%%\n\n##%%// Пример filter() - фильтрация только четных чисел%%\n##val evenNumbers = numbers.filter { it % 2 == 0 }\n##println(evenNumbers) %%// Output: [2, 4]%%\n\n##%%// Пример reduce() - суммирование элементов списка%%\n##val sumResult = numbers.reduce { acc, value -> acc + value }\n##println(sumResult) %%// Output: 15 (1 + 2 + 3 + 4 + 5)%%',NULL,'=Заключение=\n\nВ этом уроке вы познакомились с концепцией функций высшего порядка. \nФункции большого размера - это мощный инструмент, который позволяет более гибко и компактно обрабатывать данные, повышать читаемость и поддерживать код. \nПрименение функций высшего порядка особенно полезно при работе с коллекцией данных, так как позволяет применять общие операции к каждому элементу списка или фильтровать данные по критериям.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(43,1,7,42,61,43,9,'rus','2023-11-01',NULL,'Введение в жизненный цикл Деятельность','=1. Что такое жизненный цикл Activity? =\nЖизненный цикл Activity представляет собой серию событий, которые проходят от момента его создания до момента удаления. \nПоощрение жизненного цикла является важным для разработчиков Android, так как позволяет эффективно управлять потреблением и состоянием приложений, максимально интенсивное взаимодействие с пользователем. \n\n=2. Основные этапы жизненного цикла Деятельность:=\n\n=onCreate():= Этот метод вызвался при создании Activity. В этом методе произошла модификация пользовательского интерфейса и другие случаи.\n\n=onStart():= Метод вызова, когда активность становится видимой для пользователя, но еще не становится взаимодействующей.\n\n=onResume():= Этот метод опроса, когда активность становится активной и готовой для взаимодействия с пользователем.\n В этом методе обычно размещают код для запуска анимаций, обновления данных и т.д.\n\n=onPause():= Этот метод вызывается, когда другое Activity становится активным или приложение становится частично невидимым. \nВ этом методе можно изменить изменения, чтобы избежать потери данных.\n\n=onStop():= Метод вызова, когда активность становится полностью невидимой для пользователя. \nЗдесь можно выполнять операции, которые должны быть приостановлены, когда активность не видна.\n\n=onDestroy():= Этот метод восстания перед тем, как Activity будет обезврежен. Здесь вы должны захватывать ресурсы и заключать другие завершающие операции.\n\n=3. Переходы между состояниями:=\n\nКогда пользователь запускает приложение, активность onCreate()-> onStart()-> onResume().\nКогда другое Активность перекрывает активность, активность onPause()-> onStop().\nКогда пользователь возвращается на ранее открытое Активность, активность onRestart()-> onStart()-> onResume().\nКогда приложение закрывается или уничтожается системой, восстание onPause()-> onStop()-> onDestroy().\n=4. Конфигурационные изменения: =\nКогда естественны конфигурационные изменения, такие как поворот экрана или изменение языка, активность может быть заражена и пересоздана.\n В таких случаях система автоматически сохраняет состояние Activity (если его метод onSaveInstanceState()используется) и восстанавливает после пересоздания.\n\n=5. Заключение: =\nЖизненный цикл Activity — это важная концепция в Android-разработке, которая помогает эффективно управлять ограничениями и условиями приложений. \nПонимание этой картины позволяет разработчикам создавать более стабильные и отзывчивые приложения.\n',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(44,1,7,43,62,44,9,'rus','2023-11-01',NULL,'Работа с намерениями и переходами между действиями с учетом жизненного цикла Activity','=Введение=\nВ этом уроке мы рассмотрим, как работать с намерениями (Intents) в Android, чтобы осуществлять переходы между различными действиями (Activities) в приложении. \nТакже мы учтем жизненный цикл Activity при переходах.\n\n=Намерения и переходы между действиями=\nНамерение (Intent) - это способ для компонентов Android взаимодействовать друг с другом. В основном, используется для\n\nЗапуска действий (Activities, Services, Broadcast Receivers)\nПередачи данных между компонентами\nПример перехода с передачей данных в SecondActivity\n','##val **intent** = Intent(this, SecondActivity::class.java)\n##**intent**.putExtra(key, \"Hello from FirstActivity!\")\n##startActivity(**intent**)',NULL,'В этом примере мы создаем намерение для перехода из FirstActivity в SecondActivity. Мы также добавляем дополнительные данные в намерение с помощью putExtra.\n\n=Часть 3 Жизненный цикл и переходы=\nПри переходе между действиями, жизненный цикл каждой активности срабатывает. Это важно учитывать для сохранения данных и правильного функционирования.\n\n=Пример=','##class FirstActivity  AppCompatActivity() {\n   ##private var **binding**: ActivityFirstBinding? = null\n    ##override fun ^^onCreate^^(savedInstanceState Bundle) {\n        ##super.^^onCreate^^(savedInstanceState)\n         ##**binding** = ActivityFirstBinding.inflate(layoutInflater)\n        ##val **view** = **binding**?.root\n        ##setContentView(**view**)\n\n 	 ##binding?.button.setOnClickListener {\n            ##val **message** = \"Hello from FirstActivity!\"\n            ##val **intent** = Intent(this, SecondActivity::class.java)\n            ##**intent**.putExtra(\"message\", message)\n            ##startActivity(**intent**)\n        ##}\n    ##}\n##}\n\n##class SecondActivity  AppCompatActivity() {\n ##private var **binding**: ActivitySecondBinding? = null\n    ##override fun ^^onCreate^^(savedInstanceState Bundle) {\n        ##super.^^onCreate^^(savedInstanceState)\n        ##binding = ActivitySecondBinding.inflate(layoutInflater)\n        ##val **view** = binding?.root\n        ##setContentView(**view**)\n\n        ##val **receivedMessage** = **intent**.getStringExtra(\"message\")\n        ##**binding**?.messageTextView.text = **receivedMessage**\n    ##}\n##}\n',NULL,'=Часть 4 Заключение=\nВ этом уроке мы изучили, как работать с намерениями и осуществлять переходы между действиями.\n Важно учитывать жизненный цикл Activity при переходах, чтобы обеспечить правильную работу приложения и сохранение данных.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(45,1,7,44,63,45,9,'rus','2023-11-01',NULL,'Управление жизненным циклом Activity','=Введение=\nВ этом уроке мы подробно рассмотрим жизненный цикл Activity в Android и предоставим примеры, чтобы лучше понять, как управлять этим циклом для создания стабильных приложений.\n\n\n=Примеры управления жизненным циклом=\n\nПример 1: Сохранение данных перед уничтожением Activity','##class MainActivity : AppCompatActivity() {\n\n    ##private var **counter** = 0\n\n    ##override fun ^^onCreate^^(savedInstanceState: Bundle?) {\n        ##super.^^onCreate^^(savedInstanceState)\n        ##setContentView(R.layout.activity_main)\n\n        ##if (savedInstanceState != null) {\n            ##**counter** = savedInstanceState.getInt(\"counter\", 0)\n        ##}\n\n        ##updateCounterUI()\n    ##}\n\n    ##override fun ^^onSaveInstanceState^^(outState: Bundle) {\n        ##super.^^onSaveInstanceState^^(outState)\n        ##outState.putInt(\"counter\", counter)\n    ##}\n\n    ##fun ^^incrementCounter^^(view: View) {\n        ##counter++\n        ##updateCounterUI()\n    ##}\n\n    ##private fun ^^updateCounterUI^^() {\n        ##val **counterTextView** = findViewById<TextView>(R.id.counterTextView)\n        ##**counterTextView**.text = \"Counter: $counter\"\n    ##}\n##}',NULL,'=Что делает этот пример:=\n\nМы создаем Activity StateSavingActivity, которая содержит счетчик.\nВ методе onCreate мы проверяем наличие сохраненных данных в savedInstanceState и восстанавливаем значение счетчика, если они есть.\nПри нажатии на кнопку \"Увеличить\" счетчик увеличивается на 1 и обновляется UI.\nВ методе onSaveInstanceState мы сохраняем текущее значение счетчика перед пересозданием Activity.\nЭтот пример показывает, как обрабатывать сохранение и восстановление состояния при пересоздании Activity, чтобы пользовательские данные сохранялись, даже если пользователь поворачивает устройство.\n=Пример 2: Остановка таймера при уходе в фоновый режим=','##class TimerActivity : AppCompatActivity() {\n\n    ##private var **timer**: Timer? = null\n\n    ##override fun ^^onCreate^^(savedInstanceState: Bundle?) {\n        ##super.^^onCreate^^(savedInstanceState)\n        ##setContentView(R.layout.activity_timer)\n    ##}\n\n    ##override fun ^^onResume^^() {\n        ##super.^^onResume^^()\n        ##startTimer()\n    ##}\n\n    ##override fun ^^onPause^^() {\n        ##super.^^onPause^^()\n        ##stopTimer()\n    ##}\n\n    ##private fun ^^startTimer^^() {\n        ##**timer** = Timer()\n        ##**timer**?.scheduleAtFixedRate(object : TimerTask() {\n            ##override fun ^^run^^() {\n                ##%%// Выполнение задачи%%\n            ##}\n        ##}, 0, 1000) %%// Запуск каждую секунду%%\n    ##}\n\n    ##private fun ^^stopTimer^^() {\n        ##**timer**?.cancel()\n        ##**timer** = null\n    ##}\n##}',NULL,'В этом коде создается активность TimerActivity. Когда активность отображается на экране (в методе onResume), запускается таймер, который каждую секунду выполняет определенную задачу (в данном случае, задача пока пуста). Когда активность уходит с экрана (в методе onPause), таймер останавливается. \nЭто может быть использовано для выполнения действий с интервалом, например, обновления информации или периодической проверки состояния.\n=Заключение=\nПонимание и управление жизненным циклом Activity - это ключевой аспект разработки.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(46,1,7,45,64,46,9,'rus','2023-11-01',NULL,'Debug','Отладка (debugging) в Android Studio — это процесс исследования и исправления ошибок в вашем приложении. Он позволяет вам пошагово выполнять код, наблюдать за значениями переменных и анализировать поведение приложения для выявления проблем. \n=Отладку в Android Studio, мы выполним в данном примере:=\n','##fun ^^main^^() {\n    ##val **numbers** = listOf(1, 2, 3, 4, 5)\n    ##var **sum** = 0\n\n    ##for (number in **numbers**) {\n        ##sum += **number**\n    ##}\n\n    ##println(\"Сумма чисел: $sum\")\n##}',NULL,'Мы установим точку останова на строке sum += number, чтобы проанализировать, какие числа добавляются.\n\nЗапустите отладку, нажав на зеленого жука на панели инструментов Android Studio, или выбрав пункт \"Debug\" из меню \"Run\".\n\nПрограмма будет запущена в режиме отладки, и выполнение остановится на точке останова.\n\nВ окне \"Debug\" внизу Android Studio вы можете видеть значения переменных и текущее состояние программы. Вы можете наблюдать за изменениями значений переменных, выполнять шаги по коду и анализировать их состояние.\n\nИспользуйте кнопки на панели инструментов или сочетания клавиш для выполнения шагов отладки. Например, вы можете использовать кнопку \"Step Over\" для перехода к следующей строке кода или кнопку \"Resume Program\" для продолжения выполнения до следующей точки останова.\n\nВ процессе отладки вы можете проверять значения переменных и выполнять другие действия. Например, в окне \"Debug\" вы можете ввести имя переменной и посмотреть ее текущее значение.\n\nПродолжайте выполнение программы и анализируйте значения переменных, пока не найдете и исправите ошибки или не получите нужные результаты.\n\nЭто простой пример использования отладки в Kotlin. Вы можете использовать более сложные сценарии и функции отладки, такие как условные точки останова, наблюдение за переменными и многое другое, в зависимости от ваших потребностей.\n',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(47,1,8,46,65,47,10,'rus','2023-11-01',NULL,'Основные концепции Объектно-Ориентированного Программирования (ООП)','В данной лекции мы более подробно рассмотрим основные концепции Объектно-Ориентированного Программирования (ООП) - Наследование, Абстрактные классы, Интерфейсы, Полиморфизм и Перегрузка методов.\n\n=1. Наследование=\n\nНаследование позволяет создавать новый класс на основе уже существующего (родительского) класса. Подкласс (дочерний класс) наследует поля и методы родительского класса. Основное преимущество наследования - повторное использование кода.\n\n=2. Абстрактные классы=\n\nАбстрактные классы - это классы, которые не могут быть созданы непосредственно, а служат в качестве базовых для других классов. Они могут содержать абстрактные методы (без реализации), которые должны быть переопределены в подклассах.\n\n=3. Интерфейсы=\n\nИнтерфейсы определяют контракты для классов, указывая на методы, которые класс должен реализовать. Класс может реализовать несколько интерфейсов, что обеспечивает множественное наследование методов.\n\n=4. Полиморфизм=\n\nПолиморфизм - это способность использовать один и тот же интерфейс (метод или функцию) для разных классов. Полиморфизм позволяет создавать универсальные алгоритмы, работающие с разными типами данных.\n\n=5. Перегрузка методов=\n\nПерегрузка методов позволяет определить несколько методов с одним именем в одном классе. Эти методы имеют разные параметры (типы или количество), и компилятор выберет подходящий метод на основе переданных аргументов.\n\n\n=Заключение=\n\nОсновные концепции ООП - Наследование, Абстрактные классы, Интерфейсы, Полиморфизм и Перегрузка методов - позволяют создавать гибкий, структурированный и повторно используемый код. Они обеспечивают эффективное проектирование и разработку программного обеспечения, а также способствуют более понятному и легкому сопровождению кода.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(48,1,8,47,66,48,10,'rus','2023-11-01',NULL,'Инкапсуляция','В этом уроке мы рассмотрим концепцию инкапсуляции и предоставим примеры, чтобы понять, как она работает и как она может помочь создавать более безопасный и модульный код.\n\n=Инкапсуляция Основы=\n\nИнкапсуляция - это один из ключевых принципов объектно-ориентированного программирования.\n Она позволяет скрыть детали реализации класса и предоставить публичный интерфейс для взаимодействия с объектом. \nЭто означает, что данные и методы, которые необходимы только внутри класса, остаются скрытыми от внешнего мира.\n\n=Пример 1 Инкапсуляция полей класса=\n','##class BankAccount(private var balance Double) {\n    ##fun ^^deposit^^(amount Double) {\n        ##if (amount  0) {\n            ##balance += amount\n        ##}\n    ##}\n\n    ##fun ^^withdraw^^(amount Double) {\n        ##if (amount  0 && amount = balance) {\n            ##balance -= amount\n        ##}\n    ##}\n\n    ##fun ^^getBalance^^() Double {\n        ##return balance\n    ##}\n##}\n##fun ^^main^^() {\n    ##val **account** = BankAccount(100.0)\n    ##account.^^deposit^^(50.0)\n    ##account.^^withdraw^^(30.0)\n    ##println(\"Current balance: ${account.getBalance()}\")\n##}',NULL,'В этом примере мы создали класс BankAccount, который имеет закрытое поле balance. Мы предоставили методы deposit и withdraw для изменения баланса с проверками на валидность операций. Метод getBalance позволяет получить текущий баланс.\n\n=Пример 2 Инкапсуляция методов класса=','##class TemperatureConverter(private var **celsius** Double) {\n    ##fun ^^setCelsius^^(value Double) {\n        ##**celsius** = value\n    ##}\n\n    ##fun ^^setFahrenheit^^(value Double) {\n        ##**celsius** = (value - 32)  5  9\n    ##}\n\n    ##fun ^^getCelsius^^() Double {\n        ##return **celsius**\n    ##}\n\n    ##fun ^^getFahrenheit^^() Double {\n        ##return **celsius**  9  5 + 32\n    ##}\n##}\n##fun ^^main^^() {\n    ##val **converter** = TemperatureConverter(0.0)\n    ##**converter**.^^setCelsius^^(25.0)\n    ##println(\"Celsius: ${converter.getCelsius()} | Fahrenheit: ${converter.getFahrenheit()}\")\n    ##**converter**.^^setFahrenheit^^(77.0)\n    ##println(\"Celsius: ${converter.getCelsius()} | Fahrenheit: ${converter.getFahrenheit()}\")\n##}',NULL,'Здесь у нас есть класс TemperatureConverter, который преобразует температуры между шкалами Цельсия и Фаренгейта. Мы предоставили методы для установки и получения значений температуры, а также применили инкапсуляцию к расчетам.\n\n=Пример 3 Инкапсуляция с приватными методами=','##class ShoppingCart {\n    ##private val **items** = mutableListOfString()\n\n    ##fun ^^addItem^^(item String) {\n        ##**items**.add(item)\n    ##}\n\n    ##fun ^^removeItem^^(item String) {\n        ##**items**.remove(item)\n    ##}\n\n    ##fun ^^displayItems^^() {\n        ##println(Items in the cart ${items.joinToString(, )})\n    ##}\n\n    ##fun ^^checkout^^() {\n        ##^^displayItems^^()\n        ##println(Checkout completed.)\n        ##clearCart()\n    ##}\n\n    ##private fun ^^clearCart^^() {\n        ##**items**.clear()\n    ##}\n##}\n##fun ^^main^^() {\n    ##val **cart** = ShoppingCart()\n    ##**cart**.addItem(\"Item 1\")\n    ##**cart**.addItem(\"Item 2\")\n    ##**cart**.displayItems()\n    ##**cart**.checkout()\n##}',NULL,'В этом примере мы создали класс ShoppingCart, представляющий корзину для покупок. Мы предоставили методы для добавления и удаления товаров, отображения содержимого корзины и оформления заказа. Метод clearCart является приватным и доступен только внутри класса.\n\n=Заключение=\n\nИнкапсуляция позволяет создавать защищенные и управляемые объекты, скрывая внутренние детали реализации. Она обеспечивает контролируемый доступ к данным и методам класса, что способствует более надежному и гибкому программированию.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(49,1,8,48,67,49,10,'rus','2023-11-01',NULL,'Наследование, Абстрактные классы и Интерфейсы','В этом уроке мы рассмотрим ключевые концепции наследования, абстрактных классов и интерфейсов.\nЭти концепции помогут вам создавать более структурированный и гибкий код, улучшая его модульность и переиспользуемость.\n\n=Наследование=\nНаследование позволяет одному классу наследовать свойства и методы другого класса.\n В Kotlin, класс должен быть объявлен с модификатором open, чтобы его можно было унаследовать.\n','##open class Vehicle(val name: String) {\n    ##open fun ^^start^^() {\n        ##println(\"$name is starting\")\n    ##}\n##}\n\n##class Car(name: String) : Vehicle(name) {\n    ##fun ^^drive^^() {\n        ##println(\"$name is driving\")\n    ##}\n##}\n\n##class Bus(name: String) : Vehicle(name) {\n    ##fun ^^stop^^() {\n        ##println(\"$name is stopping\")\n    ##}\n##}\n\n##fun ^^main^^() {\n    ##val **myCar** = Car(\"Toyota Corolla\")\n    ##val **myBus** = Bus(\"City Bus\")\n\n    ##**myCar**.^^start^^()\n    ##**myCar**.^^drive^^()\n\n    ##**myBus**.^^start^^()\n    ##**myBus**.^^stop^^()\n##}',NULL,'В этом примере мы создали базовый класс Vehicle, который имеет метод start(), описывающий начало движения. Затем у нас есть классы Car и Bus, которые наследуют этот базовый класс. Класс Car добавляет метод drive(), а класс Bus добавляет метод stop().\nИсключение:\nНаследовать что либо из класса родителя, вы можете только, если у этого элемента модификатор доступа не является привтным.\nПлюсы наследования:\n\nПовторное использование кода: Благодаря наследованию, мы можем использовать общие характеристики и методы, определенные в базовом классе Vehicle, в классах Car и Bus, без необходимости дублирования кода.\n\nСтруктурированность: Используя наследование, мы создаем иерархию классов, что делает код более структурированным и легко понимаемым. Мы видим, что все транспортные средства имеют общий метод start(), что делает код предсказуемым.\n\nРасширяемость: Если мы решим добавить новый тип транспортного средства, например, велосипед, мы можем создать новый класс, который наследует базовый класс Vehicle, и реализовать специфичное поведение для велосипеда.\n\nПолиморфизм: Благодаря наследованию, мы можем использовать объекты производных классов в тех местах кода, где ожидается объект базового класса. Например, мы можем создать массив транспортных средств и вызвать метод start() для каждого из них, независимо от их конкретного типа.\n\n=Абстрактные классы=\nАбстрактные классы представляют классы, которые нельзя создать напрямую, но могут содержать абстрактные методы и методы с реализацией.\n Абстрактные методы объявляются без тела и должны быть переопределены в подклассах.','##abstract class Shape(val name: String) {\n    ##abstract fun ^^draw^^()\n##}\n\n##class Circle(name: String) : Shape(name) {\n    ##override fun ^^draw^^() {\n        ##println(\"$name circle is drawn\")\n    ##}\n##}\n\n##class Square(name: String) : Shape(name) {\n    ##override fun ^^draw^^() {\n        ##println(\"$name square is drawn\")\n    ##}\n##}',NULL,'Здесь Shape - абстрактный класс с абстрактным методом draw(), который переопределяется в классах Circle и Square.\n\n=Интерфейсы=\nИнтерфейсы задают контракты, которые классы должны выполнить.\n Они могут содержать абстрактные методы без реализации, а также методы с реализацией начиная с версии Kotlin 1.4.\n','##interface SoundMaker {\n    ##fun ^^makeSound^^()\n##}\n\n##class Dog(val name: String) : SoundMaker {\n    ##override fun ^^makeSound^^() {\n        ##println(\"$name is barking\")\n    ##}\n##}\n\n##class Cat(val name: String) : SoundMaker {\n    ##override fun ^^makeSound^^() {\n        ##println(\"$name is meowing\")\n    ##}\n##}',NULL,'В данном примере, классы Dog и Cat реализуют интерфейс SoundMaker, обязываясь предоставить реализацию метода makeSound().\n\n=Практический пример=\nДавайте рассмотрим практический пример, объединяющий все концепции: наследование, абстрактные классы и интерфейсы.\n','##%%// Базовый класс \"Транспортное средство\"%%\n##open class Vehicle(val name: String) {\n    ##open fun ^^start^^() {\n        ##println(\"$name is starting\")\n    ##}\n##}\n\n##%%// Абстрактный класс \"Автомобиль\", наследующий \"Транспортное средство\"%%\n##abstract class Car(name: String) : Vehicle(name) {\n    ##abstract fun ^^drive^^()\n##}\n\n##%%// Интерфейс \"Электрическое транспортное средство\"%%\n##interface ElectricVehicle {\n    ##fun ^^charge^^()\n##}\n\n##%%// Класс \"Электрический автомобиль\", реализует \"Автомобиль\" и \"Электрическое транспортное средство\"%%\n##class ElectricCar(name: String) : Car(name), ElectricVehicle {\n    ##override fun ^^drive^^() {\n        ##println(\"$name is driving\")\n    ##}\n\n    ##override fun ^^charge^^() {\n        ##println(\"$name is charging\")\n    ##}\n##}\n\n##fun ^^main^^() {\n    ##val **myCar** = ElectricCar(\"Tesla Model 3\")\n    ##**myCar**.^^start^^()\n    ##**myCar**.^^drive^^()\n    ##**myCar**.^^charge^^()\n##}',NULL,'В этом примере:\nКласс ElectricCar наследует абстрактный класс Car и реализует интерфейс ElectricVehicle.\nКласс Car в свою очередь наследует класс Vehicle.\nВ результате мы создали иерархию классов и определили общее поведение, а также контракты, которые классы должны выполнять.\n\n=Когда использовать что?=\nИспользуйте наследование, когда вы хотите делать подклассы на основе существующих классов и изменять их поведение.\nИспользуйте абстрактные классы, чтобы создавать общее поведение, которое будет наследоваться.\nИспользуйте интерфейсы, чтобы объявить контракты, которые классы должны выполнить, независимо от их иерархии.\n=Заключение=\nВ этом уроке мы разобрали ключевые концепции наследования, абстрактных классов и интерфейсов в языке программирования Kotlin.\n Эти инструменты позволяют создавать гибкий и модульный код, улучшая его структуру и переиспользуемость. Наследование помогает строить иерархии классов, абстрактные классы - определять общее поведение, а интерфейсы - объявлять контракты, которые классы обязаны выполнить.\n',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(50,1,8,49,68,50,10,'rus','2023-11-01',NULL,'Перегрузка методов','В этом уроке мы рассмотрим концепцию перегрузки методов.\n Перегрузка позволяет определить несколько методов с одним и тем же именем, но различными параметрами.\n Это удобно, когда вы хотите обеспечить однотипные действия для разных типов данных.\n\n=Пример 1 Основы перегрузки методов=\n','##class MathOperations {\n    ##fun ^^add^^(a Int, b Int) Int {\n        ##return a + b\n    ##}\n\n    ##fun ^^add^^(a Double, b Double) Double {\n       ##return a + b\n    ##}\n##}\n\n##fun ^^main^^() {\n    ##val **math** = MathOperations()\n    ##println(Sum of integers ${math.add(5, 3)})\n    ##println(Sum of doubles ${math.add(2.5, 1.7)})\n##}',NULL,'В этом примере мы создали класс MathOperations, который имеет два метода с именем add. \nОдин принимает целочисленные аргументы, а другой - аргументы с плавающей точкой. Компилятор различает их по типам параметров.\n\n=Пример 2 Перегрузка методов с различным числом параметров=\n','##class StringUtil {\n    ##fun ^^concatenate^^(a String, b String) String {\n        ##return a + b\n    ##}\n\n    ##fun ^^concatenate^^(a String, b String, c String) String {\n        ##return a + b + c\n    ##}\n##}\n\n##fun ^^main^^() {\n    ##val **strUtil** = StringUtil()\n    ##println(Concatenation ${strUtil.concatenate(Hello, , world!)})\n    ##println(Triple concatenation ${strUtil.concatenate(This,  is,  Kotlin)})\n##}',NULL,'В этом примере мы определили класс StringUtil, у которого есть два метода с именем concatenate. \nОдин принимает две строки, а другой - три. Параметры различаются по количеству.\n\n=Пример 3 Перегрузка методов с nullable параметрами=','##class Printer {\n    ##fun ^^print^^(message String) {\n        ##println(message)\n    ##}\n\n    ##fun ^^print^^(message Int) {\n        ##println(Number $message)\n    ##}\n##}\n\n##fun ^^main^^() {\n    ##val **printer** = Printer()\n    ##**printer**.^^print^^(Hello, Kotlin!)\n    ##**printer**.^^print^^(42)\n##}',NULL,'В этом примере класс Printer имеет два метода print, один для строк и другой для целых чисел (с возможностью null). \nПерегрузка позволяет выбирать подходящий метод в зависимости от типа аргумента.\n\n=Заключение=\n\nПерегрузка методов - это важный механизм в программировании, который позволяет создавать более удобный и гибкий код. \nОна позволяет определить несколько методов с одним именем, но с разными параметрами.\n Это особенно полезно, когда вы хотите выполнить одинаковую операцию, но с разными типами данных или количеством аргументов.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(51,1,8,50,69,51,10,'rus','2023-11-01',NULL,'Полиморфизм','В этом уроке мы рассмотрим понятие полиморфизма в программировании, а также как его реализовать. Полиморфизм позволяет одному интерфейсу или методу иметь несколько различных реализаций.\n\n=Что такое полиморфизм=\n\nПолиморфизм - это принцип ООП, который позволяет объектам различных классов использоваться одинаково при вызове общего метода или интерфейса. Это означает, что одна и та же операция может выполняться на разных типах данных.\n\n=Пример полиморфизма=\n\nДля примера, давайте рассмотрим ситуацию, где есть базовый класс Shape и его подклассы Circle и Rectangle. У каждой фигуры есть метод calculateArea(), но каждая фигура будет реализовывать этот метод по-своему.\n','##open class Shape {\n    ##open fun ^^calculateArea^^() Double {\n        ##return 0.0\n    ##}\n##}\n\n##class Circle(val radius Double)  Shape() {\n    ##override fun ^^calculateArea^^() Double {\n        ##return Math.PI  radius  radius\n    ##}\n##}\n\n##class Rectangle(val width Double, val height Double)  Shape() {\n    ##override fun ^^calculateArea^^() Double {\n        ##return width  height\n    ##}\n##}',NULL,'=Применение полиморфизма=\n\nТеперь мы можем создать массив фигур разных типов и вызвать для каждой из них метод calculateArea()\n','##fun ^^main^^() {\n    ##val **shapes** ArrayShape = arrayOf(\n        ##Circle(5.0),\n        ##Rectangle(4.0, 6.0)\n    ##)\n    \n    ##for (shape in **shapes**) {\n        ##println(Area ${shape.calculateArea()})\n    ##}\n##}',NULL,'В этом примере, благодаря полиморфизму, мы можем вызвать метод calculateArea() на объектах разных типов (круг и прямоугольник), и каждый из них предоставит свою собственную реализацию этого метода.\n\n=Преимущества полиморфизма=\n\nГибкость Полиморфизм позволяет легко добавлять новые классы, расширяя функциональность без необходимости изменения существующего кода.\n\nУдобство Полиморфные вызовы позволяют обращаться к разным объектам через общий интерфейс или метод, что упрощает управление и понимание кода.\n\nРасширяемость Полиморфизм позволяет создавать более абстрактные и обобщенные классы, способствуя повторному использованию кода.\n\n=Заключение=\n\nПолиморфизм - это важный концепт в объектно-ориентированном программировании, позволяющий создавать гибкий и расширяемый код. Полиморфизм реализуется через наследование, интерфейсы и переопределение методов.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(52,1,8,51,70,52,10,'rus','2023-11-01',NULL,'Введение в фрагменты в KotlinВведение в фрагменты в Kotlin','=Что такое фрагменты в Kotlin?=\n\nФрагменты (fragments) в языке программирования Kotlin представляют собой части кода, которые могут быть многократно использованы в разных местах программы.\n Они позволяют разбить код на более мелкие и логически связанные части, что упрощает поддержку и расширение кода.\n\n=Зачем использовать фрагменты?=\n\nМногократное использование: Вы можете создать фрагмент с определенной функциональностью и вставлять его в разные части вашей программы без необходимости дублировать код.\n\nРазделение ответственности: Фрагменты помогают разделить программный код на логически связанные блоки, улучшая читаемость и обслуживаемость кода.\n\nУпрощение обновлений: Если вы хотите внести изменения, вам придется внести их только в одном месте (фрагменте), что уменьшает риск ошибок и упрощает обновления.\nТакже сейчас рекомендуется Система \"Single Activity\" (одна активити) - это подход в разработке, при котором приложение состоит из одной главной активити и нескольких фрагментов, которые меняются внутри этой активити в зависимости от действий пользователя.\n\n=Как создать фрагмент в Kotlin?=\n\nСоздание файла фрагмента: Создайте новый файл с расширением .kt. Например, MyFragment.kt.\n\nОпределение класса фрагмента: Определите класс фрагмента, который наследуется от Fragment:','##import android.os.Bundle\n##import androidx.fragment.app.Fragment\n\n##class MyFragment : Fragment() {\n    ##%%// Ваш код фрагмента%%\n##}',NULL,'Определение макета: Определите макет (разметку) для вашего фрагмента. Создайте XML файл в папке res/layout:','##<!-- my_fragment_layout.xml -->\n##<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    ##android:layout_width=\"match_parent\"\n    ##android:layout_height=\"match_parent\"\n    ##android:orientation=\"vertical\">\n\n    ##<!-- Элементы разметки вашего фрагмента -->\n\n##</LinearLayout>',NULL,'Связывание макета с фрагментом: В методе onCreateView вашего фрагмента, свяжите созданный макет с фрагментом:','##override fun ^^onCreateView^^(\n    ##inflater: LayoutInflater, container: ViewGroup?,\n    ##savedInstanceState: Bundle?\n##): View? {\n    ##return inflater.inflate(R.layout.my_fragment_layout, container, false)\n##}',NULL,'=Как использовать фрагмент в активности?=\n\nДобавление фрагмента в макет активности: В макете вашей активности добавьте контейнер для отображения фрагмента:','##<!-- activity_main.xml -->\n##<FrameLayout\n    ##android:id=\"@+id/fragment_container\"\n    ##android:layout_width=\"match_parent\"\n    ##android:layout_height=\"match_parent\" />',NULL,'Добавление фрагмента программно: В коде активности используйте FragmentManager для добавления фрагмента в контейнер:','##val **fragment** = MyFragment()\n##val **fragmentManager** = supportFragmentManager\n##val **transaction** = **fragmentManager**.beginTransaction()\n##**transaction**.replace(R.id.fragment_container, **fragment**)\n##**transaction**.commit()',NULL,'=Заключение=\n\nФрагменты - это мощный инструмент для организации и структурирования вашего кода в Android-приложениях. \nОни позволяют разделить программу на логические части, облегчают обновления и поддержку кода, а также улучшают повторное использование компонентов.\n Начните с создания фрагментов в своих проектах и постепенно углубляйтесь в более сложные концепции.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(53,3,15,52,71,53,19,'rus','2023-11-01',NULL,'=MVP=','Сейчас мы рассмотрим еще один популярный паттерн в архитектуре - MVP, или Model-View-Presenter. \n Этот паттерн поможет нам создавать более структурированный и тестируемый код, улучшая общее качество приложения. \n \nЧасть 1: Основы паттерна MVP \n \nMVP состоит из трех ключевых компонентов: \n \nМодель (Model): Это слой, отвечающий за бизнес-логику и взаимодействие с данными. \n Он предоставляет методы для получения и обработки данных, но не знает ничего о том, как эти данные будут отображаться. \n \nПредставление (View): Этот слой отображает данные пользователю и обрабатывает пользовательский ввод. \n Важно, чтобы представление было максимально passivе - оно не должно содержать логику, связанную с бизнес-процессами. \n \nПрезентер (Presenter): Этот слой является посредником между моделью и представлением. \n Он получает данные от модели, обрабатывает их и передает в представление для отображения.  \nПрезентер также принимает пользовательский ввод с представления и решает, какие действия нужно предпринять. \n \nЧасть 2: Пример реализации MVP в Kotlin','##%%// Модель - класс, представляющий задачу%% \n##data class Task(val id: Int, val title: String, val description: String) \n \n##%%// Интерфейс для Model (сервис, загружающий данные)%% \n##interface TaskModel { \n    ##fun ^^getTasks^^(): List<Task> \n##} \n \n##%%// Реализация Model%% \n##class TaskModelImpl : TaskModel { \n    ##override fun ^^getTasks^^(): List<Task> { \n        ##%%// Здесь может быть код для загрузки данных из базы данных или сети%% \n        ##return listOf( \n            ##Task(1, \"Задача 1\", \"Описание задачи 1\"), \n            ##Task(2, \"Задача 2\", \"Описание задачи 2\"), \n            ##Task(3, \"Задача 3\", \"Описание задачи 3\") \n        ##) \n    ##} \n##} \n \n##%%// Интерфейс для View (Activity или Fragment)%% \n##interface TaskView { \n    ##fun ^^showTasks^^(tasks: List<Task>) \n##} \n \n##%%// Presenter - управляет взаимодействием между Model и View%% \n##class TaskPresenter(private val model: TaskModel, private val view: TaskView) { \n    ##fun ^^loadTasks^^() { \n        ##val tasks = model.^^getTasks^^() \n        ##view.showTasks(tasks) \n    ##} \n##} \n \n##%%// Шаг 2: Реализация View (Activity или Fragment) с RecyclerView%% \n \n##class TaskActivity : AppCompatActivity(), TaskView { \n    ##private lateinit var presenter: TaskPresenter \n     \n    ##override fun ^^onCreate^^(savedInstanceState: Bundle?) { \n        ##super.^^onCreate^^(savedInstanceState) \n        ##setContentView(R.layout.activity_task) \n         \n        ##%%// Создание экземпляра Model и Presenter%% \n        ##val model = TaskModelImpl() \n        ##**presenter** = TaskPresenter(model, this) \n         \n        ##presenter.loadTasks() \n    ##} \n     \n    ##%%// Метод из интерфейса TaskView для отображения задач%% \n    ##override fun ^^showTasks^^(tasks: List<Task>) { \n        ##val recyclerView: RecyclerView = findViewById(R.id.taskRecyclerView) \n        ##val adapter = TaskAdapter(tasks) \n        ##**recyclerView**.**adapter** = adapter \n    ##} \n##}',NULL,'В этом примере Presenter (TaskPresenter) занимается управлением взаимодействия между Model (TaskModel) и View (TaskView). \n Model предоставляет данные, а Presenter обрабатывает их и передает во View для отображения.  \nВ реализации View (TaskActivity), Presenter создается и вызывается метод loadTasks() для загрузки и отображения задач. \nЗаключение: \n \nПаттерн MVP позволяет разделить логику, представление и данные, делая код более читаемым, модульным и тестируемым \n. Он активно используется в разработке Android-приложений, помогая создавать приложения, которые легко масштабировать и поддерживать.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(54,3,15,53,72,54,19,'rus','2023-11-01',NULL,' =MVVM в Android=','Архитектурный паттерн MVVM (Model-View-ViewModel) используется для разделения кода на три ключевых компонента: Model, View и ViewModel. \n Этот паттерн позволяет более удобно управлять данными и обработкой пользовательского взаимодействия. \n \nКомпоненты MVVM: \n \nМодель (Model): Это слой, который отвечает за бизнес-логику и работу с данными. Модель не знает о представлении или ViewModel, что обеспечивает независимость компонентов. \n \nПредставление (View): Этот слой обрабатывает пользовательский интерфейс, отображает данные и реагирует на взаимодействие пользователя. Однако представление не содержит бизнес-логику или данные напрямую. \n \nViewModel: ViewModel служит прослойкой между моделью и представлением. Он обрабатывает бизнес-логику, управляет состоянием представления и предоставляет данные, необходимые для отображения. \n \n \nДля примера рассмотрим приложение \"Список задач\" с использованием паттерна MVVM и RecyclerView. \nШаги для создания MVVM: \n1. Создание Model:','##%%// Модель - класс, представляющий задачу%% \n##data class Task(val id: Int, val title: String, val description: String) \n \n##%%// Репозиторий - класс для загрузки данных задач%% \n##class TaskRepository { \n      ##fun ^^getTasks^^(): List<Task> { \n        ##%%// Здесь мы пока что не прошли, как загружать данные из базы данных или сети.%% \n        ##%%// Поэтому возвращаем временный список задач.%% \n        ##return listOf( \n            ##Task(1, \"Задача 1\", \"Описание задачи 1\"), \n            ##Task(2, \"Задача 2\", \"Описание задачи 2\"), \n            ##Task(3, \"Задача 3\", \"Описание задачи 3\") \n        ##) \n    ##} \n##} \n \n##%%// ViewModel - управляет данными задач и обработкой%% \n##class TaskViewModel : ViewModel() { \n    ##private val repository = TaskRepository() \n    ##private val tasks: MutableLiveData<List<Task>> = MutableLiveData() \n \n    ##init { \n        ##fetchTasks() \n    ##} \n \n    ##private fun ^^fetchTasks^^() { \n        ##val tasksList = repository.getTasks() \n        ##tasks.value = tasksList \n    ##} \n \n    ##%%// Метод для получения LiveData с данными задач%% \n    ##fun ^^getTasks^^(): LiveData<List<Task>> { \n        ##return tasks \n    ##} \n##} \nkotlin \nCopy code \n##%%// Шаг 2: Реализация View (Activity или Fragment) с RecyclerView%% \n \n##class TaskActivity : AppCompatActivity() { \n    ##private lateinit var taskViewModel: TaskViewModel \n     \n    ##override fun onCreate(savedInstanceState: Bundle?) { \n        ##super.onCreate(savedInstanceState) \n        ##setContentView(R.layout.activity_task) \n         \n        ##%%// Создание экземпляра ViewModel%% \n        ##taskViewModel = ViewModelProvider(this).get(TaskViewModel::class.java) \n         \n        ##%%// Получение ссылки на RecyclerView из макета%% \n        ##val recyclerView: RecyclerView = findViewById(R.id.taskRecyclerView) \n         \n        ##%%// Создание адаптера для RecyclerView%% \n        ##val adapter = TaskAdapter() \n        ##recyclerView.adapter = adapter \n         \n        ##%%// Подписка на изменения LiveData из ViewModel%% \n        ##taskViewModel.getTasks().observe(this, { tasks -> \n            ##%%// Обновление данных в адаптере при изменении LiveData%% \n            ##adapter.submitList(tasks) \n        ##}) \n    ##} \n##} \n \n##%%// Создание адаптера для RecyclerView%% \n##class TaskAdapter : ListAdapter<Task, TaskViewHolder>(TaskDiffCallback()) { \n    ##override fun ^^onCreateViewHolder^^(parent: ViewGroup, viewType: Int): TaskViewHolder { \n        ##val itemView = LayoutInflater.from(parent.context).inflate(R.layout.item_task, parent, false) \n        ##return TaskViewHolder(itemView) \n    ##} \n \n    ##override fun ^^onBindViewHolder^^(holder: TaskViewHolder, position: Int) { \n        ##val task = getItem(position)##holder.bind(task) \n    ##} \n##} \n \n##%%// Класс для определения различий между элементами списка%% \n##class TaskDiffCallback : DiffUtil.ItemCallback<Task>() { \n    ##override fun ^^areItemsTheSame^^(oldItem: Task, newItem: Task): Boolean { \n        ##return oldItem.id == newItem.id \n    ##} \n \n    ##override fun areContentsTheSame(oldItem: Task, newItem: Task): Boolean { \n        ##return oldItem == newItem \n    ##} \n##} \n##%%// Создание ViewHolder для элемента списка%% \n##class TaskViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) { \n    ##fun ^^bind^^(task: Task) { \n        ##itemView.titleTextView.text = task.title \n        ##itemView.descriptionTextView.text = task.description \n    ##} \n##}',NULL,'Заключение: \n \nПаттерн MVVM позволяет разделить бизнес-логику и отображение данных, что делает код более структурированным и удобным для тестирования. \n ViewModel предоставляет данные для отображения, и View отвечает за отображение и взаимодействие с пользователем.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(55,3,15,54,73,55,19,'rus','2023-11-01',NULL,'=MVI=','MVI (Model-View-Intent) - это архитектурный паттерн, который призван решить проблемы, связанные с управлением состоянием и обработкой действий пользователя в пользовательских интерфейсах, обеспечивая более четкую структуру, уменьшение возможности ошибок и предсказуемость поведения приложения. \n \nкак работает MVI: \n \nModel (Модель): Представляет состояние приложения. Это неизменяемые данные, содержащие всю информацию для отображения. \n \nView (Представление): Отображает данные из модели. Пассивно отображает информацию и создает интенты (намерения) для действий пользователя. \n \nIntent (Намерение): Представляет действия пользователя, такие как запросы на обновление, загрузку данных. \n \nPresenter (Презентер): Обрабатывает интенты, обновляет модель и возвращает новое состояние для отображения. Он управляет бизнес-логикой и состоянием приложения.','##%%// Модель - класс, представляющий задачу%% \n##data class Task(val id: Int, val title: String, val description: String) \n \n##%%// ViewIntent - класс, представляющий намерение от пользователя%% \n##sealed class TaskViewIntent { \n    ##object LoadTasks : TaskViewIntent() \n##} \n \n##%%// Интерфейс для Model (сервис, загружающий данные)%% \n##interface TaskModel { \n    ##fun getTasks(): List<Task> \n##} \n \n##%%// Реализация Model%% \n##class TaskModelImpl : TaskModel { \n    ##override fun ^^getTasks^^(): List<Task> { \n        ##%%// Здесь может быть код для загрузки данных из базы данных или сети%% \n        ##return listOf( \n            ##Task(1, \"Задача 1\", \"Описание задачи 1\"), \n            ##Task(2, \"Задача 2\", \"Описание задачи 2\"), \n            ##Task(3, \"Задача 3\", \"Описание задачи 3\") \n        ##) \n    ##} \n##}',NULL,'Шаг 2: Реализация View (Activity или Fragment) с RecyclerView','##class TaskActivity : AppCompatActivity() { \n \n    ##private val viewModel: TaskViewModel by viewModels() \n \n    ##override fun ^^onCreate^^(savedInstanceState: Bundle?) { \n        ##super.^^onCreate^^(savedInstanceState) \n        ##setContentView(R.layout.activity_task) \n \n        ##val recyclerView: RecyclerView = findViewById(R.id.taskRecyclerView) \n        ##val adapter = TaskAdapter() \n        ##recyclerView.adapter = adapter \n \n        ##**viewModel**.state.observe(this, { state -> \n            ##**adapter**.submitList(state.tasks) \n        ##}) \n \n        ##%%// Отправляем намерение загрузить задачи%% \n        ##**viewModel**.processIntent(TaskViewIntent.LoadTasks) \n    ##} \n##}',NULL,'Шаг 3: Реализация ViewModel и Reducer','##data class TaskViewState(val tasks: List<Task>) \n \n \n##class TaskViewModel(private val model: TaskModel) : ViewModel() { \n \n    ##private val _state = MutableLiveData<TaskViewState>() \n    ##val state: LiveData<TaskViewState> = _state \n \n    ##%%// Отправка намерения для обработки%% \n    ##fun ^^processIntent^^(intent: TaskViewIntent) { \n        ##when (intent) { \n            ##is TaskViewIntent.LoadTasks -> { \n                ##val tasks = model.getTasks() \n                ##val newState = TaskViewState(tasks) \n                ##**_state**.value = newState \n            ##} \n        ##} \n    ##} \n##}',NULL,'В этом примере ViewModel (TaskViewModel) принимает намерения (Intent) от View и обрабатывает их, возвращая состояние (ViewState). View (TaskActivity) подписывается на состояние и обновляет интерфейс при изменениях. Model (TaskModelImpl) предоставляет данные задач. \n \nПаттерн MVI позволяет более явно выразить взаимодействие между компонентами приложения и управлять состоянием интерфейса с помощью обработки намерений от пользователя.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(56,3,15,55,74,56,19,'rus','2023-11-01',NULL,'=LiveData=','LiveData - это компонент из архитектурных компонентов Android, который обеспечивает удобную и эффективную передачу данных между различными компонентами приложения, такими как Activity, Fragment, ViewModel и другие. \n \nПреимущества использования LiveData \n \nЖизненный цикл LiveData автоматически учитывает жизненный цикл компонентов (например, Activity или Fragment) и обновляет данные только тогда, когда компонент находится в активном состоянии. \n \nПредотвращение утечек памяти LiveData автоматически подписывается и отписывается от данных в соответствии с жизненным циклом компонента, что помогает предотвратить утечки памяти. \n \nОбработка изменений LiveData позволяет удобно обрабатывать изменения данных, предоставляя возможность реагировать на них с минимальным кодом. \n \nПример использования LiveData \n \nПредставим, что у нас есть простое приложение для отображения списка задач. Мы будем использовать LiveData для обновления списка задач в пользовательском интерфейсе. \n \nШаг 1 Добавление зависимостей \n \nДобавьте зависимость для архитектурных компонентов в вашем файле build.gradle','##build.gradle (Module app) \n##dependencies { \n    ##implementation androidx.lifecyclelifecycle-livedata2.3.1 \n##}',NULL,'Шаг 2: Создание класса данных (Task)','##data class Task(val id: Int, val title: String, val description: String)',NULL,'Шаг 3: Использование LiveData в Activity','##import android.os.Bundle \n##import androidx.appcompat.app.AppCompatActivity \n##import androidx.lifecycle.LiveData \n##import androidx.lifecycle.MutableLiveData \n \n##class TaskActivity : AppCompatActivity() { \n \n    ##private val _tasks = MutableLiveData<List<Task>>() \n    ##val tasks: LiveData<List<Task>> = _tasks \n \n    ##override fun ^^onCreate^^(savedInstanceState: Bundle?) { \n        ##super.^^onCreate^^(savedInstanceState) \n        ##setContentView(R.layout.activity_task) \n \n        ##%%// Загружаем данные (может быть из репозитория)%% \n        ##val sampleTasks = listOf( \n            ##Task(1, \"Задача 1\", \"Описание задачи 1\"), \n            ##Task(2, \"Задача 2\", \"Описание задачи 2\"), \n            ##Task(3, \"Задача 3\", \"Описание задачи 3\") \n        ##) \n \n        ##%%// Обновляем LiveData%% \n        ##**_tasks**.value = sampleTasks \n \n        ##%%// Наблюдаем за изменениями LiveData%% \n        ##**tasks**.observe(this, { updatedTasks -> \n            ##%%// Обновление пользовательского интерфейса с новым списком задач%% \n            ##%%// updatedTasks содержит актуальные данные списка задач%% \n        ##}) \n    ##} \n##}',NULL,'Объяснение: \n_tasks и tasks - это переменные, используемые для работы с LiveData. \n \nprivate val _tasks = MutableLiveData<List<Task>>(): Здесь мы создаем экземпляр MutableLiveData с типом данных List<Task>. Префикс _ (например, _tasks) часто используется для обозначения приватных полей в Kotlin. MutableLiveData - это подкласс LiveData, который позволяет изменять данные. \n \nval tasks: LiveData<List<Task>> = _tasks: Это публичное поле tasks, которое возвращает экземпляр _tasks как LiveData. Оно предназначено для наблюдения извне, но не дает доступа к изменению данных. Такой подход делает данные доступными только для чтения извне класса. \n \nС помощью этой структуры, вы можете изменять данные в _tasks внутри вашего кода, и любой код, который наблюдает за tasks, будет автоматически оповещен об изменениях, не требуя явной ручной установки слушателей. Это основной механизм, который делает LiveData так удобным для работы с жизненным циклом компонентов Android и обновлением пользовательского интерфейса. \n \nЗаключение: \n \nLiveData предоставляет удобный способ для передачи и обновления данных в соответствии с жизненным циклом компонентов Android. \n Он помогает сделать код более структурированным и предотвращает множество распространенных ошибок, связанных с обновлением данных в пользовательском интерфейсе.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(57,3,15,56,75,57,19,'rus','2023-11-01',NULL,'=Использование Flow в Android с примерами=','Flow - это асинхронный поток данных в андроиде, представляющий последовательность значений, которые могут быть асинхронно произведены или потреблены. Flow разработан для замены RxJava и LiveData в асинхронных сценариях и может быть использован внутри ViewModel для обновления пользовательского интерфейса.\nПреимущества использования Flow\nКорутинами Flow интегрирован с корутинами и предоставляет более удобный способ работы с асинхронными операциями.\nАсинхронное программирование Flow предоставляет мощные операторы для манипулирования данными асинхронно.\nПоддержка отмены Flow автоматически отменяет выполнение, если необходимо.\nПример использования Flow\nПредставим, что у нас есть приложение для отображения списка задач.\n Мы будем использовать Flow для обновления списка задач в пользовательском интерфейсе.\nШаг 1 Добавление зависимостей\nДобавьте зависимость для архитектурных компонентов и Kotlin Coroutines в вашем файле build.gradle','##%%// build.gradle (Module app)%%##dependencies {\n    ##implementation androidx.lifecyclelifecycle-runtime2.3.1    ##implementation org.jetbrains.kotlinxkotlinx-coroutines-core1.5.0\n    ##implementation org.jetbrains.kotlinxkotlinx-coroutines-android1.5.0',NULL,'Шаг 2 Создание класса данных (Task)','##data class Task(val id Int, val title String, val description String)',NULL,'Шаг 3 Использование Flow в ViewModel\nСоздайте ViewModel, которая будет хранить список задач в виде Flow','##import androidx.lifecycle.ViewModel\n##import androidx.lifecycle.asLiveData\n##import kotlinx.coroutines.flow.flow\n##class TaskViewModel  ViewModel() {    ##val tasksFlow = flow {\n        ##%%// Загрузка данных (может быть из репозитория)%%        ##val sampleTasks = listOf(\n            ##Task(1, Задача 1, Описание задачи 1),            ##Task(2, Задача 2, Описание задачи 2),\n            ##Task(3, Задача 3, Описание задачи 3)        ##)\n        ##emit(sampleTasks)    ##}.asLiveData()\n##}',NULL,'Шаг 4 Использование Flow в Activity\nСоздайте Activity, которая будет наблюдать за изменениями списка задач и обновлять пользовательский интерфейс','##import android.os.Bundle##import androidx.appcompat.app.AppCompatActivity\n##import androidx.lifecycle.Observer##import androidx.lifecycle.ViewModelProvider\n##class TaskActivity  AppCompatActivity() {\n    ##private lateinit var taskViewModel TaskViewModel\n    ##override fun ^^onCreate^^(savedInstanceState Bundle) {\n        ##super.^^onCreate^^(savedInstanceState)        ##setContentView(R.layout.activity_task)\n        ##taskViewModel = ViewModelProvider(this).get(TaskViewModelclass.java)\n        ##taskViewModel.tasksFlow.observe(this, Observer { tasks -\n             ##%%//Обновление пользовательского интерфейса с новым списком задач%%            ##%%// tasks содержит актуальные данные списка задач%%\n        ##})    ##}\n##}',NULL,'Заключение\nFlow предоставляет эффективный способ для работы с асинхронными операциями и обновлением данных в андроид-приложениях. Он интегрирован с корутинами и предоставляет богатый набор операторов для управления данными. \nFlow может быть использован вместе с ViewModel для обновления пользовательского интерфейса в реактивном стиле.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(58,3,15,57,76,58,19,'rus','2023-11-01',NULL,'=сравнение Flow и LiveData=','Flow и LiveData - это оба инструмента Android для работы с реактивными потоками данных, но они имеют различия в функциональности, использовании и возможностях.\nLiveData\nЖизненный цикл LiveData интегрирован с жизненным циклом компонентов (Activity, Fragment), что позволяет автоматически управлять подписками и предотвращать утечки памяти.\nUI-ориентированный LiveData часто используется для обновления пользовательского интерфейса, так как он автоматически обновляет UI в соответствии с жизненным циклом активности или фрагмента.\nПростота использования LiveData предоставляет базовые возможности для обработки изменений данных. Он не имеет сложных операторов преобразования данных.\nТолько для чтения LiveData предназначен только для чтения данных, и его значения не могут быть напрямую изменены извне.\nFlow\nКорутины Flow интегрирован с Kotlin Coroutines и предоставляет более широкий спектр операторов для манипулирования данными.\nАсинхронность Flow предназначен для обработки асинхронных операций и позволяет выполнять сложные манипуляции с данными.\nГибкость Flow подходит для широкого спектра сценариев, от асинхронных операций до обработки потоковых данных.\nMutability Flow может быть как для чтения, так и для записи. Вы можете создавать собственные потоки данных и изменять их значения.\nОбработка ошибок Flow предоставляет операторы для обработки ошибок и исключений в асинхронных операциях.\nКакой выбрать\nИспользуйте LiveData, когда вам нужно автоматическое управление жизненным циклом для обновления UI в соответствии с жизненным циклом компонента.Используйте Flow, когда вам нужны более сложные манипуляции с данными, операции с Kotlin Coroutines, обработка ошибок и асинхронные сценарии.\nЛучший выбор зависит от ваших потребностей в конкретном проекте. Иногда также можно комбинировать оба инструмента в зависимости от задачи.Но на данный момент использование Flow часто является предпочтительным в современных андроид-приложениях',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(59,3,15,58,77,59,19,'rus','2023-11-01',NULL,'=Сравнение MVP, MVVM и MVI Когда использовать каждый паттерн=','MVP, MVVM и MVI - это три популярных архитектурных паттерна для разработки Android-приложений. Каждый из них имеет свои особенности и подходит для определенных сценариев. Давайте сравним эти паттерны и разберем, где их лучше использовать.\nMVP (Model-View-Presenter)\nОсобенности\nView передает пользовательские действия (намерения) Presenter, который обрабатывает их и обновляет View.Model содержит бизнес-логику и данные, но не знает о View или Presenter.\nПрименение\nMVP хорошо подходит для проектов с небольшой сложностью, когда необходимо быстро развернуть код.Отлично подходит, если приоритетом является тестирование бизнес-логики.\nMVVM (Model-View-ViewModel)\nОсобенности\nViewModel отвечает за предоставление данных и логику для отображения. Он не знает о View, но может обрабатывать пользовательские события.View подписывается на LiveData или Observable, поставляемые ViewModel, и автоматически обновляется при изменении данных.\nПрименение\nMVVM подходит для проектов с средней и высокой сложностью, где требуется более структурированный и поддерживаемый код.Используется, если важен отдельный контроль над состоянием интерфейса и реакция на изменения данных.\nMVI (Model-View-Intent)\nОсобенности\nViewIntent представляет намерение пользователя. Presenter (или ViewModel) обрабатывает намерение и возвращает новое состояние.Состояние передается во View, которая отображает его. View также может создавать намерения, начиная цикл снова.\nПрименение\nMVI рекомендуется для проектов с высокой сложностью, где важно более четкое определение действий пользователя и состояний приложения.Подходит, если требуется более предсказуемый и контролируемый способ обработки действий пользователя.\nКак выбрать паттерн\nЕсли проект небольшой и простой, MVP может быть хорошим выбором.Если важен более модульный и тестируемый код, MVVM может быть предпочтительным.\nЕсли проект сложный, требует строгой обработки пользовательских действий и контроля над состоянием, MVI может быть лучшим вариантом.Выбор паттерна также зависит от опыта команды разработчиков, особенностей проекта и предпочтений в разработке приложений.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(60,3,15,59,78,60,19,'rus','2023-11-01',NULL,'=Clean Architecture=','Clean Architecture - это подход к разработке программного обеспечения, который стремится создать приложение с высокой степенью изолированности и независимости между его компонентами. В этом уроке мы рассмотрим основные принципы и компоненты Clean Architecture на примере Android-приложения.\n\nОсновные принципы Clean Architecture\n\nНезависимость от фреймворков Внешние фреймворки, библиотеки и UI не должны влиять на внутренние компоненты приложения.\n\nРазделение на слои Приложение разделяется на различные слои, каждый из которых имеет свою ответственность.\n\nЗависимости наружу Внутренние компоненты не зависят от внешних. Зависимости направлены от внешних компонентов к внутренним.\n\nЧистота границ Граничные компоненты, отвечающие за взаимодействие с внешним миром (UI, база данных), должны быть максимально чистыми и минимизировать свою логику.\n\nКомпоненты Clean Architecture\n\nEntities (Сущности) Это объекты, которые представляют бизнес-логику приложения и не зависят от внешних компонентов.\n\nUse Cases (Использование случая) Представляют конкретные действия, которые могут быть выполнены в системе.\n\nInteractors (Интеракторы) Это бизнес-логика, которая связывает Use Cases и Entities. Они оркестрируют работу Use Cases.\n\nFrameworks & Drivers (Фреймворки и Драйверы) Внешние компоненты, такие как фреймворки, UI, базы данных.\n Зависят от внутренних компонентов.\n\nInterface Adapters (Адаптеры интерфейсов) Преобразуют данные из формата, удобного для использования внутри приложения, в формат, понятный для внешних компонентов.\n\nPresenters & Controllers (Презентеры и Контроллеры) Преобразуют данные из формата, удобного для использования в приложении, в формат, понятный для UI.\n\nПример Clean Architecture в Android-приложении','##%%// Entities%%\n##data class Task(val id: Int, val title: String, val description: String)\n\n##%%// Use Cases%%\n##interface TaskUseCase {\n    ##fun ^^getTasks^^(): List<Task>\n##}\n\n##%%// Interactors%%\n##class TaskInteractor : TaskUseCase {\n    ##override fun ^^getTasks^^(): List<Task> {\n        ##return listOf(\n            ##Task(1, \"Задача 1\", \"Описание задачи 1\"),\n            ##Task(2, \"Задача 2\", \"Описание задачи 2\"),\n            ##Task(3, \"Задача 3\", \"Описание задачи 3\")\n        ##)\n   ##}\n##}\n\n##%%// Frameworks & Drivers%%\n##class FakeTaskRepository : TaskRepository {\n    ##override fun ^^getTasks^^(): List<Task> {\n        ##return listOf(\n            ##Task(1, \"Задача 1\", \"Описание задачи 1\"),\n            ##Task(2, \"Задача 2\", \"Описание задачи 2\"),\n            ##Task(3, \"Задача 3\", \"Описание задачи 3\")\n        ##)\n    ##}\n##}\n\n##%%// Interface Adapters%%\n##class TaskPresenter(private val taskUseCase: TaskUseCase) {\n    ##fun ^^loadTasks^^(): List<Task> {\n        ##return taskUseCase.^^getTasks^^()\n    ##}\n##}',NULL,'2. Создание пользовательского интерфейса (XML-макет для списка задач):','##<!-- res/layout/activity_task.xml -->\n##<androidx.recyclerview.widget.RecyclerView\n    ##xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    ##android:id=\"@+id/taskRecyclerView\"\n    ##android:layout_width=\"match_parent\"\n    ##android:layout_height=\"match_parent\" />\n',NULL,'3. Реализация Activity и адаптера для RecyclerView:','##class TaskActivity : AppCompatActivity() {\n\n    ##private lateinit var taskViewModel: TaskViewModel\n    ##private lateinit var taskAdapter: TaskAdapter\n\n    ##override fun ^^onCreate^^(savedInstanceState: Bundle?) {\n        ##super.^^onCreate^^(savedInstanceState)\n        ##setContentView(R.layout.activity_task)\n        ##val taskInteractor = TaskInteractor()\n        ##taskViewModel = ViewModelProvider(this, TaskViewModelFactory(taskInteractor)).get(TaskViewModel::class.java)\n\n        ##val recyclerView: RecyclerView = findViewById(R.id.taskRecyclerView)\n        ##taskAdapter = TaskAdapter()\n        ##recyclerView.adapter = taskAdapter\n\n        ##val tasks = taskViewModel.^^getTasks^^()\n        ##taskAdapter.submitList(tasks)\n    ##}\n##}',NULL,'Создание адаптера:','##class TaskAdapter : ListAdapter<Task, TaskViewHolder>(TaskDiffCallback()) {\n    ##override fun ^^onCreateViewHolder^^(parent: ViewGroup, viewType: Int): TaskViewHolder {\n        ##val itemView = LayoutInflater.from(parent.context).inflate(R.layout.item_task, parent, false)\n        ##return TaskViewHolder(itemView)\n    ##}\n\n    ##override fun ^^onBindViewHolder^^(holder: TaskViewHolder, position: Int) {\n        ##val task = getItem(position)\n        ##holder.bind(task)\n    ##}\n##}\n\n##class TaskViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {\n    ##fun ^^bind^^(task: Task) {\n        ##itemView.titleTextView.text = task.title\n        ##itemView.descriptionTextView.text = task.description\n    ##}\n##}\n\n##class TaskDiffCallback : DiffUtil.ItemCallback<Task>() {\n    ##override fun ^^areItemsTheSame^^(oldItem: Task, newItem: Task): Boolean {\n        ##return oldItem.id == newItem.id\n    ##}\n\n    ##override fun ^^areContentsTheSame^^(oldItem: Task, newItem: Task): Boolean {\n        ##return oldItem == newItem\n    ##}\n##}',NULL,'4. Создание ViewModel:','##class TaskViewModel(private val taskInteractor: TaskInteractor) : ViewModel() {\n\n    ##fun ^^getTasks^^(): List<Task> {\n        ##return taskInteractor.^^getTasks^^()\n    ##}\n##}\n\n##class TaskViewModelFactory(private val taskInteractor: TaskInteractor) : ViewModelProvider.Factory {\n    ##override fun <T : ViewModel?> create(modelClass: Class<T>): T {\n        ##if (modelClass.isAssignableFrom(TaskViewModel::class.java)) {\n            ##return TaskViewModel(taskInteractor) as T\n        ##}\n        ##throw IllegalArgumentException(\"Unknown ViewModel class\")\n    ##}\n##}',NULL,'Примечание:\nTaskViewModelFactory используется для создания экземпляра TaskViewModel с передачей зависимости TaskInteractor.\n\nКогда мы создаем ViewModel с помощью ViewModelProvider, система обычно использует конструктор ViewModel без аргументов. Однако, в некоторых случаях, нам может потребоваться передать зависимости в конструктор ViewModel.\n\nTaskViewModelFactory позволяет нам внедрить зависимость TaskInteractor в конструктор TaskViewModel. Когда система запрашивает создание экземпляра TaskViewModel, она будет использовать TaskViewModelFactory, который, в свою очередь, будет создавать TaskViewModel с передачей необходимой зависимости.\n\nИспользование фабрики (ViewModelFactory) полезно, если ViewModel требует какие-либо внешние зависимости, такие как интеракторы, репозитории и т.д. Это позволяет нам управлять инъекцией зависимостей внутри ViewModel и соблюдать принципы чистой архитектуры.\n\nЗаключение\n\nClean Architecture позволяет создавать модульные, тестируемые и независимые компоненты в приложении.\n Каждый слой имеет свою ответственность и зависимости направлены от внешних компонентов к внутренним.\n Этот подход помогает создавать более чистый и структурированный код, упрощает тестирование и поддержку приложения.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(61,3,16,60,79,61,20,'rus','2023-11-01',NULL,'=Асинхронное программирование=','В этом уроке мы рассмотрим концепцию асинхронного программирования, которая позволяет эффективно управлять задачами, выполняя их параллельно или в фоновом режиме.\n Асинхронное программирование особенно полезно для работы с IO-операциями, сетевыми запросами и другими задачами, которые могут блокировать выполнение кода.\n\n=Проблема блокировки=\n\nВ синхронном программировании при выполнении операции код блокируется до завершения операции.\n Это может привести к затратам времени и плохой производительности, особенно в случае долгих IO-операций.\n\nПример блокирующей операции','##fun ^^main^^() {\n    ##println(\"Start\")\n    ##Thread.sleep(2000) // Блокирование на 2 секунды\n    ##println(\"End\")\n##}',NULL,'=Асинхронное =программирование с Callbacks\n\nАсинхронное программирование можно реализовать с использованием колбэков (callbacks), которые выполняются после завершения асинхронной операции.\n\nПример асинхронного программирования с колбэками','##fun ^^fetchData^^(callback: (String) -> Unit) {\n    ##// Эмуляция задержки при получении данных\n    ##Thread.sleep(1000)\n    ##val data = \"Async Data\"\n    ##callback(data)\n##}\n\n##fun ^^main^^() {\n    ##println(\"Start\")\n    ##^^fetchData^^ { result ->\n        ##println(\"Received $result\")\n    ##}\n    ##println(\"End\")\n##}',NULL,'=Асинхронное программирование с Kotlin Coroutines=\n\nKotlin Coroutines предоставляют более эффективный и понятный способ асинхронного программирования. \nОни позволяют писать код, который выглядит как синхронный, но выполняется асинхронно.\n\n=Пример асинхронного программирования с Kotlin Coroutines=','##import kotlinx.coroutines.*\n\n##suspend fun ^^fetchData^^(): String {\n    ##delay(1000) // Эмуляция задержки при получении данных\n    ##return \"Async Data\"\n##}\n\n##fun ^^main^^() = runBlocking {\n    ##println(\"Start\")\n    ##val result = async { ^^fetchData^^() }\n    ##println(\"End\")\n    ##println(\"Received ${result.await()}\")\n##}',NULL,'=Заключение=\n\nАсинхронное программирование является важным подходом для создания отзывчивых и эффективных приложений. \nОно позволяет эффективно управлять задачами, которые занимают много времени, такими как IO-операции и сетевые запросы. \nВыбор между колбэками и Kotlin Coroutines зависит от предпочтений разработчика и конкретных требований проекта.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(62,3,16,61,80,62,20,'rus','2023-11-01',NULL,'=Асинхронные паттерны=','В этом уроке мы рассмотрим несколько асинхронных паттернов, которые помогают эффективно организовать асинхронное программирование и управление задачами.\n\n=Callbacks=\n\nCallbacks - это один из базовых асинхронных паттернов. Он представляет собой передачу функции (колбэка) в качестве параметра другой функции. Колбэк будет вызван после завершения асинхронной операции.\n\n=Пример использования паттерна Callbacks:=','##fun ^^fetchData^^(callback: (String) -> Unit) {\n    ##%%// Эмуляция задержки при получении данных%%\n    ##Thread.sleep(1000)\n    ##val data = \"Async Data\"\n    ##callback(data)\n##}\n\n##fun ^^main^^() {\n    ##println(\"Start\")\n    ##fetchData { result ->\n        ##println(\"Received $result\")\n    ##}\n    ##println(\"End\") \n##}',NULL,'Часть 2 PromisesFutures\n\nPromises (или Futures) - это паттерн, который представляет собой объект, предоставляющий обещание о завершении асинхронной операции. Пользователь может добавить колбэки для обработки успешного завершения или ошибки.\n\n=Пример использования паттернаPromisesFutures с помощью библиотеки kotlinx.coroutines:=\n','##import kotlinx.coroutines.*\n##import java.util.concurrent.CompletableFuture\n\n##fun ^^fetchDataAsync^^(): CompletableFuture<String> {\n    ##val future = CompletableFuture<String>()\n    ##GlobalScope.launch {\n        ##delay(1000)\n        ##val data = \"Async Data\"\n        ##future.complete(data)\n    ##}\n    ##return future\n##}\n\n##fun ^^main^^() = runBlocking {\n    ##println(\"Start\")\n    ##val future = ^^fetchDataAsync^^()\n    ##println(\"End\")\n    ##val result = future.await()\n    ##println(\"Received: $result\")\n##}',NULL,'Часть 3 ObservablesReactive Programming\n\nObservables - это паттерн из реактивного программирования, который позволяет создавать и обрабатывать потоки данных. Он предоставляет механизм для реакции на изменения данных и событий.\n\n=Пример использования паттерна Observables с помощью библиотеки RxJava:=','##import io.reactivex.Observable\n\n##fun ^^fetchDataObservable^^(): Observable<String> {\n    ##return Observable.create<String> { emitter ->\n        ##Thread.sleep(1000)\n        ##val data = \"Async Data\"\n        ##emitter.onNext(data)\n        ##emitter.onComplete()\n    ##}\n##}\n\n##fun ^^main^^() {\n    ##println(\"Start\")\n    ##val observable = fetchDataObservable()\n    ##observable.subscribe(\n        ##{ result -> println(\"Received: $result\") },\n        ##{ error -> println(\"Error: $error\") },\n        ##{ println(\"Completed\") }\n    ##)\n    ##println(\"End\")\n##}',NULL,'=Заключение=\n\nАсинхронные паттерны предоставляют эффективные инструменты для организации асинхронного программирования и управления асинхронными задачами. Каждый паттерн имеет свои преимущества и подходит для разных сценариев. Выбор паттерна зависит от требований проекта и предпочтений разработчика.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(63,3,16,62,81,63,20,'rus','2023-11-01',NULL,'=Антипаттерны=','Антипаттерны - это практики, которые могут привести к плохому качеству кода, сложности и другим негативным последствиям. Вот некоторые из них\n\n=1. Copy-Paste Programming =(Программирование копированием и вставкой)\nЭто когда разработчики копируют и вставляют существующий код вместо создания переиспользуемых компонентов. Это приводит к дублированию кода, трудностям в поддержке и увеличению вероятности ошибок.\n\n=2. God Object (Божественный объект)=\nЭто объект, который содержит слишком много функциональности и нарушает принцип единственной ответственности. Это делает код менее модульным, трудным для тестирования и поддержки.\n\n=3. Spaghetti Code (Спагетти-код)=\nСпагетти-код - это путаница из некоординированных и запутанных фрагментов кода. Это затрудняет понимание кода и вносит трудности при изменениях.\n\n=4. Magic Numbers (Магические числа)=\nИспользование хардкодированных чисел в коде вместо использования именованных констант делает код менее читаемым и подверженным ошибкам.\n\n=5. Shotgun Surgery (Стрельба из ружья)=\nКогда изменения в одной части кода требуют множественных изменений в других местах, это может привести к хрупкости кода и сложностям в поддержке.\n\n=6. Golden Hammer (Золотой молоток)=\nИспользование одного и того же инструмента или подхода для всех задач, даже если он не всегда подходит, может привести к ненужным сложностям и ограничениям.\n\n=7. Cargo Cult Programming =(Программирование по образцу)\nЭто когда разработчики копируют код или практики без полного понимания, как они работают, надеясь на магический результат.\n\n=8. Not Invented Here (Не изобретено здесь)=\nОтказ от использования сторонних библиотек или решений в пользу написания своих, что может привести к избыточной сложности и потере времени.\n\n=9. Overengineering (Переинжиниринг)=\nСоздание избыточно сложных решений для задач, которые могли бы быть решены более просто.\n=10. Dead Code (Мёртвый код)=\nНеиспользуемый код в проекте, который только добавляет сложности и ухудшает поддержку.\n\nЭто лишь несколько примеров антипаттернов. Важно избегать их, чтобы создавать качественный, понятный и поддерживаемый код.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(64,3,16,63,82,64,20,'rus','2023-11-01',NULL,'=Основы Многопоточности=','В этом уроке мы рассмотрим основы многопоточности. \nМногопоточность позволяет выполнять несколько задач одновременно в рамках одного приложения.\n Мы будем использовать концепции из стандартной библиотеки Kotlin и Kotlin Coroutines.\n\n=Потоки=\nПотоки - это независимые пути выполнения внутри процесса. \nОни позволяют выполнить несколько задач одновременно.\n Каждое приложение имеет как минимум один основной поток, называемый \"главным\" потоком (Main Thread).\n\n=Создание и работа с потоками=\n\nПотоки представляют собой независимые пути выполнения внутри приложения.\n Kotlin предоставляет простой способ создания потоков с помощью функции thread.\n\nПример создания и использования потока:\n','##import kotlin.concurrent.thread\n\n##fun ^^main^^() {\n    ##val thread = thread {\n        ##println(\"Hello from thread!\")\n    ##}\n\n    ##thread.join() %%// Ожидание завершения потока%%\n\n    ##println(\"Main thread continues...\")\n##}',NULL,'=2. Работа с разделяемыми ресурсами и блокировками=\n\nПри работе с многопоточностью возникает проблема с разделяемыми ресурсами, такими как переменные.\n Если не синхронизировать доступ к разделяемым ресурсам, может возникнуть состояние гонки и непредсказуемые результаты.\n\n=Состояние гонки (Race Condition):=\n\nСостояние гонки - это ситуация в многопоточной программе, когда поведение программы зависит от того, в каком порядке выполняются операции в разных потоках. \nСостояние гонки возникает, когда несколько потоков одновременно пытаются обращаться к разделяемому ресурсу (переменной, файлу, памяти) без должной синхронизации.\n\n=Пример состояния гонки:=','##var counter = 0\n\n##fun ^^main^^() {\n    ##val thread1 = thread {\n        ##for (i in 1..1000) {\n            ##counter++\n        ##}\n    ##}\n\n    ##val thread2 = thread {\n        ##for (i in 1..1000) {\n            ##counter++\n        ##}\n    ##}\n\n    ##thread1.join()\n    ##thread2.join()\n\n    ##println(\"Counter value: $counter\") %%// Результат может быть неожиданным%%\n##}',NULL,'В данном примере два потока пытаются инкрементировать переменную counter на 1000. Однако из-за отсутствия синхронизации между потоками, возникает состояние гонки. Результат работы программы может быть различным при каждом запуске, и он может быть даже меньше 2000 (что ожидалось).\n\nЧтобы избежать состояния гонки, необходимо использовать механизмы синхронизации, такие как блокировки (synchronized), мьютексы, атомарные операции и другие. Эти механизмы обеспечивают правильную синхронизацию доступа к разделяемым ресурсам и предотвращают состояние гонки.\n\nИспользование корутин в Kotlin также способствует избежанию состояния гонки, так как корутины обеспечивают безопасное выполнение операций в рамках одной корутины, избегая проблем с синхронизацией.\nПример работы с разделяемым счетчиком и блокировкой:','##import kotlin.concurrent.thread\n\n##fun ^^main^^() {\n    ##val counter = Counter()\n\n    ##val thread1 = thread {\n        ##for (i in 1..5) {\n            ##counter.increment()\n            ##println(\"Thread 1: ${counter.getCount()}\")\n        ##}\n    ##}\n\n    ##val thread2 = thread {\n        ##for (i in 1..5) {\n            ##counter.increment()\n            ##println(\"Thread 2: ${counter.getCount()}\")\n        ##}\n    ##}\n\n    ##thread1.join()\n    ##thread2.join()\n\n    ##println(\"Final count: ${counter.getCount()}\")\n##}\n\n##class Counter {\n    ##private var count = 0\n\n    ##@Synchronized %%// Блокирует доступ к методу для одного потока%%\n    ##fun ^^increment^^() {\n        ##count++\n    ##}\n    ##fun ^^getCount^^(): Int {\n        ##return count\n    ##}\n##}',NULL,'=Часть 2: Kotlin Coroutines=\n\n1. Создание и запуск корутин\n\nКорутины представляют более легковесный и гибкий подход к многопоточности.\n Они позволяют асинхронно выполнять задачи и управлять потоками.\n Для работы с корутинами используется библиотека kotlinx.coroutines.\n\n=Пример создания и использования корутины:=\n','##import kotlinx.coroutines.*\n\n##fun ^^main^^() = runBlocking {\n    ##%%// Создание корутины с помощью функции launch%%\n    ##val job = launch {\n        ##delay(1000) %%// Приостановка корутины на 1 секунду%%\n        ##println(\"Coroutine is done!\")\n    ##}\n\n    ##println(\"Coroutine is working...\")\n    ##job.join() %%// Ожидание завершения корутины%%\n    ##println(\"Coroutine has finished.\")\n##}',NULL,'=2. Параллельное выполнение корутин=\n\nКорутины позволяют легко создавать и параллельно выполнять несколько задач.\n\n=Пример параллельного выполнения корутин:=','##import kotlinx.coroutines.*\n\n##fun ^^main^^() = runBlocking {\n    ##%%// Запуск двух корутин для параллельного выполнения%%\n    ##val job1 = launch {\n        ##repeat(5) {\n            ##delay(200) %%// Приостановка корутины на 200 миллисекунд%%\n            ##println(\"Coroutine 1: $it\")\n        ##}\n    ##}\n\n    ##val job2 = launch {\n        ##repeat(5) {\n            ##delay(300) %%// Приостановка корутины на 300 миллисекунд%%\n            ##println(\"Coroutine 2: $it\")\n        ##}\n    ##}\n\n    ##job1.join() %%// Ожидание завершения первой корутины%%\n    ##job2.join() %%// Ожидание завершения второй корутины%%\n##}',NULL,'=3. Асинхронные операции с async=\n\nФункция async позволяет запустить корутину, которая возвращает результат.\n\n=Пример использования async для выполнения асинхронных операций:=','##import kotlinx.coroutines.*\n\n##fun ^^main^^() = runBlocking {\n    ##%%// Создание асинхронных операций с помощью функции async%%\n    ##val result1 = async {\n        ##delay(1000) %%// Приостановка корутины на 1 секунду%%\n        ##\"Result 1\"\n    ##}\n\n    ##val result2 = async {\n        ##delay(1500) // Приостановка корутины на 1.5 секунды\n        ##\"Result 2\"\n    ##}\n\n    ##println(\"Waiting for results...\")\n    ##println(\"Result 1: ${result1.await()}\") %%// Ожидание и получение результата%%\n    ##println(\"Result 2: ${result2.await()}\") %%// Ожидание и получение результата%%\n##}',NULL,'4. Использование корутин для многопоточности\n\nКорутины также упрощают многопоточность и работу с разделяемыми ресурсами.\n\nПример использования корутин для многопоточности:','##import kotlinx.coroutines.*\n\n##fun ^^main^^() = runBlocking {\n    ##val counter = Counter()\n\n    ##val job1 = launch {\n        ##repeat(5) {\n            ##delay(200)\n            ##counter.^^increment^^() %%// Асинхронное инкрементирование счетчика%%\n            ##println(\"Coroutine 1: ${counter.getCount()}\")\n        ##}\n    ##}\n\n    ##val job2 = launch {\n        ##repeat(5) {\n            ##delay(300)\n            ##counter.^^increment^^() %%// Асинхронное инкрементирование счетчика%%\n            ##println(\"Coroutine 2: ${counter.getCount()}\")\n        ##}\n    ##}\n\n    ##job1.join() %%// Ожидание завершения первой корутины%%\n    ##job2.join() %%// Ожидание завершения второй корутины%%\n\n    ##println(\"Final count: ${counter.getCount()}\")\n##}\n\n##class Counter {\n    ##private var count = 0\n\n    ##suspend fun ^^increment^^() = coroutineScope {\n        ##delay(100) %%// Приостановка корутины на 100 миллисекунд%%\n        ##count++\n    ##}\n\n    ##fun ^^getCount^^(): Int {\n        ##return count\n    ##}\n##}',NULL,'=Общие замечания:=\n\nКорутины предоставляют более удобный способ работы с многопоточностью в сравнении с низкоуровневыми потоками.\n\nKotlin Coroutines позволяют асинхронно выполнять задачи без явного использования блокировок и синхронизации.\n\nВместо блокировок и мьютексов Kotlin Coroutines предлагает структурированные конструкции, такие как launch, async и coroutineScope.\n\nКорутины позволяют написать более чистый и читаемый код для многопоточных операций.',NULL,NULL,NULL,NULL,NULL,NULL,NULL),(65,3,16,64,83,65,20,'rus','2023-11-01',NULL,'=Многозадачность (Multitasking)=','\nВ этом уроке мы рассмотрим концепцию многозадачности, которая позволяет выполнять несколько задач в одно и то же время.\n Многозадачность может быть реализована на уровне операционной системы с использованием потоков и процессов.\n\n=Типы многозадачности=\n\n1. Многозадачность на уровне процессора (Single-core Multitasking)\n\nЭтот тип многозадачности использует один физический процессор для выполнения нескольких задач. Процессор переключается между задачами достаточно быстро, чтобы создать иллюзию параллельного выполнения.\n\n2. Многозадачность на уровне процессоров (Multi-core Multitasking)\n\nСовременные процессоры часто имеют несколько ядер, что позволяет параллельно выполнять несколько задач на разных ядрах.\n\n3. Многозадачность на уровне операционной системы\n\nОперационные системы управляют выполнением задач, планируя их выполнение в рамках процессов и потоков. Каждый процесс имеет свою собственную область памяти, а каждый поток выполняется в рамках процесса.\n\n=Типы многозадачности в Kotlin=\n\n1. Потоки (Threads)\n\nПотоки позволяют выполнять несколько задач в одном процессе. Операционная система переключает выполнение потоков, чтобы создать иллюзию параллельного выполнения.\n\n2. Корутины (Coroutines)\n\nКорутины - это легковесные исключения, которые позволяют выполнять задачи асинхронно, избегая блокировок и обеспечивая более чистый код.\n\n3. Процессы\n\nПроцессы - это изолированные области выполнения, имеющие свои собственные ресурсы и память. Процессы могут выполняться параллельно и независимо друг от друга.\n\n=Примеры использования=\n\n1. Параллельное выполнение задач','##import kotlin.concurrent.thread\n\n##fun ^^main^^() {\n    ##val thread1 = thread {\n        ##println(\"Task 1 is running.\")\n    ##}\n\n    ##val thread2 = thread {\n        ##println(\"Task 2 is running.\")\n    ##}\n\n    ##thread1.join()\n    ##thread2.join()\n\n    ##println(\"All tasks are done.\")\n##}',NULL,'2. Асинхронные операции с корутинами','##import kotlinx.coroutines.*\n\n##fun ^^main^^() = runBlocking {\n    ##val job1 = launch {\n        ##delay(1000)\n        ##println(\"Task 1 is done.\")\n    ##}\n\n    ##val job2 = launch {\n        ##delay(1500)\n        ##println(\"Task 2 is done.\")\n    ##}\n\n    ##job1.join()\n    ##job2.join()\n\n    ##println(\"All tasks are completed.\")\n##}',NULL,'3. Параллельное выполнение процессов\n\nПримеры использования процессов требуют более сложной организации и зависят от операционной системы, на которой выполняется код.\n\n=Заключение=\n\nМногозадачность является важной концепцией в современных операционных системах и языках программирования.\n Она позволяет эффективно использовать ресурсы компьютера и создавать более отзывчивые и производительные приложения. В\nажно выбирать подходящие инструменты многозадачности в зависимости от конкретных требований приложения.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(66,3,16,65,84,66,20,'rus','2023-11-01',NULL,'=Пулы потоков и Задачи=','В этом уроке мы рассмотрим понятие пулов потоков и задач, которые предоставляют эффективный способ управления множеством задач в многозадачной среде.\n\n=Понятие Пулов потоков=\n\nПул потоков - это набор заранее созданных потоков, которые могут выполнять задачи из пула.\n Пул потоков управляет созданием и переиспользованием потоков, что может уменьшить накладные расходы при создании и завершении потоков.\n\n=Пример использования пула потоков:=','##import java.util.concurrent.Executors\n\n##fun ^^main^^() {\n    ##val pool = Executors.newFixedThreadPool(4) %%// Создание пула из 4 потоков%%\n\n    ##for (i in 1..10) {\n        ##pool.submit {\n            ##println(\"Task $i is running on ${Thread.currentThread().name}\")\n        ##}\n    ##}\n\n    ##pool.shutdown() %%// Завершение пула потоков после завершения всех задач%%\n##}',NULL,'=Понятие Задач=\n\nЗадача - это абстракция, которая представляет собой единицу работы, которую нужно выполнить.\n Задачи могут быть отправлены на выполнение в пул потоков или другие механизмы выполнения.\n\n=Пример использования задач:=','##import java.util.concurrent.Callable\n##import java.util.concurrent.Executors\n##import java.util.concurrent.Future\n\n##fun ^^main^^() {\n    ##val pool = Executors.newFixedThreadPool(4) %%// Создание пула из 4 потоков%%\n\n    ##val futureResults = List(10) {\n        ##pool.submit(Callable {\n            ##\"Result from task ${it + 1}\"\n        ##})\n    ##}\n\n    pool.shutdown() %%// Завершение пула потоков после завершения всех задач%%\n\n    ##futureResults.forEachIndexed { index, future ->\n        ##val result = future.get() %%// Получение результата задачи%%\n        ##println(\"Task $index: $result\")\n    ##}\n##}',NULL,'=Преимущества Пулов потоков и Задач=\n\nЭффективное управление ресурсами Пулы потоков позволяют переиспользовать потоки, что уменьшает накладные расходы при создании и завершении потоков.\n\nУправление задачами Задачи позволяют абстрагироваться от непосредственного управления потоками и предоставляют удобный способ описания работы.\n\nКонтроль нагрузки Пулы потоков позволяют контролировать количество параллельно выполняющихся задач и ограничивать нагрузку на ресурсы.\n\n=Заключение=\n\nПулы потоков и задачи предоставляют мощные инструменты для эффективной организации и управления выполнением задач в многозадачной среде.\n Они помогают управлять ресурсами, оптимизировать нагрузку и улучшать производительность приложений.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(67,3,16,66,85,67,20,'rus','2023-11-01',NULL,'=Параллелизм и Конкурентность=','В этом уроке мы разберем концепции параллелизма и конкурентности, которые связаны с одновременным выполнением задач в многозадачной среде.\n\n=Параллелизм=\n\nПараллелизм - это концепция, при которой задачи выполняются одновременно, с использованием физических параллельных ресурсов, таких как многопроцессорные системы.\n\n=Пример параллелизма:=','##import kotlin.concurrent.thread\n\n##fun ^^main^^() {\n    ##val thread1 = thread {\n        ##println(\"Task 1 is running.\")\n    ##}\n\n    ##val thread2 = thread {\n        ##println(\"Task 2 is running.\")\n    ##}\n\n    ##thread1.join()\n    ##thread2.join()\n\n    ##println(\"All tasks are done.\")\n##}',NULL,'=Конкурентность=\n\nКонкурентность - это концепция, когда задачи могут быть выполняемыми одновременно, но на разных временных интервалах.\n Задачи переключаются в процессе выполнения, создавая иллюзию параллельности, даже если физические ресурсы ограничены.\n\n=Пример конкурентности:=','##import kotlinx.coroutines.*\n##import java.util.concurrent.atomic.AtomicInteger\n\n##fun ^^main^^() = runBlocking {\n    ##val counter = AtomicInteger(0)\n\n    ##val job1 = launch {\n        ##repeat(1000) {\n            ##counter.incrementAndGet()\n        ##}\n    ##}\n\n    ##val job2 = launch {\n        ##repeat(1000) {\n            ##counter.incrementAndGet()\n        ##}\n    ##}\n\n    ##job1.join()\n    ##job2.join()\n\n    ##println(\"Final count ${counter.get()}\")\n##}',NULL,'=Разница между Параллелизмом и Конкурентностью=\n\nПараллелизм означает, что задачи выполняются одновременно, используя физические параллельные ресурсы.\n\nКонкурентность означает, что задачи выполняются одновременно, но могут переключаться между собой на разных временных интервалах.\n\n=Заключение=\n\nПараллелизм и конкурентность являются важными концепциями в многозадачных средах.\n Параллелизм эффективно использует физические ресурсы для одновременного выполнения задач. Конкурентность позволяет создать иллюзию параллельности даже при ограниченных ресурсах.\n Правильное использование этих концепций зависит от требований приложения и доступных ресурсов.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(68,3,16,67,86,68,20,'rus','2023-11-01',NULL,'=Использование Coroutines в ViewModel=','=Введение=\nViewModel - это архитектурный компонент в библиотеке Android Jetpack, предназначенный для хранения и управления данными, связанными с пользовательским интерфейсом.\n Использование Kotlin Coroutines в ViewModel может сделать работу с асинхронными операциями более простой и читаемой.\n\n=Зачем использовать Coroutines в ViewModel?=\nАсинхронные операции Coroutines позволяют выполнять асинхронные операции, такие как загрузка данных с сервера или базы данных, без создания сложной структуры управления потоками.\n\nЧитаемый код Использование Coroutines упрощает синтаксис и сделает код более читаемым, устраняя необходимость вложенных колбэков.\n\nИзбегание утечек Coroutines автоматически управляют жизненным циклом, что может помочь избежать утечек памяти.\n\n=Пример Загрузка данных с использованием Coroutines в ViewModel=\nДопустим, у вас есть ViewModel, который должен загрузить список пользователей с сервера.\n Вам потребуется зависимость Retrofit для работы с сетью.\n\n=Добавьте зависимость на Retrofit и Coroutines в файл build.gradle=','##dependencies {\n    ##implementation \"org.jetbrains.kotlinx:kotlinx-coroutines-android:1.5.2\"\n    ##implementation \"com.squareup.retrofit2:retrofit:2.9.0\"\n    ##implementation \"com.squareup.retrofit2:converter-gson:2.9.0\"\n##}',NULL,'Создайте Retrofit сервис для работы с сервером','##interface UserService {\n    ##@GET(\"/users\")\n    ##suspend fun getUsers(): List<User>\n##}',NULL,'Создайте ViewModel для работы с данными','##class UserViewModel : ViewModel() {\n\n    ##private val userService: UserService = RetrofitClient.createService(UserService::class.java)\n\n    ##private val _users = MutableLiveData<List<User>>()\n    ##val users: LiveData<List<User>> = _users\n\n     ##val error = MutableLiveData<String>()\n\n    ##fun ^^fetchUsers^^() {\n        ##viewModelScope.launch {\n            ##try {\n                ##val response = userService.getUsers()\n                ##_users.value = response\n            ##} catch (e: Exception) {\n                ##error.value = \"Ошибка при загрузке пользователей: ${e.message}\"\n            ##}\n        ##}\n    ##}\n##}',NULL,'Используйте ViewModel в вашей активности или фрагменте','##class UserActivity : AppCompatActivity() {\n\n    ##private val userViewModel: UserViewModel by viewModels()\n\n   ##override fun ^^onCreate^^(savedInstanceState: Bundle?) {\n        ##super.^^onCreate^^(savedInstanceState)\n        ##setContentView(R.layout.activity_user)\n\n        ##userViewModel.users.observe(this, Observer { users ->\n            ##%%// Обновление пользовательского интерфейса с данными%%\n        ##})\n\n        ##userViewModel.error.observe(this, Observer { errorMessage ->\n            ##%%// Показать ошибку пользователю%%\n            ##Toast.makeText(this, errorMessage, Toast.LENGTH_SHORT).show()\n        ##})\n\n        ##userViewModel.^^fetchUsers^^()\n    ##}\n##}',NULL,'=Заключение=\nИспользование Kotlin Coroutines в ViewModel делает асинхронное программирование более простым и понятным. \nОн позволяет избегать колбэков и ненадежных подходов для управления потоками.\n В результате, вы получите чистый и поддерживаемый код для вашего Android-приложения.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(69,3,17,68,87,69,21,'rus','2023-11-01',NULL,'Введение в Koin (Kotlin Dependency Injection)','=Введение в Koin (Kotlin Dependency Injection)=\n=Что такое Dependency Injection (DI)=\nDependency Injection (DI) - это практика, когда объекты предоставляются в другие объекты, чтобы они могли использовать их функциональность. Это способствует уменьшению связности компонентов и облегчает тестирование и поддержку кода.\n\n=Что такое Koin=\nKoin - это легкая библиотека для Dependency Injection (DI) в Kotlin-приложениях. Она предоставляет удобный способ внедрения зависимостей без необходимости написания сложного и многословного кода.\n\n=Преимущества использования Koin:=\n1.Легкость использования Koin предоставляет простой и дружелюбный API, который легко освоить.\n\n2.Минимум бойлерплейта Отсутствие необходимости в аннотациях и сложных конфигурациях делает код более чистым и понятным.\n\n3.Ленивая инициализация Зависимости инициализируются только в момент их первого использования.\n\n4.Поддержка Android и не только Koin поддерживает как Android-приложения, так и обычные Kotlin-проекты.\n\n=Пример простого использования Koin=\nДобавьте зависимость на Koin в файл build.gradle:','dependencies {\n    implementation \"io.insert-koin:koin-core:3.1.2\"\n}',NULL,'=Создайте файл для определения модуля зависимостей, например AppModule.kt:=\n','import org.koin.dsl.module\n\n##val appModule = module {\n    ##single { UserRepository() }\n    ##single { UserService(get()) }\n    ##viewModel { UserViewModel(get()) }\n##}',NULL,'=Настройте Koin в приложении:=','##class MyApp : Application() {\n\n    ##override fun ^^onCreate^^() {\n        ##super.^^onCreate^^()\n\n        ##startKoin {\n            ##androidContext(this@MyApp)\n            ##modules(appModule)\n        ##}\n    ##}\n##}',NULL,'=Используйте зависимости в своем коде:=\n','##class UserViewModel(private val userService: UserService) : ViewModel() {\n\n    ##private val **_users** = MutableLiveData<List<User>>()\n    ##val **users**: LiveData<List<User>> = _users\n\n    ##private val **_error** = MutableLiveData<String>()\n    ##val **error**: LiveData<String> = _error\n\n    ##fun ^^fetchUsers^^() {\n        ##viewModelScope.launch {\n            ##try {\n                ##val **response** = userService.getUsers()\n                ##_users.value = response\n            ##} catch (e: Exception) {\n                ##_error.value = \"Ошибка при загрузке пользователей: ${e.message}\"\n            ##}\n        ##}\n    ##}\n##}',NULL,'=Сравнение c koin и без :=\nUserActivity без использования Koin:','##class UserActivity : AppCompatActivity() {\n\n    ##private lateinit var **userViewModel**: UserViewModel\n\n    ##override fun ^^onCreate^^(savedInstanceState: Bundle?) {\n        ##super.^^onCreate^^(savedInstanceState)\n        ##setContentView(R.layout.activity_user)\n\n        ##val **userService** = UserService() %%// Создание зависимости UserService%%\n        ##userViewModel = UserViewModel(**userService**) %%// Создание UserViewModel с передачей зависимости%%\n\n        ##userViewModel.users.observe(this, Observer { users ->\n            ##%%// Обновление пользовательского интерфейса с данными%%\n        ##})\n\n        ##userViewModel.error.observe(this, Observer { errorMessage ->\n            ##%%// Показать ошибку пользователю%%\n            ##Toast.makeText(this, errorMessage, Toast.LENGTH_SHORT).show()\n        ##})\n\n        ##userViewModel.^^fetchUsers^^()\n    ##}\n##}',NULL,'=UserActivity с использованием Koin:=','##class UserActivity : AppCompatActivity() {\n\n    ##private val **userViewModel**: UserViewModel by viewModels()\n\n    ##override fun ^^onCreate^^(savedInstanceState: Bundle?) {\n        ##super.^^onCreate^^(savedInstanceState)\n        ##setContentView(R.layout.activity_user)\n\n        ##**userViewModel**.users.observe(this, Observer { users ->\n            ##%%// Обновление пользовательского интерфейса с данными%%\n        ##})\n\n        ##**userViewModel**.error.observe(this, Observer { errorMessage ->\n            ##%%// Показать ошибку пользователю%%\n            ##Toast.makeText(this, errorMessage, Toast.LENGTH_SHORT).show()\n        ##})\n\n        ##**userViewModel**.^^fetchUsers^^()\n    ##}\n##}',NULL,'=Без Koin:=\n Вам нужно явно создать экземпляр UserService и передать его в конструктор UserViewModel в UserActivity.\n Это может потребовать изменений в UserActivity, если в будущем изменится способ создания или управления зависимостью.\n\n=С Koin:=\n Вы используете viewModels() для автоматической инъекции UserViewModel с уже созданной зависимостью userService.\n Это делает код активности более компактным и упрощает внедрение зависимостей.\n\n\n=Заключение=\nВведение в Koin позволит вам начать использовать Dependency Injection в ваших Kotlin-приложениях с минимальными усилиями.\n Благодаря легкому синтаксису и удобным функциям, Koin может упростить управление зависимостями и сделать ваш код более читаемым и тестируемым.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(70,3,17,69,88,70,21,'rus','2023-11-01',NULL,'Фабрики и Ленивая Инициализация в Koin','В Koin вы можете использовать фабрики для создания новых экземпляров зависимостей каждый раз, когда они запрошены, и ленивую инициализацию, чтобы создавать объекты только при их первом использовании. \nВ этом уроке мы рассмотрим, как использовать фабрики и ленивую инициализацию в Koin.\n\n=Определение зависимостей с фабриками=\nСоздайте файл AppModule.kt для определения модуля зависимостей с использованием фабрик:','##import org.koin.androidx.viewmodel.dsl.viewModel\n##import org.koin.core.qualifier.named\n##import org.koin.dsl.module\n\n##val **appModule** = module {\n    ##%%// Определение зависимости как фабрики%%\n    ##factory { (id: Int) -> UserRepository(id) }\n\n    ##%%// Определение ViewModel как фабрики%%\n    ##viewModel { (id: Int) -> UserViewModel(get(id)) }\n##}',NULL,'=Использование фабрик=\nИспользование зависимости как фабрики:','##class SomeActivity : AppCompatActivity() {\n\n    ##private val **userRepository**: UserRepository by inject { parametersOf(42) }\n\n    ##override fun ^^onCreate^^(savedInstanceState: Bundle?) {\n        ##super.^^onCreate^^(savedInstanceState)\n        ##setContentView(R.layout.activity_some)\n\n        ##%%// userRepository создается как новый экземпляр с параметром 42\n    ##}\n##}',NULL,'=Использование ViewModel как фабрики:=','##class AnotherActivity : AppCompatActivity() {\n\n    ##private val **userViewModel**: UserViewModel by viewModels { parametersOf(42) }\n\n    ##override fun ^^onCreate^^(savedInstanceState: Bundle?) {\n        ##super.^^onCreate^^(savedInstanceState)\n        ##setContentView(R.layout.activity_another)\n\n        ##%%// userViewModel создается как новый экземпляр с параметром 42%%\n    ##}\n##}',NULL,'=Ленивая инициализация=\nИспользуйте by lazy для ленивой инициализации зависимости:','##class SomeFragment : Fragment() {\n\n    ##private val **userRepository**: UserRepository by lazy { UserRepository(42) }\n\n    ##%%// ...%%\n##}',NULL,'=Заключение=\nИспользование фабрик позволяет создавать новые экземпляры зависимостей при каждом запросе, что может быть полезно, если требуется разные экземпляры с разными параметрами.\n Ленивая инициализация с by lazy позволяет создавать объекты только при их первом использовании, что может быть полезно для оптимизации производительности при загрузке зависимостей.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(71,3,17,70,89,71,21,'rus','2023-11-01',NULL,'Scopes и Жизненные Циклы в Koin','Scopes в Koin позволяют определить, как долго будут существовать объекты зависимостей. \nВ этом уроке мы рассмотрим, как использовать Scopes и как они связаны с жизненными циклами компонентов.\n\n=Определение Scopes=\nСоздайте файл AppModule.kt для определения модуля зависимостей и Scopes:\n','##import org.koin.androidx.viewmodel.dsl.viewModel\n##import org.koin.core.qualifier.named\n##import org.koin.dsl.module\n\n##val appModule = module {\n    ##%%// Определение одиночных зависимостей%%\n    ##single { UserRepository() }\n    ##single { UserService(get()) }\n\n    ##%%// Определение ViewModel в Scope Activity%%\n    ##scope(named<UserActivity>()) {\n        ##viewModel { UserViewModel(get()) }\n    ##}\n\n    ##%%// Определение Scoped зависимости для Fragment%%\n    ##scope(named<UserFragment>()) {\n        ##scoped { UserFragmentPresenter(get()) }\n    ##}\n##}',NULL,'=Использование Scopes= \nИспользование ViewModel в Scope Activity:','##class UserActivity : AppCompatActivity() {\n\n    ##private val **userViewModel**: UserViewModel by viewModels()\n\n    ##override fun ^^onCreate^^(savedInstanceState: Bundle?) {\n        ##super.^^onCreate^^(savedInstanceState)\n        ##setContentView(R.layout.activity_user)\n\n        ##%%// userViewModel будет существовать в пределах данной активности%%\n    ##}\n##}',NULL,'=Использование Scoped зависимости во Fragment:=','##class UserFragment : Fragment() {\n\n    ##private val **userFragmentPresenter**: UserFragmentPresenter by inject()\n\n    ##override fun ^^onCreateView^^(\n        ##inflater: LayoutInflater, container: ViewGroup?,\n        ##savedInstanceState: Bundle?\n    ##): View? {\n        ##%%// userFragmentPresenter будет существовать в пределах данного фрагмента%%\n    ##}\n##}',NULL,'=Заключение=\nScopes в Koin позволяют контролировать жизненные циклы зависимостей. Определяя зависимости с помощью разных Scopes, вы можете управлять временем их жизни, создавая более эффективный и устойчивый код.\n Это особенно полезно, когда речь идет о ViewModel внутри активности или о зависимостях внутри фрагментов, где их существование должно быть связано с жизненными циклами соответствующих компонентов.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(72,3,17,71,90,72,21,'rus','2023-11-01',NULL,'=Дополнительные Возможности Koin=','\nВ этом уроке мы рассмотрим некоторые дополнительные возможности Koin, которые могут быть полезны при разработке приложений.\n\n=Модификация и Замещение Зависимостей=','\n##val **appModule** = module {\n    ##single { UserRepository() }\n    ##single { UserService(get()) }\n##}\n\n##%%// Заменить UserService на MockUserService%%\n##val **testModule** = module {\n    ##single(override = true) { MockUserService() }\n##}',NULL,'=Замещение зависимости:=','##val **appModule** = module {\n    ##single { UserRepository() }\n    ##single { UserService(get()) }\n##}\n\n##%%// Заменить UserRepository на MockUserRepository%%\n##val **testModule** = module {\n    ##single(override = true) { MockUserRepository() }\n##}',NULL,'=Параметры и Named Зависимости=','##val **appModule** = module {\n    ##factory { (id: Int) -> UserRepository(id) }\n##}',NULL,'=Named Зависимости:=','##val **appModule** = module {\n    ##single(named(\"prod\")) { ProductionServiceImpl() }\n    ##single(named(\"test\")) { TestServiceImpl() }\n##}\n',NULL,'=Динамическая Зависимость=\nИспользование bind для динамической замены:','interface ApiService\n##class RemoteServiceImpl : ApiService\n##class LocalServiceImpl : ApiService\n\n##val **appModule** = module {\n    ##single { RemoteServiceImpl() }\n    ##%%// ...%%\n    ##bind<ApiService>() with provider { LocalServiceImpl() }\n##}',NULL,'=Множественные Реализации=\nИспользование setOf для множественных реализаций:','##interface Logger\n##class ConsoleLogger : Logger\n##class FileLogger : Logger\n\n##val **appModule** = module {\n    ##single { ConsoleLogger() }\n    ##single { FileLogger() }\n    ##single { setOf<Logger>(get(), get()) }\n##}',NULL,'=Дополнительные Функции Koin=\nПолучение всех определенных модулей:','##val **allModules** = koin.getAllModules()\n//Очистка Koin и завершение работы:\n##koin.close()',NULL,'=Заключение=\nKoin предоставляет множество дополнительных возможностей, таких как модификация и замещение зависимостей, работа с параметрами и именованными зависимостями, динамические зависимости, множественные реализации и многое другое.\n Эти возможности помогают создавать более гибкий и масштабируемый код, подходящий для различных сценариев разработки.',NULL,NULL,NULL,NULL,NULL,NULL,NULL),(73,3,17,72,91,73,21,'rus','2023-11-01',NULL,'Тестирование с помощью Koin','Koin облегчает тестирование зависимостей и внедрение фейковых (поддельных) зависимостей в тестовых сценариях. В этом уроке мы рассмотрим, как использовать Koin для тестирования и подмены зависимостей.\n\n=Тестирование с фейковыми зависимостями=\nДля тестирования, вы можете создать фейковые (поддельные) зависимости, которые заменят реальные зависимости в тестовых сценариях.\n\n=Пример фейковых зависимостей=','##class FakeUserRepository : UserRepository {\n    ##%%// Реализация фейкового UserRepository для тестирования%%\n##}\n\n##class FakeUserService(private val userRepository: UserRepository) : UserService {\n    ##%%// Реализация фейкового UserService с переданным фейковым UserRepository%%\n##}',NULL,'=Использование фейковых зависимостей в тестах с Koin=','##%%// Замена модулей фейковыми зависимостями для тестирования.%%\n##val **testModule** = module {\n    ##single<UserRepository> { FakeUserRepository() }\n    ##single<UserService> { FakeUserService(get()) }\n##}\n\n##%%// Инициализация Koin с тестовыми модулями.\n##startKoin {\n    ##modules(testModule)\n##}\n\n##%%// Получение фейковых зависимостей для тестирования.%%\n##val **userRepository**: UserRepository = get()\n##val **userService**: UserService = get()',NULL,'=Тестирование с использованием фейковых зависимостей=','##class MyTest {\n\n    ##@Before\n    ##fun ^^setup^^() {\n        ##%%/ Инициализация Koin с тестовыми модулями.%%\n        ##startKoin {\n            ##modules(testModule)\n        ##}\n    ##}\n\n    ##@Test\n    ##fun ^^testSomething^^() {\n        ##%%// Получение фейковых зависимостей для тестирования.%%\n        ##val **userRepository**: UserRepository = get()\n        ##val **userService**: UserService = get()\n\n        ##%%// Теперь мы можем использовать фейковые зависимости для тестирования.%%\n    ##}\n##}',NULL,'=Заключение=\nИспользование Koin упрощает создание и использование фейковых зависимостей для тестирования. \nВы можете легко подменять реальные зависимости на фейковые в тестовых сценариях, что делает тестирование более контролируемым и надежным.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(74,3,17,73,92,74,21,'rus','2023-11-01',NULL,'Модульное Тестирование с Koin','Модульное тестирование с использованием Koin позволяет изолированно тестировать отдельные компоненты вашего приложения, включая зависимости, которые вы внедряете с помощью Koin. В этом уроке мы рассмотрим, как создавать модульные тесты с Koin.\n\n=Настройка тестового окружения=\nДобавьте зависимость Koin для модульного тестирования в файл build.gradle вашего модуля тестов','dependencies {\n    testImplementation \"io.insert-koin:koin-test:3.1.2\"\n}',NULL,'=Написание модульных тестов=\nСоздайте тестовый класс для вашей зависимости:\n','\n##import org.koin.dsl.module\n##import org.koin.test.KoinTest\n##import org.koin.test.inject\n##import org.mockito.kotlin.mock\n##import org.junit.Before\n##import org.junit.Test\n\n##class UserRepositoryTest : KoinTest {\n\n    ##private val testModule = module {\n        ##single { UserRepository() }\n    ##}\n\n    ##private val **userRepository**: UserRepository by inject()\n\n    ##@Before\n    ##fun ^^setup^^() {\n        ##startKoin { modules(testModule) }\n    ##}\n\n    ##@Test\n    ##fun ^^testGetUsers^^() {\n        ##%%// Arrange%%\n\n        ##%%// Act%%\n        ##val **users** = **userRepository**.getUsers()\n\n        ##%%// Assert%%\n        ##%%// Напишите свои проверки здесь%%\n    ##}\n##}',NULL,'Аннотация @Before в JUnit обозначает метод, который будет выполнен перед каждым тестовым методом в классе.\n В контексте модульного тестирования с Koin, метод setup() с startKoin используется для настройки зависимостей перед каждым тестом. \nЭто обеспечивает изоляцию и надежность тестов, так как каждый тест имеет свои собственные зависимости.\n\nВ этом примере мы используем KoinTest для обеспечения интеграции Koin в тестовом окружении.\n Мы также создаем модуль testModule, в котором определяем тестируемую зависимость.\n\n=Заключение=\nМодульное тестирование с Koin позволяет создавать изолированные тесты для ваших компонентов, управляя зависимостями через Koin. \nЭто способствует повышению качества вашего кода и обеспечивает уверенность в работоспособности ваших компонентов независимо от внешних зависимостей.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(75,3,17,74,93,75,21,'rus','2023-11-01',NULL,'Обработка Ошибок и Исключений в Koin','Обработка ошибок и исключений является важной частью разработки приложений. В этом уроке мы рассмотрим, как обрабатывать ошибки и исключения при использовании Koin.\n\n=Обработка ошибок в Koin=\nKoin предоставляет несколько способов обработки ошибок и исключений при внедрении зависимостей.\n\nПо умолчанию если Koin не может разрешить зависимость, он генерирует исключение NoBeanDefFoundException. Вы можете обработать это исключение при необходимости.\n','##try {\n    ##val **userService**: UserService = get()\n    ##%%// Используйте userService%%\n##} catch (e: NoBeanDefFoundException) {\n    ##%%// Обработка ошибки%%\n##}',NULL,'=Обработка в функции inject=\nФункция inject() позволяет передать лямбду для обработки ошибки при внедрении зависимости.','##val **userService**: UserService = inject(\n    ##null, %%// По умолчанию, если нет зависимости%%\n    ##parameters = { // Параметры для разрешения зависимости\n        ##parametersOf(userId)\n    ##},\n    ##onError = { %%// Обработка ошибки%%\n        ##%%// Обработка ошибки%%\n    ##}\n##)',NULL,'=Заключение=\nОбработка ошибок и исключений в Koin может быть реализована через обработку исключений при получении зависимостей с помощью get() или через передачу лямбды в функцию inject().\n Правильная обработка ошибок улучшит надежность вашего приложения и позволит более точно реагировать на проблемные сценарии.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(76,3,18,75,94,76,22,'rus','2023-11-01',NULL,'=Введение в Dagger Hilt=','Dagger Hilt - это фреймворк для внедрения зависимостей, разработанный Google и предназначенный специально для упрощения и автоматизации процесса внедрения зависимостей в Android-приложениях. В этом уроке мы рассмотрим основные концепции Dagger Hilt.\n=Преимущества Dagger Hilt=Простота использования Dagger Hilt облегчает настройку и управление внедрением зависимостей в Android-приложениях, освобождая разработчиков от необходимости написания большого объема кода Dagger.\nМинимальная конфигурация Он предоставляет аннотации и аннотированные классы, которые автоматически генерируют код, упрощая конфигурацию.Интеграция с Android Dagger Hilt интегрируется с архитектурными компонентами Android, такими как ViewModel и Fragment, делая внедрение зависимостей естественным и легко управляемым.\n=Основные компоненты Dagger Hilt=Hilt Modules Определяют зависимости и предоставляют их с помощью аннотации @Module и методов @Provides.\nHilt Components Предоставляют зависимости, определенные в модулях, с помощью аннотации @Component.\nHilt Android Entry Points Это аннотации, которые помечают точки входа в приложение, такие как Application, Activity, Fragment, Service, и другие, для внедрения зависимостей.\n=Использование Dagger Hilt=\nДавайте рассмотрим пример использования Dagger Hilt.\n=Добавление зависимости=Добавьте зависимость Dagger Hilt в файл build.gradle вашего модуля приложения\n','##dependencies {    ##%%// ...%%\n    ##implementation \"com.google.dagger:hilt-android:2.38.1\"    ##kapt \"com.google.dagger:hilt-android-compiler:2.38.1\"\n##}',NULL,'=Аннотирование приложения=Аннотируйте ваш класс Application аннотацией @HiltAndroidApp:','##@HiltAndroidApp\n##class MyApplication : Application() {    ##%%// ...%%\n##}',NULL,'=Создание модуля=Создайте модуль с помощью аннотации @Module и предоставьте зависимости с помощью методов @Provides:\n','##@Module##@InstallIn(SingletonComponent::class)\n##object AppModule {    ##@Provides\n    ##@Singleton    ##fun ^^provideUserService^^(): UserService {\n        ##return UserServiceImpl()    ##}\n##}',NULL,'=Внедрение зависимостей=Внедрение зависимостей происходит автоматически в классах, аннотированных как точки входа. Например, в Activity:','##@AndroidEntryPoint\n##class MainActivity : AppCompatActivity() {    ##@Inject\n    ##lateinit var userService: UserService    \n    ##override fun ^^onCreate^^(savedInstanceState: Bundle?) {\n        ##super.^^onCreate^^(savedInstanceState)        ##setContentView(R.layout.activity_main)\n        ##%%// userService доступен для использования%%\n    ##}##}',NULL,'=Зачем используется lateinit?=\nВ данном случае мы используем lateinit var userService: UserService потому, что userService будет инициализирован Dagger Hilt после создания активности. Dagger Hilt автоматически производит внедрение зависимостей после onCreate, поэтому на момент вызова onCreate свойство userService будет гарантированно инициализировано.\n=Заключение=Dagger Hilt облегчает внедрение зависимостей в Android-приложениях, предоставляя простой и интуитивный способ конфигурации.\n Он автоматически генерирует большую часть кода, позволяя вам сосредоточиться на разработке приложения.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(77,3,18,76,95,77,22,'rus','2023-11-01',NULL,'=Основы аннотаций Dagger Hilt=','Dagger Hilt предоставляет ряд аннотаций, которые позволяют легко и наглядно определять зависимости и компоненты в вашем Android-приложении. В этом уроке мы рассмотрим основные аннотации Dagger Hilt.\n@HiltAndroidAppАннотация @HiltAndroidApp применяется к классу вашего приложения и является точкой входа для Dagger Hilt.\n Она говорит Hilt о необходимости создания и настройки компонента для внедрения зависимостей.','##@HiltAndroidApp##class MyApplication : Application() {\n    ##%%// ...%%##}',NULL,'@AndroidEntryPoint\nАннотация @AndroidEntryPoint применяется к Android-классам, таким как Activity, Fragment, Service и другие, для автоматического внедрения зависимостей. Она говорит Hilt о необходимости внедрения зависимостей в этот класс.','##@AndroidEntryPoint##class MainActivity : AppCompatActivity() {\n    ##%%// ...%%##}',NULL,'@Module\nАннотация @Module определяет модуль, который предоставляет зависимости с помощью методов @Provides. Методы в модуле аннотируются @Provides и предоставляют зависимости, которые будут использоваться в приложении.','##@Module##@InstallIn(SingletonComponent::class)\n##object AppModule {\n    ##@Provides    ##@Singleton\n    ##fun ^^provideUserService^^(): UserService {        ##return UserServiceImpl()\n    ##}##}',NULL,'@InstallIn\nАннотация @InstallIn указывает, в каком компоненте Dagger Hilt будет доступен модуль. Принимаемые значения, такие как SingletonComponent, ActivityComponent, FragmentComponent, определяют область видимости зависимостей.','##@Module##@InstallIn(SingletonComponent::class)\n##object AppModule {    ##%%// ...%%\n##}',NULL,'@EntryPoint\nАннотация @EntryPoint позволяет вам получить доступ к Hilt-компоненту для внедрения зависимостей в класс, который не аннотирован @AndroidEntryPoint, например, в ViewModel.','##@EntryPoint##@InstallIn(SingletonComponent::class)\n##interface MyEntryPoint {    ##fun ^^getUserService^^(): UserService\n##}',NULL,'@InjectАннотация @Inject применяется к свойствам, конструкторам или методам, которые должны быть внедрены. Это обозначает, что Dagger Hilt должен обеспечить эту зависимость.\n','##@AndroidEntryPoint##class MainActivity : AppCompatActivity() {\n    ##@Inject    ##lateinit var userService: UserService\n    ##%%// ...%%##}',NULL,'@ViewModelInject\nАннотация @ViewModelInject применяется к конструктору ViewModel и позволяет Dagger Hilt автоматически внедрять зависимости в ViewModel. Это особенно удобно, так как ViewModel часто требует зависимостей, например, репозиториев.','##@HiltViewModel##class UserViewModel @ViewModelInject constructor(\n    ##private val userRepository: UserRepository##) : ViewModel() {\n    ##%%// ...%%##}',NULL,'@HiltViewModel\nАннотация @HiltViewModel указывает Dagger Hilt на необходимость создания и внедрения зависимостей в ViewModel. Она должна быть применена к классу ViewModel.','##@HiltViewModel##class UserViewModel @ViewModelInject constructor(\n    ##private val userRepository: UserRepository##) : ViewModel() {\n    ##%%// ...%%##}',NULL,'Использование\nDagger Hilt автоматически создаст и внедрит зависимости, указанные в конструкторе UserViewModel. При создании экземпляра UserViewModel будут автоматически внедрены все зависимости, определенные в конструкторе.','##@AndroidEntryPoint##class MainActivity : AppCompatActivity() {\n    ##private val userViewModel: UserViewModel by viewModels()\n    ##%%// ...%%\n##}',NULL,'=Заключение=Аннотации Dagger Hilt обеспечивают простой и декларативный способ определения и внедрения зависимостей в Android-приложениях. \nОни помогают сократить объем\n\nкода и сделать процесс внедрения более понятным и удобным.',NULL),(78,3,18,77,96,78,22,'rus','2023-11-01',NULL,'=Жизненный цикл и области видимости в Dagger Hilt=','Dagger Hilt предоставляет управление жизненным циклом и областями видимости зависимостей, позволяя эффективно управлять созданием и уничтожением зависимостей в приложении. В этом уроке мы рассмотрим, как Dagger Hilt управляет жизненным циклом и областями видимости.\n=Области видимости=Dagger Hilt предоставляет несколько областей видимости для управления временем жизни зависимостей\n@Singleton Зависимости с этой аннотацией живут в пределах жизненного цикла приложения и создаются только один раз.\n@ActivityScoped Зависимости с этой аннотацией живут в пределах жизненного цикла активности и создаются заново для каждой активности.@FragmentScoped Зависимости с этой аннотацией живут в пределах жизненного цикла фрагмента и создаются заново для каждого фрагмента.\n=Применение областей видимости=Чтобы указать область видимости для зависимости, аннотируйте методы @Provides модуля соответствующей аннотацией. Например\n','##@Module##@InstallIn(SingletonComponent::class)\n##object AppModule {\n    ##@Provides    ##@Singleton\n    ##fun ^^provideUserService^^(): UserService {        ##return UserServiceImpl()\n    ##}##}\n##@Module\n##@InstallIn(ActivityComponent::class)##object ActivityModule {\n    ##@Provides\n    ##@ActivityScoped\n    ##fun ^^provideSomeDependency^^(): SomeDependency {        ##return SomeDependencyImpl()\n    ##}##}',NULL,'=Жизненный цикл=\nDagger Hilt автоматически управляет временем жизни зависимостей в соответствии с их областями видимости:\n@Singleton зависимости создаются один раз при запуске приложения и уничтожаются вместе с приложением.@ActivityScoped зависимости создаются при создании активности и уничтожаются вместе с ней.\n@FragmentScoped зависимости создаются при создании фрагмента и уничтожаются вместе с ним.Заключение\nDagger Hilt позволяет управлять жизненным циклом и областями видимости зависимостей, облегчая управление временем создания и уничтожения зависимостей в различных частях вашего приложения. Аннотации @Singleton, @ActivityScoped и @FragmentScoped позволяют определить область видимости для зависимостей, а Dagger Hilt автоматически управляет их жизненным циклом.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(79,3,18,78,97,79,22,'rus','2023-11-01',NULL,'=Использование ViewModel с Dagger Hilt=','Dagger Hilt упрощает инъекцию зависимостей в ViewModel и управление их жизненным циклом. В этом уроке мы рассмотрим, как использовать Dagger Hilt для внедрения зависимостей в ViewModel и как правильно управлять их жизненным циклом.\n=Аннотирование ViewModel=Для начала нам нужно аннотировать наш класс ViewModel с помощью аннотации @HiltViewModel. Эта аннотация указывает Dagger Hilt на необходимость управления этим ViewModel.','##@HiltViewModel\n##class UserViewModel @Inject constructor(    ##private val userRepository: UserRepository\n##) : ViewModel() {    ##%%// ...%%\n##}',NULL,'=Внедрение ViewModel=Далее, чтобы внедрить ViewModel в нашей активности или фрагменте, мы используем аннотацию @ViewModelInject. Эта аннотация говорит Dagger Hilt, что нам нужно внедрить ViewModel в данный компонент.','##@AndroidEntryPoint\n##class MainActivity : AppCompatActivity() {\n    ##@ViewModelInject    ##lateinit var userViewModel: UserViewModel\n    ##%%// ...%%\n##}',NULL,'=Использование ViewModel=Теперь мы можем использовать нашу ViewModel, и Dagger Hilt автоматически внедрит зависимости, такие как UserRepository, в эту ViewModel.','@AndroidEntryPoint\n##class MainActivity : AppCompatActivity() {\n    ##@ViewModelInject    ##lateinit var userViewModel: UserViewModel\n    ##override fun ^^onCreate^^(savedInstanceState: Bundle?) {\n        ##super.^^onCreate^^(savedInstanceState)        ##setContentView(R.layout.activity_main)\n        ##%%// Использование userViewModel и его зависимостей%%\n    ##}##}',NULL,'=Заключение=\nИспользование ViewModel с Dagger Hilt делает процесс внедрения зависимостей более простым и удобным. Аннотации @HiltViewModel и @ViewModelInject позволяют автоматически внедрять зависимости в ViewModel и управлять их жизненным циклом.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(80,3,18,79,98,80,22,'rus','2023-11-01',NULL,'=Дополнительные функции Dagger Hilt=','Dagger Hilt предоставляет множество дополнительных функций для управления зависимостями и их жизненным циклом в приложениях Android. В этом уроке мы рассмотрим несколько ключевых возможностей Dagger Hilt, которые помогут вам более эффективно управлять зависимостями в вашем приложении.\n=1. Scopes (Области видимости)=Dagger Hilt предоставляет несколько встроенных областей видимости, таких как @Singleton, @ActivityScoped, @FragmentScoped и др. Области видимости позволяют управлять жизненным циклом зависимостей и обеспечивают их совместное использование только внутри определенных компонентов (например, только в рамках активности или фрагмента).\n=Пример:=','##@Singleton\n##@InstallIn(SingletonComponentclass)##@Module\n##object AppModule {     ##Предоставление зависимостей для области Singleton\n##}',NULL,'=2. Настройка аргументов для зависимостей=Вы можете настраивать аргументы для ваших зависимостей, используя аннотацию @BindValue. Это позволяет передавать параметры в зависимости во время их создания.\n=Пример:=','##@HiltViewModel\n##class MyViewModel @Inject constructor(    ##private val repository: MyRepository,\n    ##@BindValue private val customValue: String##) : ViewModel()',NULL,'=3. Квалификаторы=\nВы можете использовать квалификаторы для разрешения конфликтов, когда у вас есть несколько зависимостей одного и того же типа. Для этого используется аннотация @Qualifier.\n=Пример:=','##@Retention(AnnotationRetention.BINARY)##@Qualifier\n##annotation class CustomQualifier\n##@Module##@InstallIn(SingletonComponent::class)\n##object AppModule {    ##@CustomQualifier\n    ##@Provides    ##fun ^^provideCustomDependency^^(): CustomDependency {\n        ##return CustomDependency()    ##}\n##}',NULL,'=4. Динамическая настройка компонентов=Вы можете динамически настраивать компоненты Dagger Hilt в зависимости от потребностей вашего приложения. Это делается с помощью аннотации @EntryPoint и @EntryPointAccessors.\n=Пример:=','##@EntryPoint\n##@InstallIn(SingletonComponent::class)##interface MyEntryPoint {\n    ##fun ^^inject^^(myClass: MyClass)##}\n##val entryPoint = EntryPointAccessors.fromApplication(context, MyEntryPoint::class.java)\n##**entryPoint**.^^inject^^(myClass)',NULL,'5. Компоненты собраны на основе интерфейсовВы можете определить интерфейс компонента и разрешить Dagger Hilt сгенерировать реализацию этого интерфейса автоматически.\n=Пример:=','##@Singleton\n##@InstallIn(SingletonComponent::class)\n##@Component##interface MyComponent {\n    ##%%// Здесь определяются методы предоставления зависимостей%%##}',NULL,'=Заключение=\nDagger Hilt предоставляет множество дополнительных функций для управления зависимостями в ваших Android-приложениях. Вы можете использовать области видимости, настраивать аргументы для зависимостей, использовать квалификаторы, динамически настраивать компоненты и многое другое. \nЭти возможности позволяют вам эффективно управлять зависимостями в вашем приложении и облегчают разработку и тестирование.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(81,3,18,80,99,81,22,'rus','2023-11-01',NULL,'=Тестирование с помощью Dagger Hilt=','Dagger Hilt - это библиотека для внедрения зависимостей (DI) в приложения Android, которая является частью библиотеки Dagger. Она упрощает создание и тестирование компонентов приложения, которые используют DI.\n В этом уроке мы рассмотрим, как использовать Dagger Hilt для тестирования ваших Android-приложений.\n=Подключение Dagger Hilt=Прежде всего, вам нужно добавить зависимость Dagger Hilt в ваш проект. Вы можете сделать это, добавив следующую зависимость в файл build.gradle вашего приложения:','##implementation \"com.google.dagger:hilt-android:2.40.5\"\n##annotationProcessor \"com.google.dagger:hilt-android-compiler:2.40.5\"',NULL,'Также, убедитесь, что в вашем файле build.gradle есть следующая строка:','##apply plugin: \"dagger.hilt.android.plugin\"',NULL,'=Создание компонентов Hilt=Dagger Hilt использует аннотации для создания компонентов, которые предоставляют зависимости. Ваше приложение должно иметь следующие компоненты:\n@HiltAndroidApp: Эта аннотация помечает ваше приложение как приложение Dagger Hilt и генерирует необходимый код.\n@HiltViewModel: Эта аннотация помечает ваши ViewModel, чтобы Dagger Hilt мог предоставлять им зависимости.\n=Пример:=','##@HiltAndroidApp\n##class MyApplication : Application()##@HiltViewModel\n##class MyViewModel @Inject constructor(private val repository: MyRepository) : ViewModel()',NULL,'=Создание модулей=Модули предоставляют зависимости Dagger Hilt. Вы можете создать модули для предоставления зависимостей, таких как репозитории, сервисы и другие классы.\n=Пример:=','##@Module\n##@InstallIn(SingletonComponent::class)##object MyModule {\n    ##@Provides    ##fun ^^provideRepository^^(): MyRepository {\n        ##return MyRepository()    ##}\n##}',NULL,'=Создание юнит-тестов=\nDagger Hilt упрощает создание юнит-тестов для вашего кода. Вы можете использовать HiltTestRule для инициализации компонентов Dagger Hilt перед запуском тестов.\n=Пример:=','##@HiltAndroidTest##@UninstallModules(MyModule::class)\n##class MyViewModelTest {\n    ##@get:Rule    ##var hiltTestRule = HiltAndroidRule(this)\n    ##@Inject\n    ##lateinit var repository: MyRepository\n    ##@Before    ##fun ^^setup^^() {\n        ##**hiltTestRule**.inject()\n    ##}\n    ##@Test    ##fun ^^testViewModel^^() {\n        ##%%// Ваши тесты ViewModel%%    ##}\n##}',NULL,' =Запуск тестов=Теперь вы можете запустить ваши тесты с помощью инструмента для запуска тестов Android. \nDagger Hilt автоматически предоставит зависимости, необходимые для ваших тестов.\n=Заключение=Dagger Hilt - мощный инструмент для внедрения зависимостей в приложения Android, который облегчает тестирование вашего кода.\n Следуя этому уроку, вы сможете использовать Dagger Hilt для создания компонентов и модулей, а также написания юнит-тестов для вашего приложения. Это поможет вам обеспечить качество вашего приложения и улучшить его поддерживаемость.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(82,3,19,81,100,82,23,'rus','2023-11-01',NULL,'Что такое тестирование?','Тестирование - это процесс проверки программы с целью выявления ошибок, а также подтверждения, что она работает ожидаемым образом. Тестирование играет важную роль в обеспечении качества программного продукта и уверенности в его функциональности.\n\n=Почему тестирование важно=\nВыявление ошибок Тестирование помогает обнаружить ошибки и дефекты в программе, даже до того, как она попадет к пользователям.\nПоддержание качества Тестирование помогает поддерживать высокое качество кода и продукта, предотвращая появление ошибок в будущем.\nДокументация Тесты служат как документация к коду, описывая ожидаемое поведение компонентов.\nОблегчение рефакторинга С тестами можно убедиться, что изменения в коде не нарушают его работу.\nДоверие к продукту Наличие хорошо протестированного кода создает доверие у пользователей.\n=Виды тестирования=\nUnit-тестирование Тестирование отдельных компонентов (например, функций, методов) для проверки их корректности работы. Тестируется изолированно от остальной системы.\nИнтеграционное тестирование Проверка взаимодействия между компонентами системы. Определяется, как различные компоненты работают вместе.\nФункциональное тестирование Тестирование системы в целом с точки зрения её функций и поведения.\nПриёмочное тестирование Тестирование с целью убедиться, что продукт соответствует ожиданиям заказчика.\n=Тестирование в Kotlin=\nKotlin предоставляет широкий спектр инструментов для тестирования:\n\nJUnit Популярный фреймворк для юнит-тестирования.\nKotest Полнофункциональный фреймворк для тестирования Kotlin-кода с богатым DSL.\nMockK Библиотека для создания моков и стабов.\nkotlinx.coroutines.test Поддержка для тестирования сопрограмм.\nЛучшие практики при тестировании\nArrange-Act-Assert Разделяйте код теста на три части подготовка (arrange), выполнение действия (act) и проверка результата (assert).\nПишите тесты раньше кода Это помогает определить ожидаемое поведение и выявить проблемы на ранних этапах.\nПокрытие кода тестами Старайтесь покрыть как можно больше кода тестами для обеспечения надежности.\nТестирование граничных случаев Убедитесь, что ваши тесты включают проверку крайних значений и некорректных входных данных.\nЗапуск тестов регулярно Используйте системы Continuous Integration (CI) для автоматического запуска тестов при каждом изменении кода.\n=Заключение=\nТестирование является неотъемлемой частью процесса разработки, помогающей создать надежное и стабильное программное обеспечение.\n Оно позволяет выявить ошибки и дефекты, поддерживать высокое качество кода и создавать доверие к продукту.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(83,3,19,82,101,83,23,'rus','2023-11-01',NULL,'Unit-Тестирование','=Что такое Unit-тестирование?=\nUnit-тестирование - это процесс проверки отдельных компонентов вашего кода (функций, методов, классов) с целью убедиться, что они работают корректно и соответствуют ожидаемому поведению.\n\n=Преимущества Unit-тестирования=\nРаннее выявление ошибок Unit-тесты помогают выявить ошибки на ранних этапах разработки, что снижает затраты на исправление проблем в будущем.\nДокументация Unit-тесты служат как документация к коду, описывая ожидаемое поведение компонентов.\nПоддерживаемость При изменении кода вы можете использовать unit-тесты, чтобы убедиться, что изменения не сломали существующую функциональность.\nДизайн с точки зрения клиента Тестирование с точки зрения клиента (то есть использование кода как клиентский код) помогает создать более простой и легко используемый интерфейс.\n=Написание Unit-тестов в Kotlin=\nВыбор фреймворка Вы можете использовать различные фреймворки для юнит-тестирования, такие как JUnit или Kotest. Они предоставляют средства для создания тестовых случаев и проверки ожидаемых результатов.\n\nАранжирование (Arrange) Подготовьте тестовые данные и создайте экземпляр компонента, который вы хотите протестировать.\n\nДействие (Act) Вызовите метод или функцию, которую вы хотите протестировать, передавая тестовые данные.\n\nУтверждение (Assert) Сравните результат выполнения с ожидаемым результатом. Если результаты не соответствуют ожидаемым, тест считается неудачным.\n\nТесты пишутся в специально папке, под названием androidTest\nТакже для работы теста нужно полностью скопировать всю ветку директорий в которой находится тестируемый элемент :фото\n=Подключение junit:=','dependencies {\n##dependencies {\n    ##testImplementation(\"junit:junit:4.13.2\")\n    ##%%// ... другие зависимости%%\n##}\n ',NULL,'=Пример Unit-теста в Kotlin (с использованием JUnit)=','##import org.junit.Test\n##import kotlin.test.assertEquals\n##%%//Тестируемый элемент%%\n##class Calculator {\n    ##fun add(a Int, b Int) Int {\n        ##return a + b\n    ##}\n##}\n\nclass CalculatorTest {\n\n    @Test\n    ##fun ^^testAdd^^() {\n        ##val **calculator** = Calculator()\n        ##val **result** = **calculator**.add(3, 5)\n        ##assertEquals(8, result)\n    ##}\n##}',NULL,'=Тестирование граничных случаев=\nПомимо тестирования стандартных сценариев, важно акцентировать внимание на проверку граничных случаев при написании юнит-тестов. Граничные случаи представляют собой экстремальные значения и ситуации, которые могут привести к непредсказуемому поведению или ошибкам в вашем коде. Проверка граничных случаев может обнаружить уязвимости и некорректное поведение, которые могут остаться незамеченными в обычных сценариях.\n\nПримеры Граничных Случаев\nНулевые значения: Проверьте, как ваш код обрабатывает нулевые значения или пустые коллекции.\n\nОтрицательные значения: Убедитесь, что отрицательные значения обрабатываются корректно и без ошибок.\n\nКрайние значения: Проверьте, как ваш код обрабатывает значения, близкие к верхним или нижним границам допустимых диапазонов.\n\nПереполнение и переполнение типов: В зависимости от используемых типов данных, убедитесь, что ваш код не вызывает переполнение или недопустимые результаты.\n\nГраничные условия алгоритмов: Проверьте, как алгоритмы в вашем коде обрабатывают крайние случаи входных данных.\n\nКорневые случаи: Если ваш код содержит операции деления, извлечения квадратного корня или другие операции, которые могут вызвать ошибку при нулевых или отрицательных значениях, обязательно протестируйте эти сценарии.\n\n=Почему Граничные Случаи Важны?=\n\nВыявление ошибок: Граничные случаи могут привести к непредсказуемым результатам и ошибкам, которые не будут обнаружены при обычных тестированиях.\nУлучшение надежности: Обработка граничных случаев улучшает надежность кода и позволяет убедиться, что при непредвиденных данных ваш код будет работать стабильно.\nПовышение качества: Работоспособность в граничных условиях демонстрирует высокое качество вашего продукта.\n=Пример:=\nПредставьте, что у вас есть функция деления:','\n##fun ^^divide^^(a: Int, b: Int): Int {\n    ##return a / b\n##}',NULL,'Тестирование граничных случаев может выглядеть так:\n','##@Test\n##fun ^^testDivide^^() {\n    ##assertEquals(2, ^^divide^^(10, 5))\n    ##assertEquals(0, ^^divide^^(0, 5))\n    \n    ##assertThrows(ArithmeticException::class.java) {\n        ##^^divide^^(5, 0)\n    ##}\n##}\n',NULL,'=Лучшие практики=\nПишите тесты до написания кода.\nНазывайте тестовые методы описательно, чтобы было понятно, что они тестируют.\nИспользуйте подход AAA (Arrange-Act-Assert) для структурирования тестов.\nПокрывайте тестами крайние и нетипичные сценарии.\n=Заключение=\nUnit-тестирование позволяет проверять отдельные компоненты вашего кода на соответствие ожидаемому поведению. Это помогает выявить ошибки, обеспечить качество и поддерживаемость кода, а также создать документацию к вашему проекту.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(84,3,19,83,102,84,23,'rus','2023-11-01',NULL,'Интеграционное Тестирование','=Что такое Интеграционное Тестирование?=\nИнтеграционное тестирование - это методика тестирования, при которой тестируется взаимодействие между различными компонентами системы или модулями кода. \nЦелью интеграционного тестирования является проверка, как компоненты взаимодействуют друг с другом и что весь код работает вместе как ожидается.\n\n=Зачем это нужно?=\nПроверка взаимодействия Интеграционные тесты помогают убедиться, что компоненты системы корректно взаимодействуют друг с другом.\nОбнаружение несоответствий Эта методика позволяет выявлять несоответствия и ошибки, которые могут возникнуть только при совместной работе компонентов.\nУверенность в качестве Интеграционные тесты повышают уверенность в качестве продукта перед его выпуском.\n=Примеры Интеграционного Тестирования=\nИнтеграционное тестирование сервиса с использованием реальной базы данных','##class UserService(private val userRepository: UserRepository) {\n    ##fun getUserById(id: Int): User? {\n        ##return userRepository.findById(id)\n    ##}\n##}\n\n##class UserRepository {\n    ##fun ^^findById^^(id: Int): User? {\n        ##// Реальный запрос к базе данных\n    ##}\n##}\n\n##class UserServiceIntegrationTest {\n\n    ##@Test\n    ##fun ^^testGetUserById^^() {\n        ##val **userRepository** = UserRepository()\n        ##val **userService** = UserService(**userRepository**)\n\n        ##val **user** = userService.getUserById(1)\n\n        ##assertNotNull(**user**)\n        ##assertEquals(1, **user**?.id)\n    ##}\n##}',NULL,'В этом примере тестируется взаимодействие между UserService и UserRepository. \nВажно, чтобы этот вид тестирования проводился на реальной базе данных или на её стабе.\n=Интеграционное тестирование API=','##class UserController(private val userService: UserService) {\n    ##fun ^^getUserInfo^^(userId: Int): UserInfo? {\n        ##val **user** = userService.getUserById(userId)\n        ##return if (**user** != null) {\n            ##UserInfo(**user**.id, **user**.name, **user**.email)\n        ##} else {\n            ##null\n        ##}\n    ##}\n##}\n\n##class UserControllerIntegrationTest {\n\n    ##@Test\n    ##fun ^^testGetUserInfo^^() {\n        ##val **userRepository** = UserRepository()\n        ##val **userService** = UserService(**userRepository**)\n        ##val **userController** = UserController(**userService**)\n\n        ##val **userInfo** = **userController**.getUserInfo(1)\n\n        ##assertNotNull(**userInfo**)\n        ##assertEquals(1, **userInfo**?.userId)\n    ##}\n##}',NULL,'В этом примере интеграционно тестируется API контроллера UserController, который взаимодействует с UserService.\n\n=Заключение=\nИнтеграционное тестирование важно для обеспечения правильного взаимодействия компонентов и модулей в вашем программном продукте. Это позволяет выявить несоответствия и ошибки, которые могут возникнуть только при совместной работе, и обеспечить надежное функционирование всей системы.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(85,3,19,84,103,85,23,'rus','2023-11-01',NULL,'Тестирование Kotlin Coroutines','Что такое Kotlin Coroutines?\nKotlin Coroutines - это библиотека, позволяющая упростить асинхронное программирование в языке Kotlin. Она предоставляет легковесные потоки выполнения (корутины), которые могут быть приостановлены и продолжены без создания дополнительных нитей.\n\n=Зачем это нужно?=\nАсинхронное программирование: Kotlin Coroutines упрощают написание асинхронного кода без необходимости вручную управлять потоками.\nСинтаксическая чистота: Корутины предоставляют удобный и выразительный синтаксис для описания асинхронных операций.\nПараллелизм: Корутины могут выполняться параллельно, что позволяет эффективнее использовать ресурсы.\n=Тестирование Корутин=\nПри тестировании кода, использующего корутины, важно обеспечить предсказуемость и контроль над их выполнением.\n Для этого вы можете использовать TestCoroutineDispatcher из пакета kotlinx.coroutines.test.\n\n\n=Gradle зависимость=\nДобавьте зависимость на kotlinx-coroutines-test в ваш файл build.gradle.kts (или build.gradle):     ','##dependencies {\n    ##testImplementation(\"org.jetbrains.kotlinx:kotlinx-coroutines-test:1.5.2\")\n    ##%%// ... другие зависимости%%\n##}',NULL,'\nПредположим, у вас есть функция, которая выполняет асинхронную операцию:','##import kotlinx.coroutines.Dispatchers\n##import kotlinx.coroutines.delay\n##import kotlinx.coroutines.withContext\n\n##suspend fun ^^fetchData^^(): String {\n    ##return withContext(Dispatchers.IO) {\n        ##delay(1000)\n        ##return@withContext \"Data from network\"\n    ##}\n##}',NULL,'Пример теста с использованием TestCoroutineDispatcher:','##import kotlinx.coroutines.test.runBlockingTest\n##import org.junit.Test\n##import kotlin.test.assertEquals\n\n##class CoroutineTest {\n\n    ##@Test\n    ##fun ^^testFetchData^^() = runTest {\n        ##val **result** = ^^fetchData^^()\n        ##assertEquals(\"Data from network\", **result**)\n    ##}\n##}',NULL,'В этом примере функция runTest предоставляет контролируемую среду выполнения для корутин в тестах.\n\n=Заключение=\nТестирование Kotlin Coroutines важно для обеспечения надежности и стабильности асинхронного кода. Используйте TestCoroutineDispatcher и специфичные функции для тестирования корутин, чтобы создать предсказуемую среду для асинхронных операций.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(86,3,19,85,104,86,23,'rus','2023-11-01',NULL,'Тестирование Исключений','Что такое Тестирование Исключений?\nТестирование исключений - это методика юнит-тестирования, при которой проверяется, как ваш код обрабатывает исключительные ситуации (исключения), которые могут возникнуть в процессе выполнения программы.\n\n=Зачем это нужно=\nОбработка ошибок Тестирование исключений позволяет убедиться, что ваш код корректно обрабатывает исключительные ситуации и не приводит к непредвиденным сбоям.\nРобастность Хорошо обработанные исключения повышают робастность кода, позволяя ему продолжать работу даже при возникновении ошибок.\n=Примеры Тестирования Исключений=\nИспользование @Test аннотации с ожидаемым исключением\n','##import org.junit.Test\n##import kotlin.test.assertFailsWith\n\n##class MathUtils {\n    ##fun ^^divide^^(a Int, b Int) Int {\n        ##if (b == 0) {\n            ##throw IllegalArgumentException(Division by zero is not allowed)\n        ##}\n        ##return a  b\n    ##}\n##}\n\n##class MathUtilsTest {\n\n    ##@Test\n    ##fun ^^testDivideByZero^^() {\n        ##val **mathUtils** = MathUtils()\n        ##val **exception** = assertFailsWithIllegalArgumentException {\n            ##mathUtils.^^divide^^(10, 0)\n        ##}\n        ##assertEquals(Division by zero is not allowed, exception.message)\n    ##}\n\n    ##@Test\n    ##fun ^^testDivide^^() {\n        ##val **mathUtils** = MathUtils()\n        ##val **result** = **mathUtils**.^^divide^^(10, 5)\n        ##assertEquals(2, result)\n    ##}\n##}',NULL,'В этом примере используется функция assertFailsWith, которая ожидает, что выполнение кода в блоке вызовет исключение указанного типа. Вы также можете проверить сообщение об ошибке и другие аспекты исключения.\n\n=Использование @Test(expected = ...)=','##import org.junit.Test\n\n##class MathUtils {\n    ##fun ^^divide^^(a Int, b Int) Int {\n        ##if (b == 0) {\n            ##throw IllegalArgumentException(Division by zero is not allowed)\n        ##}\n        ##return a  b\n    ##}\n##}\n\n##class MathUtilsTest {\n\n    ##@Test(expected = IllegalArgumentExceptionclass)\n    ##fun ^^testDivideByZero^^() {\n        ##val **mathUtils** = MathUtils()\n        ##**mathUtils**.^^divide^^(10, 0)\n    ##}\n\n    ##@Test\n    ##fun ^^testDivide^^() {\n        ##val **mathUtils** = MathUtils()\n        ##val **result** = **mathUtils**.^^divide^^(10, 5)\n        ##assertEquals(2, **result**)\n    ##}\n##}',NULL,'В этом примере @Test(expected = ...) аннотация используется для указания ожидаемого исключения.\n\n=Заключение=\nТестирование исключений важно для обеспечения надежности и стабильности вашего кода. Путем создания специальных тестов для обработки исключений вы можете убедиться, что ваше приложение адекватно реагирует на нештатные ситуации и предоставляет понятные сообщения об ошибках.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(87,3,19,86,105,87,23,'rus','2023-11-01',NULL,'Тестирование REST API','Что такое Тестирование REST API?\nТестирование REST API - это процесс проверки функциональности, надежности и соответствия стандартам вашего веб-сервиса, основанного на архитектуре REST (Representational State Transfer).\n\n=Зачем это нужно=\nПоддержание качества Тестирование API помогает убедиться, что ваш сервис работает так, как ожидается, и что он продолжает работать после внесения изменений.\nДокументация Тесты API служат как документация для вашего кода, предоставляя примеры использования и ожидаемое поведение.\nИнтеграция Тестирование API позволяет обнаруживать проблемы в интеграции между компонентами системы.\n=Инструменты для Тестирования REST API=\nСуществует множество инструментов для тестирования REST API. Вам может понадобиться выбрать тот, который лучше всего соответствует вашим потребностям. Некоторые популярные инструменты\n\nPostman Графический инструмент для создания и отправки HTTP-запросов, а также проверки ответов.\n\nRestAssured Библиотека для автоматизированного тестирования REST API с использованием Java или Kotlin.\n\nJUnit или другие фреймворки Вы можете использовать стандартные инструменты для юнит-тестирования (например, JUnit) для написания тестов для вашего API.\n\n=Пример Тестирования REST API с RestAssured=\nПредположим, у вас есть REST API для создания и получения информации о пользователях. \nВот как может выглядеть тестирование с использованием RestAssured\n','##import io.restassured.RestAssured\n##import io.restassured.http.ContentType\n##import org.junit.Test\n\n##class UserApiTest {\n\n    ##private val **baseUrl** = httplocalhost8080apiusers\n\n    ##@Test\n    ##fun ^^testGetAllUsers^^() {\n        ##RestAssured.given()\n            ##.get(**baseUrl**)\n            ##.then()\n            ##.statusCode(200)\n    ##}\n\n    ##@Test\n    ##fun ^^testCreateUser^^() {\n        ##val **newUser** = mapOf(name to John, age to 30)\n\n        ##RestAssured.given()\n            ##.contentType(ContentType.JSON)\n            ##.body(newUser)\n            ##.post(baseUrl)\n            ##.then()\n            ##.statusCode(201)\n    ##}\n##}',NULL,'=Пример Тестирования REST API с Postman=\nPostman предоставляет графический интерфейс для создания и отправки запросов, а также для проверки ответов.\n Вы можете создать коллекцию запросов и тестов в Postman и запустить их в режиме автоматизированного тестирования.\n\n=Заключение=\nТестирование REST API - это важная часть обеспечения качества вашего веб-сервиса.\n Выберите подходящий инструмент и создайте тесты, которые проверяют функциональность, безопасность и надежность вашего API.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(88,3,19,87,106,88,23,'rus','2023-11-01',NULL,'Mocking и Stubbing в Тестировании','=Что такое Mocking и Stubbing?=\nMocking и stubbing - это техники, используемые в юнит-тестировании для изоляции тестируемого кода от внешних зависимостей, таких как базы данных, сетевые вызовы или другие компоненты. \nЭто позволяет создавать контролируемые среды окружения и упрощать процесс тестирования.\n\n=Mocking=\nМок (mock) - это имитация реального объекта или компонента, который может использоваться в тестах вместо настоящей реализации. \nМоки создаются с помощью библиотек для мокирования (например, MockK, Mockito).\n\nStubbing\nСтаб (stub) - это поддельная реализация метода или функции, которая возвращает заранее определенное значение.\n Стабы используются для создания сценариев тестирования, когда необходимо возвращать определенные результаты для определенных входных данных.\n\n=Зачем это нужно?=\nИзоляция Тестирование компонента, изолированного от внешних зависимостей, обеспечивает более точные и предсказуемые результаты.\nСкорость Моки и стабы позволяют тестировать компоненты быстро, не требуя реального взаимодействия с ресурсоемкими зависимостями.\nКонтроль Вы можете контролировать поведение зависимостей и создавать различные сценарии для тестирования.\n=Gradle зависимости=\nДобавьте следующие зависимости в ваш файл build.gradle:','dependencies {\n    testImplementation(\"io.mockk:mockk:1.12.0\")\n    // ... другие зависимости\n}',NULL,'=Примеры:=\n\nMocking\nПредположим, у вас есть сервис, который использует базу данных','class DatabaseService(private val database: Database) {\n    fun saveData(data: String) {\n        database.save(data)\n    }\n}\n//Используя мокирование, вы можете создать мок для Database\n\nval mockDatabase = mockk<Database>()\nval service = DatabaseService(mockDatabase)\n\n// Определение поведения мока\nevery { mockDatabase.save(any()) } just Runs\n\nservice.saveData(\"test data\")\n\n// Проверка, что метод был вызван с определенными параметрами\nverify { mockDatabase.save(\"test data\") }',NULL,'=Stubbing=\nПредположим, у вас есть функция, которая делает HTTP-запрос','class NetworkService(private val httpClient: HttpClient) {\n    suspend fun fetchData(): String {\n        return httpClient.get(\"https://example.com/data\")\n    }\n}\n\n//Используя стабирование, вы можете создать стаб для HttpClient\n\nval stubHttpClient = mockk<HttpClient>()\nval service = NetworkService(stubHttpClient)\n\n //Определение поведения стаба\ncoEvery { stubHttpClient.get(\"https://example.com/data\") } returns \"Mocked Data\"\n\nval result = runBlocking { service.fetchData() }\n\nassertEquals(\"Mocked Data\", result)',NULL,'=Заключение=\nMocking и stubbing - это мощные инструменты, которые помогают создавать изолированные среды для тестирования.\n Они позволяют контролировать зависимости и создавать различные сценарии для проверки функциональности вашего кода.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(89,2,9,89,108,89,12,'rus','2023-11-01',NULL,'Что такое контекст в Android?','Контекст - это один из наиболее важных концептов в разработке Android-приложений. Он представляет собой объект, предоставляемый системой Android, который содержит информацию о вашем приложении и окружающей среде. \r\nКонтекст позволяет вашему приложению взаимодействовать с различными компонентами системы, такими как ресурсы, активити, службы и многое другое. Он также используется для доступа к системным ресурсам и для выполнения различных операций.\r\n\r\nВиды контекста:\r\n\r\nApplicationContext: Этот тип контекста представляет приложение в целом и существует на протяжении всего жизненного цикла приложения. ApplicationContext не привязан к какой-либо конкретной активности и часто используется для доступа к глобальным ресурсам, таким как строки, графика и базы данных.\r\n\r\nActivityContext: Этот тип контекста связан с конкретной активити и имеет более ограниченную жизненную длительность. ActivityContext используется для выполнения операций, связанных с данной активити, такие как создание диалоговых окон или запуск новых активити.\r\n\r\nServiceContext: Подобно ActivityContext, этот контекст связан с конкретной службой (Service) и используется для выполнения операций в контексте этой службы.\r\n\r\nПримеры использования контекста:\r\n\r\nДоступ к ресурсам: Контекст позволяет вашему приложению получить доступ к строкам, изображениям, макетам и другим ресурсам, хранящимся в ресурсах приложения.\r\n\r\nСоздание и управление активностями: Контекст используется для запуска новых активити и взаимодействия с текущей активити.\r\n\r\nРабота с базой данных: Для работы с базой данных SQLite в приложении, вам потребуется контекст для инициализации объектов базы данных.\r\n\r\nСоздание и управление диалоговыми окнами: Контекст позволяет создавать диалоговые окна и взаимодействовать с ними.\r\n\r\nВажно отметить:\r\n\r\nКонтекст может быть утечкой памяти, если он используется неправильно. Например, хранение ссылки на контекст в статической переменной может привести к утечкам памяти. Используйте контекст аккуратно.\r\n\r\nПри работе с контекстом, удостоверьтесь, что он доступен и не является null, чтобы избежать ошибок в вашем приложении.\r\n\r\nКонтекст - это важный инструмент в разработке Android-приложений, который обеспечивает доступ к ресурсам и службам, необходимым для создания полноценного приложения. Умение правильно использовать контекст является ключевым навыком для Android-разработчика.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(90,2,9,90,109,90,12,'rus','2023-11-01',NULL,'Использование контекста для доступа к ресурсам','Контекст (Context) в Android - это ключевой компонент, который позволяет вашему приложению получать доступ к различным ресурсам, таким как строки, изображения, макеты и другие данные. В этом уроке мы рассмотрим, как использовать контекст для доступа к ресурсам в вашем приложении.\r\n\r\nШаг 1: Подготовка ресурсов\r\n\r\nПрежде чем начать использовать контекст для доступа к ресурсам, удостоверьтесь, что ваши ресурсы правильно организованы в папке \"res\" вашего проекта. Например, строки хранятся в файле strings.xml, изображения в папке drawable, а макеты в папке layout.\r\n\r\nШаг 2: Получение доступа к ресурсам\r\n\r\nДля доступа к ресурсам используйте методы, предоставляемые контекстом.\r\n\r\nДля строк:\r\n','val context = applicationContext // Получить контекст приложения\r\nval stringResource = context.getString(R.string.my_string_resource)',NULL,'В этом примере мы использовали context.getString() для получения строки, определенной в ресурсах. Вы также можете использовать контекст активити или службы в зависимости от контекста выполнения.\r\n\r\nДля изображений:','val context = applicationContext\r\nval imageResource = ContextCompat.getDrawable(context, R.drawable.my_image)',NULL,'Здесь мы использовали ContextCompat.getDrawable() для получения объекта Drawable из папки drawable. Этот метод обеспечивает совместимость с различными версиями Android.\r\n\r\nДля макетов:','val context = applicationContext\r\nval layoutInflater = LayoutInflater.from(context)\r\nval view = layoutInflater.inflate(R.layout.my_layout, null)',NULL,'Мы использовали LayoutInflater и контекст, чтобы надуть макет my_layout и получить объект View, который можно добавить в ваш интерфейс.\r\n\r\nВажные моменты:\r\n\r\nУбедитесь, что контекст доступен и не равен null, прежде чем использовать его для доступа к ресурсам.\r\n\r\nКонтекст активити может быть использован для доступа к ресурсам, но будьте осторожны при передаче контекста между активностями, чтобы избежать утечек памяти.\r\n\r\nРесурсы помогают вам эффективно управлять различными аспектами вашего Android-приложения, обеспечивая доступ к данным, хранящимся в ресурсах.\r\n\r\nЗаключение\r\n\r\nИспользование контекста для доступа к ресурсам - это важный аспект разработки Android-приложений. Он позволяет вашему приложению быть более гибким и адаптированным к различным условиям выполнения, обеспечивая доступ к данным, хранящимся в ресурсах.\r\n Надеюсь, этот урок поможет вам лучше понять, как это работает в практике разработки Android-приложений.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(91,2,9,91,110,91,12,'rus','2023-11-01',NULL,'Использование контекста для запуска новой активити','Запуск новой активити (Activity) является распространенной задачей в Android-приложениях. Для этого вы используете контекст. В этом уроке мы рассмотрим, как использовать контекст для запуска новой активити.\r\n\r\nШаг 1: Создание новой активити\r\n\r\nПрежде всего, убедитесь, что у вас есть созданная активити, которую вы хотите запустить. Например, давайте предположим, что у вас есть активити с именем SecondActivity, которую вы хотите запустить.\r\n\r\nШаг 2: Использование контекста для запуска активити\r\n\r\nИспользуйте контекст для создания интента (Intent) и запуска новой активити. Вот как это делается:','val context = applicationContext // Получить контекст приложения (или используйте контекст активити)\r\nval intent = Intent(context, SecondActivity::class.java) // Создание интента для запуска SecondActivity\r\ncontext.startActivity(intent) // Запуск новой активити',NULL,'В этом примере мы получили контекст приложения (или вы можете использовать контекст активити, если это более подходит для вашей ситуации). Затем мы создали интент, указав, какую активити мы хотим запустить (SecondActivity). Наконец, мы вызвали метод startActivity() на контексте, чтобы запустить новую активити.\r\n\r\nВажные моменты:\r\n\r\nУбедитесь, что контекст доступен и не равен null, прежде чем использовать его для запуска активити.\r\n\r\nПомните, что контекст определяет контекст выполнения и может повлиять на поведение вашей активити.\r\n\r\nВы можете передавать данные между активити, используя интент, чтобы передать дополнительную информацию.\r\n\r\nЗаключение\r\n\r\nИспользование контекста для запуска новой активити - это важная часть разработки Android-приложений. Это позволяет вашему приложению переходить между разными экранами и предоставлять пользователю более богатый опыт. Надеюсь, этот урок поможет вам понять, как это делается в практике разработки Android-приложений.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(92,2,9,92,111,92,12,'rus','2023-11-01',NULL,'Использование контекста для создания диалоговых окон','Диалоговые окна (Dialogs) - это важный способ взаимодействия с пользователем в Android-приложениях. Для создания диалоговых окон используется контекст. В этом уроке мы рассмотрим, как использовать контекст для создания диалоговых окон.\r\n\r\nШаг 1: Подготовка контекста\r\n\r\nПрежде чем создать диалоговое окно, убедитесь, что у вас есть доступный контекст. Это может быть контекст приложения или контекст активити, в зависимости от вашей ситуации.\r\n\r\nШаг 2: Создание диалогового окна\r\n\r\nИспользуйте контекст для создания объекта диалогового окна. В Android существует несколько типов диалоговых окон, таких как AlertDialog, ProgressDialog и другие. Давайте рассмотрим создание AlertDialog, которое является одним из наиболее распространенных типов диалоговых окон.','val context = applicationContext // Получить контекст приложения (или используйте контекст активити)\r\nval alertDialogBuilder = AlertDialog.Builder(context) // Создание построителя диалогового окна\r\nalertDialogBuilder.setTitle(\"Заголовок диалога\")\r\nalertDialogBuilder.setMessage(\"Текст сообщения\")\r\nalertDialogBuilder.setPositiveButton(\"OK\") { dialog, which ->\r\n    // Обработчик нажатия на кнопку \"OK\"\r\n}\r\nval alertDialog = alertDialogBuilder.create() // Создание диалогового окна\r\nalertDialog.show() // Отображение диалогового окна',NULL,'В этом примере мы создали AlertDialog с заголовком, текстом сообщения и кнопкой \"OK\". Мы использовали контекст для создания диалогового окна и отобразили его на экране.\r\n\r\nВажные моменты:\r\n\r\nУбедитесь, что контекст доступен и не равен null, прежде чем использовать его для создания диалоговых окон.\r\n\r\nAlertDialog - это только один из типов диалоговых окон. В Android существует много других типов, таких как ProgressDialog, DatePickerDialog и другие, в зависимости от ваших потребностей.\r\n\r\nВы можете добавить обработчики событий для кнопок в диалоговом окне, чтобы реагировать на действия пользователя.\r\n\r\nЗаключение\r\n\r\nИспользование контекста для создания диалоговых окон - это важная часть разработки Android-приложений. Диалоговые окна предоставляют удобный способ взаимодействия с пользователем и передачи информации. Надеюсь, этот урок поможет вам лучше понять, как это делается в практике разработки Android-приложений.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(93,2,9,93,112,93,12,'rus','2023-11-01',NULL,'Обращение к системным службам через контекст','В Android вы можете обращаться к различным системным службам, таким как служба уведомлений, служба локации, служба доступности и другие, используя контекст вашего приложения. В этом уроке мы рассмотрим, как использовать контекст для взаимодействия с системными службами.\r\n\r\nШаг 1: Получение доступа к системной службе\r\n\r\nЧтобы обратиться к системной службе, вы должны сначала получить доступ к объекту этой службы, используя соответствующий менеджер службы. Для этого вам потребуется контекст приложения.\r\n\r\nПример: Получение доступа к службе уведомлений (NotificationManager):','val context = applicationContext // Получить контекст приложения (или используйте контекст активити)\r\nval notificationManager = context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager',NULL,'В этом примере мы получаем доступ к службе уведомлений, используя context.getSystemService(). Мы указываем константу Context.NOTIFICATION_SERVICE для получения объекта NotificationManager. Обратите внимание, что вам нужно будет выполнить приведение типов (as) к соответствующему менеджеру службы.\r\n\r\nШаг 2: Использование системной службы\r\n\r\nПосле получения доступа к объекту системной службы, вы можете использовать его для выполнения различных операций.\r\n\r\nПример: Отправка уведомления с помощью NotificationManager:','val notificationId = 1\r\nval notification = NotificationCompat.Builder(context, \"channel_id\")\r\n    .setContentTitle(\"Заголовок уведомления\")\r\n    .setContentText(\"Текст уведомления\")\r\n    .setSmallIcon(R.drawable.ic_notification)\r\n    .build()\r\n\r\nnotificationManager.notify(notificationId, notification)',NULL,'Здесь мы создаем уведомление с использованием NotificationCompat.Builder и отправляем его с помощью notificationManager.notify().\r\n\r\nВажные моменты:\r\n\r\nУбедитесь, что контекст доступен и не равен null, прежде чем использовать его для доступа к системным службам.\r\n\r\nИмена констант, используемых при вызове context.getSystemService(), зависят от типа службы, к которой вы обращаетесь. Например, Context.NOTIFICATION_SERVICE для службы уведомлений.\r\n\r\nРазличные системные службы имеют свои собственные методы и объекты, которые вы можете использовать в соответствии с их функциональностью.\r\n\r\nЗаключение\r\n\r\nОбращение к системным службам через контекст позволяет вам взаимодействовать с различными системными возможностями Android, такими как уведомления, локация, доступность и другие. Это полезный инструмент для создания более функциональных и мощных Android-приложений. Надеюсь, этот урок поможет вам лучше понять, как это делается в практике разработки Android-приложений.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(94,2,9,94,113,94,12,'rus','2023-11-01',NULL,'Осторожно с контекстом','Проблемы, связанные с неправильным использованием контекста:\r\n\r\nУтечки памяти: Один из наиболее распространенных недостатков - это утечки памяти. Если вы храните ссылки на контекст в статических переменных или долгоживущих объектах, это может привести к утечкам памяти, так как контекст остается в памяти даже после завершения активити или службы.\r\n\r\nActivity/Service Context: Контекст активити и контекст службы имеют свой собственный жизненный цикл, и если вы используете их за пределами этого цикла (например, после уничтожения активити), это может вызвать ошибки выполнения.\r\n\r\nПодтеки активити: Передача контекста между активити может привести к утечкам активити. Это может быть особенно проблематично, если вы передаете контекст в асинхронные задачи или потоки.\r\n\r\nКак избежать проблем с контекстом:\r\n\r\nИспользуйте приемлемый контекст: Всегда используйте наиболее подходящий контекст в зависимости от контекста выполнения. Например, используйте контекст активити внутри активити, а контекст приложения для долгоживущих объектов.\r\n\r\nНе храните контекст в статических переменных: Избегайте хранения контекста в статических полях или объектах, которые могут жить долго. Если нужно передавать контекст, делайте это осторожно и убедитесь, что контекст будет освобожден после завершения его использования.\r\n\r\nПонимайте жизненный цикл контекста: Если вы работаете с контекстом активити или службы, учтите их жизненный цикл и убедитесь, что вы не используете их после их уничтожения.\r\n\r\nИспользуйте Application Context: В некоторых случаях, где требуется контекст, но активити или служба не подходят, можно использовать контекст приложения (Application Context). Он имеет более долгий срок жизни и может избежать некоторых проблем с жизненным циклом.\r\n\r\nЗаключение\r\n\r\nКонтекст - мощный инструмент в Android, но он также требует осторожного и правильного использования. Соблюдение этих рекомендаций поможет вам избежать проблем с утечками памяти и некорректным поведением вашего приложения. Понимание жизненного цикла контекста и использование наиболее подходящего контекста в каждой ситуации сделает ваше приложение более стабильным и надежным.\r\n',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(95,2,10,95,114,95,13,'rus','2023-11-01',NULL,'=ListFragment и ListAdapter с объяснениями=','В этом уроке мы создадим ListFragment, который использует ListAdapter для отображения списка элементов. Мы также рассмотрим отличие ListAdapter от RecyclerView.Adapter.\r\n\r\n1. Создание макета элемента списка\r\n\r\nСначала мы создадим макет для отображения элементов списка. Создайте файл item_list_item.xml','##!-- reslayoutitem_list_item.xml --\r\n##layout xmlnsandroid=httpschemas.android.comapkresandroid\r\n    ##TextView\r\n        ##androidlayout_width=match_parent\r\n        ##androidlayout_height=wrap_content\r\n        ##androidtextSize=18sp\r\n        ##androidpadding=16dp\r\n        ##androidtextColor=@androidcolorblack\r\n        ##androidid=@+iditemTextView \r\n##layout',NULL,'Этот макет содержит TextView, который будет отображать текст элемента списка.\r\n\r\n2. Создание ListAdapter\r\n\r\nСоздадим адаптер с использованием ListAdapter.','##import android.view.LayoutInflater\r\n##import android.view.ViewGroup\r\n##import androidx.recyclerview.widget.DiffUtil\r\n##import androidx.recyclerview.widget.ListAdapter\r\n##import androidx.recyclerview.widget.RecyclerView\r\n##import com.example.yourapp.databinding.ItemListItemBinding\r\n\r\n##class ListAdapter  ListAdapterString, ListAdapter.ViewHolder(DiffCallback()) {\r\n\r\n    ##override fun ^^onCreateViewHolder^^(parent ViewGroup, viewType Int) ViewHolder {\r\n        ##val **binding** = ItemListItemBinding.inflate(LayoutInflater.from(parent.context), parent, false)\r\n        ##return ViewHolder(binding)\r\n    ##}\r\n\r\n    ##override fun ^^onBindViewHolder^^(holder ViewHolder, position Int) {\r\n        ##val **item** = getItem(position)\r\n        ##holder.bind(item)\r\n    ##}\r\n\r\n    ##class ViewHolder(private val binding ItemListItemBinding)  RecyclerView.ViewHolder(binding.root) {\r\n        ##fun ^^bind^^(item String) {\r\n            ##**binding**.itemTextView.text = item\r\n        ##}\r\n    ##}\r\n\r\n    ##private class DiffCallback  DiffUtil.ItemCallbackString() {\r\n        ##override fun ^^areItemsTheSame^^(oldItem String, newItem String) Boolean {\r\n            ##return oldItem == newItem\r\n        ##}\r\n\r\n        ##override fun ^^areContentsTheSame^^(oldItem String, newItem String) Boolean {\r\n            ##return oldItem == newItem\r\n        ##}\r\n    ##}\r\n##}',NULL,'ListAdapter автоматически определяет изменения в данных с помощью DiffUtil, что делает обновления списка более эффективными.\r\n\r\n3. Создание ListFragment\r\n\r\nТеперь создадим фрагмент, который будет отображать список элементов.','##import android.os.Bundle\r\n##import androidx.fragment.app.Fragment\r\n##import android.view.LayoutInflater\r\n##import android.view.View\r\n##import android.view.ViewGroup\r\n##import androidx.recyclerview.widget.LinearLayoutManager\r\n##import com.example.yourapp.databinding.FragmentListBinding\r\n\r\n##class ListFragment  Fragment() {\r\n\r\n    ##private var **binding** FragmentListBinding?=null\r\n    ##private val **itemsList** = listOf(Item 1, Item 2, Item 3, Item 4, Item 5)\r\n\r\n    ##override fun ^^onCreateView^^(\r\n        ##inflater LayoutInflater, container ViewGroup,\r\n        ##savedInstanceState Bundle\r\n    ##) View {\r\n        ##**binding** = FragmentListBinding.inflate(inflater, container, false)\r\n        ##return **binding**?.root\r\n    ##}\r\n\r\n    ##override fun ^^onViewCreated^^(view View, savedInstanceState Bundle) {\r\n        ##super.onViewCreated(view, savedInstanceState)\r\n\r\n        ##val **adapter** = ListAdapter()\r\n        ##**adapter**.submitList(itemsList)\r\n\r\n        ##**binding**?.recyclerView?.layoutManager = LinearLayoutManager(requireContext())\r\n        ##**binding**?.recyclerView?.**adapter** = adapter\r\n    ##}\r\n##}',NULL,'В этом фрагменте мы настраиваем ListAdapter, передавая ему список элементов.\r\n Мы также настраиваем RecyclerView для отображения элементов вертикально с помощью LinearLayoutManager.\r\n\r\nRecyclerView.Adapter и ListAdapter: Сравнение и различия\r\n\r\nВ этом разделе мы проведем сравнение между RecyclerView.Adapter и ListAdapter в Android, а также рассмотрим их основные отличия.\r\n\r\n1. Общее:\r\nОба RecyclerView.Adapter и ListAdapter являются частями Android SDK и предназначены для связывания данных с RecyclerView для отображения списков элементов.\r\n\r\n2. Основное назначение:\r\n\r\nRecyclerView.Adapter: Основное назначение этого класса - предоставление адаптера для RecyclerView для настройки элементов списка, их отображения и обработки событий.\r\nListAdapter: Это расширение RecyclerView.Adapter, созданное для упрощения обработки обновлений списка и автоматического обнаружения изменений в данных.\r\n3. Обновления списка:\r\n\r\nRecyclerView.Adapter: Для обновления списка требуется вызвать метод notifyDataSetChanged() для обновления всего списка. Вы должны вручную управлять обновлениями.\r\nListAdapter: Автоматически обнаруживает изменения данных с использованием DiffUtil, что позволяет более эффективно обновлять только изменившиеся элементы.\r\n4. DiffUtil:\r\n\r\nRecyclerView.Adapter: Вы можете использовать DiffUtil с RecyclerView.Adapter, чтобы обнаруживать изменения в данных. Однако вы должны реализовать эту логику самостоятельно.\r\nListAdapter: Встроенная поддержка DiffUtil, что упрощает автоматическое обнаружение и обработку изменений в данных.\r\n5. Методы:\r\n\r\nRecyclerView.Adapter: Требует переопределения методов onCreateViewHolder, onBindViewHolder и getItemCount для настройки и отображения элементов списка.\r\nListAdapter: Также требует переопределения этих методов, но также обязывает реализовать методы areItemsTheSame() и areContentsTheSame() в классе DiffCallback для обнаружения изменений в данных.\r\n6. Преимущества ListAdapter:\r\n\r\nListAdapter автоматически обрабатывает вставки, удаления и перемещения элементов, что упрощает обновление списка.\r\nsubmitList() метод ListAdapter позволяет передать новый список данных и автоматически применить изменения.\r\n7. Примечание:\r\nОба RecyclerView.Adapter и ListAdapter имеют свои применения в зависимости от требований вашего проекта. Если вы хотите упростить обновление списков и улучшить производительность, ListAdapter может быть хорошим выбором. Если вы хотите больше контроля над процессом обновления и необходимостью реализации сложной логики, RecyclerView.Adapter также может быть полезным.\r\n\r\nЗаключение:\r\nВыбор между RecyclerView.Adapter и ListAdapter зависит от ваших требований и уровня сложности вашего проекта. Если у вас есть необходимость в автоматическом обнаружении изменений в данных и более простом обновлении списков, ListAdapter может быть предпочтительным вариантом.\r\n',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(96,2,10,96,115,96,13,'rus','2023-11-01',NULL,'=RecyclerView и создание адаптеров=','1. Добавление зависимостей\r\n\r\nДобавляем библиотеку recyclerview, которая позволит использовать RecyclerView в нашем проекте.\r\nimplementation androidx.recyclerviewrecyclerview1.2.1\r\n\r\n2. Создание макета элемента списка\r\n\r\nПеред тем, как начать использовать RecyclerView, создайте макет, который будет представлять элемент списка. \r\nВам нужно создать XML-файл для макета элемента списка, например, item_task.xml.','##LinearLayout xmlnsandroid=httpschemas.android.comapkresandroid\r\n    ##androidlayout_width=match_parent\r\n    ##androidlayout_height=wrap_content\r\n    ##androidorientation=vertical\r\n    ##androidpadding=16dp\r\n\r\n    ##TextView\r\n        ##androidid=@+idtitleTextView\r\n        ##androidlayout_width=wrap_content\r\n        ##androidlayout_height=wrap_content\r\n        ##androidtextSize=18sp\r\n        ##androidtextStyle=bold \r\n\r\n    ##TextView\r\n        ##androidid=@+iddescriptionTextView\r\n        ##androidlayout_width=wrap_content\r\n        ##androidlayout_height=wrap_content\r\n        ##androidtextSize=14sp\r\n        ##androidtextColor=@androidcolordarker_gray \r\n\r\nLinearLayout',NULL,'Здесь мы создаем макет элемента списка, который будет состоять из двух TextView - для заголовка и описания.\r\n\r\n3. Создание адаптера\r\n\r\nСоздайте класс адаптера, который связывает данные с макетом элемента списка. Создайте файл с названием, например, TaskAdapter.kt.','##import android.view.LayoutInflater\r\n##import android.view.View\r\n##import android.view.ViewGroup\r\n##import android.widget.TextView\r\n##import androidx.recyclerview.widget.RecyclerView\r\n\r\n##class TaskAdapter(private val tasks ListTask) \r\n    ##RecyclerView.AdapterTaskAdapter.TaskViewHolder() {\r\n\r\n     Создаем ViewHolder, который будет содержать элементы макета\r\n    ##override fun ^^onCreateViewHolder^^(parent ViewGroup, viewType Int) TaskViewHolder {\r\n       ##val **binding** = ItemTaskBinding.inflate(LayoutInflater.from(parent.context), parent, false)\r\n        ##return TaskViewHolder(binding)\r\n    ##}\r\n\r\n     Привязываем данные к элементу списка\r\n    ##override fun ^^onBindViewHolder^^(holder TaskViewHolder, position Int) {\r\n        ##val **task** = tasks[position]\r\n        ##holder.bind(task)\r\n    ##}\r\n\r\n     Возвращаем количество элементов в списке\r\n    ##override fun ^^getItemCount^^() Int {\r\n        ##return **tasks**.size\r\n    }\r\n\r\n     ViewHolder, содержащий элементы макета\r\n    ##class TaskViewHolder(private val binding: ItemTaskBinding) : RecyclerView.ViewHolder(binding.root) {\r\n        ##fun ^^bind^^(task: Task) {\r\n            ##binding.titleTextView.text = task.title\r\n            ##binding.descriptionTextView.text = task.description\r\n        ##}\r\n    ##}\r\n##}',NULL,'Адаптер создает ViewHolder, который хранит элементы макета. Затем он привязывает данные к этим элементам в методе onBindViewHolder.\r\n\r\n4. Использование RecyclerView\r\n\r\nВ вашей активити или фрагменте, используйте RecyclerView для отображения списка. Например, в MainActivity.kt','##import android.os.Bundle\r\n##import androidx.appcompat.app.AppCompatActivity\r\n##import androidx.recyclerview.widget.LinearLayoutManager\r\n##import androidx.recyclerview.widget.RecyclerView\r\n\r\n##class MainActivity  AppCompatActivity() {\r\n ##private var **binding**: ActivityMainBinding? = null\r\n    ##private val **taskList** = listOf(\r\n        ##Task(Task 1, Description for Task 1),\r\n        ##Task(Task 2, Description for Task 2),\r\n        ##Task(Task 3, Description for Task 3)\r\n    ##)\r\n\r\n    ##override fun ^^onCreate^^(savedInstanceState Bundle) {\r\n        ##super.^^onCreate^^(savedInstanceState)\r\n        ##**binding** = ActivityMainBinding.inflate(layoutInflater)\r\n        ##val view = **binding**?.root\r\n        ##setContentView(view)\r\n         ##val **recyclerView** = **binding**?.recyclerView\r\n         Устанавливаем LayoutManager, который определяет, как элементы будут размещаться в списке\r\n        ##**recyclerView**?.layoutManager = LinearLayoutManager(this)\r\n        \r\n         Устанавливаем адаптер для RecyclerView\r\n        ##**recyclerView**?.adapter = TaskAdapter(taskList)\r\n##%%//Добавление элемента в список%%\r\n  ##binding?.addButton.setOnClickListener {\r\n            ##val **newTask** = Task(\"New Task\", \"Description for New Task\")\r\n            ##taskList.add(newTask)\r\n            ##taskAdapter.notifyItemInserted(taskList.size - 1)%%//вызывается notifyItemInserted, чтобы сообщить адаптеру о вставке нового элемента.%%\r\n        }\r\n##%%//Удаление элемента из списка:%%\r\n   ##**binding**?.deleteButton.setOnClickListener {\r\n            ##if (taskList.isNotEmpty()) {\r\n                ##val **removedTask** = taskList.removeAt(taskList.size - 1)\r\n                ##taskAdapter.notifyItemRemoved(taskList.size)%%//вызывается notifyItemRemoved, чтобы сообщить адаптеру об удалении элемента.%%\r\n            ##}\r\n        ##}\r\n##override fun ^^onDestroy^^() {\r\n        ##super.^^onDestroy^^()\r\n        ##**binding** = null\r\n    ##}\r\n##}',NULL,'Методы notify...\r\nВ Android существует несколько методов notify..., которые используются для уведомления адаптера о изменениях в данных, которые должны быть отображены в RecyclerView. Вот некоторые из наиболее часто используемых методов notify...:\r\n\r\nnotifyDataSetChanged():\r\nЭтот метод уведомляет адаптер о том, что все данные были изменены. Он приводит к полной перерисовке списка. Этот метод следует использовать, если вы хотите обновить все данные списка. Однако, он может быть затратным по ресурсам, так как перерисовывает весь список.\r\n\r\nnotifyItemChanged(int position):\r\nЭтот метод уведомляет адаптер о том, что элемент на определенной позиции был изменен. Это позволяет адаптеру обновить только этот элемент без перерисовки всего списка. Вызов этого метода может быть полезен, когда вы хотите обновить конкретный элемент в списке.\r\n\r\nnotifyItemInserted(int position):\r\nЭтот метод уведомляет адаптер о вставке нового элемента на определенной позиции. Он позволяет адаптеру обновить список с учетом добавленного элемента. Например, после вызова этого метода элемент вставляется на указанную позицию, а остальные элементы сдвигаются.\r\n\r\nnotifyItemRemoved(int position):\r\nЭтот метод уведомляет адаптер о удалении элемента на определенной позиции. После вызова этого метода элемент удаляется с указанной позиции, и остальные элементы сдвигаются.\r\n\r\nnotifyItemRangeChanged(int startPosition, int itemCount):\r\nЭтот метод уведомляет адаптер о том, что диапазон элементов был изменен, начиная с определенной позиции startPosition. Может быть полезным, когда несколько элементов в диапазоне были изменены.\r\n\r\nnotifyItemRangeInserted(int startPosition, int itemCount):\r\nЭтот метод уведомляет адаптер о вставке диапазона новых элементов, начиная с определенной позиции startPosition.\r\n\r\nnotifyItemRangeRemoved(int startPosition, int itemCount):\r\nЭтот метод уведомляет адаптер о удалении диапазона элементов, начиная с определенной позиции startPosition.\r\n\r\nКогда вы вносите изменения в данные, которые отображаются в RecyclerView, важно использовать соответствующий метод notify..., чтобы обновления были выполнены корректно и эффективно.\r\n Выбор метода зависит от того, какие данные вы изменяете и какие изменения нужно отразить на пользовательском интерфейсе.\r\n\r\nВ этом уроке мы создали RecyclerView для отображения списка элементов. Адаптер связывает данные с макетом элемента списка.\r\n Каждый элемент списка представлен в ViewHolder, который обновляется методом onBindViewHolder.\r\n Таким образом, мы получаем эффективное отображение списков в наших Android-приложениях.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(97,2,10,97,116,97,13,'rus','2023-11-01',NULL,' =DiffUtil в RecyclerView=','DiffUtil - это утилита в Android, предоставляющая удобный способ обновления списков в RecyclerView с оптимизированными анимациями. В этом уроке мы рассмотрим, как использовать DiffUtil для эффективного обновления данных в списке.\r\n\r\n1. Создание модели данных\r\n\r\nСоздайте модель данных, которая будет представлять элементы списка. Например, создайте класс Item','##data class Item(val id Long, val name String)',NULL,'2. Создание адаптера с использованием DiffUtil\r\n\r\nСоздайте адаптер, который будет использовать DiffUtil для обновления данных.\r\n Ваш адаптер должен наследоваться от RecyclerView.Adapter и принимать список типа ListItem.','##class ItemAdapter  RecyclerView.AdapterItemAdapter.ItemViewHolder() {\r\n\r\n    ##private var **items** = emptyListItem()\r\n\r\n     Метод для обновления списка\r\n      ##fun ^^updateItems^^(newItems: List<Item>) {\r\n        ##val diffResult = DiffUtil.calculateDiff(ItemDiffCallback(**items**, newItems))\r\n        ##**items**.clear()\r\n        ##**items**.addAll(newItems)\r\n        ##diffResult.dispatchUpdatesTo(this)\r\n    ##}\r\n\r\n    ##fun addItem(item: Item) {\r\n        ##val **updatedList** = items.toMutableList()\r\n        ##**updatedList**.add(item)\r\n        ##^^updateItems^^(**updatedList**)\r\n    ##}\r\n\r\n    ##fun ^^removeItem^^(position: Int) {\r\n        ##val **updatedList** = items.toMutableList()\r\n        ##**updatedList**.removeAt(position)\r\n        ##^^updateItems^^(**updatedList**)\r\n    ##}\r\n\r\n\r\n    ##override fun ^^onCreateViewHolder^^(parent ViewGroup, viewType Int) ItemViewHolder {\r\n         ##Создание ViewHolder\r\n    ##}\r\n\r\n    ##override fun ^^onBindViewHolder^^(holder ItemViewHolder, position Int) {\r\n         ##Привязка данных к ViewHolder\r\n    ##}\r\n\r\n    ##override fun ^^getItemCount^^() Int {\r\n        ##return **items**.size\r\n    ##}\r\n\r\n    ##inner class ItemViewHolder(itemView View)  RecyclerView.ViewHolder(itemView) {\r\n         ##Инициализация элементов интерфейса\r\n    ##}\r\n##}',NULL,'3. Создание DiffUtil.Callback\r\n\r\nСоздайте класс для реализации DiffUtil.Callback, который будет сравнивать старый и новый список и определять, какие элементы изменились, добавились или удалились.','##class ItemDiffCallback(private val **oldList** ListItem, private val **newList** ListItem) \r\n    ##DiffUtil.Callback() {\r\n\r\n    ##override fun ^^getOldListSize^^() Int {\r\n        ##return **oldList**.size\r\n    ##}\r\n\r\n    ##override fun ^^getNewListSize^^() Int {\r\n        ##return **newList**.size\r\n    ##}\r\n\r\n    ##override fun ^^areItemsTheSame^^(oldItemPosition Int, newItemPosition Int) Boolean {\r\n        ##return **oldList**[oldItemPosition].id == **newList**[newItemPosition].id\r\n    ##}\r\n\r\n    ##override fun ^^areContentsTheSame^^(oldItemPosition Int, newItemPosition Int) Boolean {\r\n        ##return **oldList**[oldItemPosition] == **newList**[newItemPosition]\r\n    ##}\r\n##}',NULL,'4. Использование адаптера и обновление данных\r\n\r\nИспользуйте ItemAdapter в вашей активности или фрагменте и вызывайте метод updateItems для обновления данных.','##class MainActivity  AppCompatActivity() {\r\n ##private var **binding**: ActivityMainBinding? = null\r\n  \r\n    ##private val **itemAdapter** = ItemAdapter()\r\n\r\n    ##override fun ^^onCreate^^(savedInstanceState Bundle) {\r\n        ##super.^^onCreate^^(savedInstanceState)\r\n         ##**binding** = ActivityMainBinding.inflate(layoutInflater)\r\n        ##setContentView(binding?.root)\r\n\r\n        ##val **addButton** = **binding**?.addButton\r\n        ##val **removeButton** = **binding**?.removeButton\r\n\r\n        ##binding?.recyclerView?.apply {\r\n            ##layoutManager = LinearLayoutManager(this@MainActivity)\r\n            ##adapter = itemAdapter\r\n        ##}\r\n\r\n        ##addButton?.setOnClickListener {\r\n            ##val **newItem** = Item(Random.nextLong(), \"New Item\")\r\n            ##itemAdapter.addItem(newItem)\r\n        ##}\r\n\r\n        ##removeButton?.setOnClickListener {\r\n            ##if (itemAdapter.itemCount > 0) {\r\n                ##itemAdapter.removeItem(itemAdapter.itemCount - 1)\r\n            ##}\r\n        ##}\r\n\r\n        ##val **initialItems** = listOf(\r\n            ##Item(1, \"Item 1\"),\r\n            ##Item(2, \"Item 2\"),\r\n            ##// Добавьте остальные элементы\r\n        ##)\r\n\r\n        ##itemAdapter.updateItems(initialItems)\r\n    ##}\r\n\r\n    ##override fun ^^onDestroy^^() {\r\n        ##super.^^onDestroy^^()\r\n        ##binding = null\r\n    ##}\r\n##}',NULL,'Заключение\r\n\r\nТеперь вы знаете, как использовать DiffUtil для оптимизированного обновления данных в RecyclerView.\r\n Это позволяет избежать перерисовки всего списка при изменении данных и создает плавные анимации при добавлении, изменении или удалении элементов.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(98,2,10,98,117,98,13,'rus','2023-11-01',NULL,'=Swipe-to-Refresh=','Swipe-to-Refresh (потягивание для обновления) - это популярная функция, которая позволяет пользователям обновлять содержимое списка, потягивая вниз экрана. \r\nВ этом уроке мы добавим Swipe-to-Refresh в Android-приложение.\r\n\r\n1. Создание макета\r\n\r\nСоздайте макет для вашей активности или фрагмента, включая SwipeRefreshLayout. Например, в макете activity_main.xml','##xml version=1.0 encoding=utf-8\r\n##androidx.constraintlayout.widget.ConstraintLayout xmlnsandroid=httpschemas.android.comapkresandroid\r\n    ##xmlnsapp=httpschemas.android.comapkres-auto\r\n    ##xmlnstools=httpschemas.android.comtools\r\n    ##androidlayout_width=match_parent\r\n    ##androidlayout_height=match_parent\r\n    ##toolscontext=.MainActivity\r\n\r\n    ##androidx.swiperefreshlayout.widget.SwipeRefreshLayout\r\n        ##androidid=@+idswipeRefreshLayout\r\n        ##androidlayout_width=match_parent\r\n        ##androidlayout_height=match_parent\r\n        ##applayout_constraintTop_toTopOf=parent\r\n        ##applayout_constraintBottom_toBottomOf=parent\r\n        ##applayout_constraintStart_toStartOf=parent\r\n        ##applayout_constraintEnd_toEndOf=parent\r\n\r\n        ##RecyclerView\r\n            ##androidid=@+idrecyclerView\r\n            ##androidlayout_width=match_parent\r\n            ##androidlayout_height=match_parent \r\n    ##androidx.swiperefreshlayout.widget.SwipeRefreshLayout\r\n##androidx.constraintlayout.widget.ConstraintLayout',NULL,'2. Код в активности или фрагменте\r\n\r\nВ вашей активности или фрагменте настройте SwipeRefreshLayout и добавьте обработчик обновления.\r\n В примере ниже мы предполагаем, что у вас уже есть адаптер для RecyclerView.','##import android.os.Bundle\r\n##import androidx.appcompat.app.AppCompatActivity\r\n##import androidx.recyclerview.widget.LinearLayoutManager\r\n##import androidx.recyclerview.widget.RecyclerView\r\n##import androidx.swiperefreshlayout.widget.SwipeRefreshLayout\r\n\r\n##class MainActivity : AppCompatActivity() {\r\n\r\n    ##private var **recyclerView**: RecyclerView? = null\r\n    ##private var **swipeRefreshLayout**: SwipeRefreshLayout? = null\r\n    ##private var **adapter**: MyAdapter? = null // Замените на свой адаптер\r\n    ##private val **itemList** = mutableListOf<String>() // Ваши данные\r\n\r\n    ##override fun ^^onCreate^^(savedInstanceState: Bundle?) {\r\n        ##super.^^onCreate^^(savedInstanceState)\r\n        ##setContentView(R.layout.activity_main)\r\n\r\n        ##**recyclerView** = findViewById(R.id.recyclerView)\r\n        ##**swipeRefreshLayout** = findViewById(R.id.swipeRefreshLayout)\r\n\r\n        ##%%// Инициализация адаптера и привязка его к RecyclerView%%\r\n        ##**adapter** = MyAdapter(**itemList**) // Замените на свой адаптер\r\n        ##**recyclerView**?.layoutManager = LinearLayoutManager(this)\r\n        ##**recyclerView**?.**adapter** = adapter\r\n\r\n        ##%%// Настройка обработчика Swipe-to-Refresh%%\r\n        ##**swipeRefreshLayout**?.setOnRefreshListener {\r\n            ##// Здесь выполняется код при потягивании для обновления\r\n            ##updateData() // Ваш метод обновления данных\r\n        ##}\r\n    ##}\r\n\r\n    ##%%// Метод для обновления данных%%\r\n    ##private fun ^^updateData^^() {\r\n        ##%%// Здесь выполните обновление данных%%\r\n        ##%%// Например, обновите список itemList и вызовите notifyDataSetChanged() у адаптера%%\r\n\r\n        ##%%// Завершите обновление и скройте индикатор обновления%%\r\n        ##**swipeRefreshLayout**?.isRefreshing = false\r\n    ##}\r\n##}',NULL,'3. Добавление зависимости\r\n\r\nУбедитесь, что у вас есть зависимость для SwipeRefreshLayout в файле build.gradle (Module app)','##dependencies {\r\n \r\n\r\n    ##implementation \'androidx.swiperefreshlayoutswiperefreshlayout1.1.0\'\r\n##}',NULL,'Заключение\r\n\r\nТеперь ваше приложение поддерживает Swipe-to-Refresh! Пользователи смогут потянуть список вниз для обновления данных.\r\n Обратите внимание, что вам необходимо настроить метод updateData() для обновления данных и скрыть индикатор обновления в конце обновления данных.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(99,2,10,99,118,99,13,'rus','2023-11-01',NULL,'=Выбор множества элементов в RecyclerView=','В этом уроке мы рассмотрим, как реализовать выбор множества элементов в RecyclerView, используя флажки.\r\n\r\n1. Создание макета\r\n\r\nСоздайте макет для вашей активности или фрагмента. Например, в макете activity_main.xml','##xml version=1.0 encoding=utf-8\r\n##androidx.constraintlayout.widget.ConstraintLayout xmlnsandroid=httpschemas.android.comapkresandroid\r\n    ##xmlnsapp=httpschemas.android.comapkres-auto\r\n    ##xmlnstools=httpschemas.android.comtools\r\n    ##androidlayout_width=match_parent\r\n    ##androidlayout_height=match_parent\r\n    ##toolscontext=.MainActivity\r\n\r\n    ##androidx.recyclerview.widget.RecyclerView\r\n        ##androidid=@+idrecyclerView\r\n        ##androidlayout_width=match_parent\r\n        ##androidlayout_height=match_parent \r\n\r\n    ##Button\r\n        ##androidid=@+idselectButton\r\n        ##androidlayout_width=wrap_content\r\n        ##androidlayout_height=wrap_content\r\n        ##androidtext=Select\r\n        ##applayout_constraintBottom_toBottomOf=parent\r\n        ##applayout_constraintEnd_toEndOf=parent\r\n        ##applayout_constraintStart_toStartOf=parent\r\n        ##androidlayout_marginBottom=16dp \r\n##androidx.constraintlayout.widget.ConstraintLayout',NULL,'2. Создание адаптера с выбором\r\n\r\nСоздайте адаптер для RecyclerView, который будет поддерживать выбор множества элементов.\r\n В примере ниже, предполагаем, что у вас есть класс Item для элементов списка.','##class SelectableItemAdapter(private val itemList ListItem) \r\n    ##RecyclerView.AdapterSelectableItemAdapter.ItemViewHolder() {\r\n\r\n    ##private val **selectedItems** = mutableSetOfItem()\r\n\r\n    ##override fun ^^onCreateViewHolder^^(parent ViewGroup, viewType Int) ItemViewHolder {\r\n        ##val **view** = LayoutInflater.from(parent.context).inflate(R.layout.item_layout, parent, false)\r\n        ##return ItemViewHolder(**view**)\r\n    ##}\r\n\r\n    ##override fun ^^onBindViewHolder^^(holder ItemViewHolder, position Int) {\r\n        ##val **item** = itemList[position]\r\n        ##val **isSelected** = selectedItems.contains(**item**)\r\n\r\n        ##holder.bind(**item**, **isSelected**)\r\n\r\n        ##%%// Настраиваем обработчик нажатия на элемент списка%%\r\n    ##holder.itemView.setOnClickListener {\r\n        ##if (isSelected) {\r\n            ##selectedItems.remove(**item**) %%// Убираем элемент из выбранных%%\r\n        ##} else {\r\n            ##selectedItems.add(**item**) %%// Добавляем элемент в выбранные%%\r\n        ##}\r\n        ##%%// Уведомляем адаптер об изменениях, чтобы обновить вид элемента%%\r\n        ##notifyItemChanged(position)\r\n    ##}\r\n    ##}\r\n\r\n    ##override fun ^^getItemCount^^() Int {\r\n        ##return itemList.size\r\n    ##}\r\n\r\n    ##inner class ItemViewHolder(itemView View)  RecyclerView.ViewHolder(itemView) {\r\n        ##fun ^^bind^^(item Item, isSelected Boolean) {\r\n        ##itemNameTextView.text = **item**.name\r\n        ##itemCheckBox.isChecked = **isSelected**\r\n\r\n        ##%%// Установка обработчика для флажка, чтобы пользователь мог выбирать элемент%%\r\n        ##itemCheckBox.setOnCheckedChangeListener { _, isChecked ->\r\n            ##if (isChecked) {\r\n                ##selectedItems.add(item)\r\n            ##} else {\r\n                ##selectedItems.remove(item)\r\n            ##}\r\n        ##}\r\n    ##}\r\n##}',NULL,'3. В активности\r\n\r\nВ вашей активности настройте RecyclerView и кнопку для выбора','##import android.os.Bundle\r\n##import androidx.appcompat.app.AppCompatActivity\r\n##import androidx.recyclerview.widget.LinearLayoutManager\r\n##import androidx.recyclerview.widget.RecyclerView\r\n##import com.example.yourapp.databinding.ActivityMainBinding %%// Замените на путь к вашему binding%%\r\n\r\n##class MainActivity : AppCompatActivity() {\r\n\r\n    ##private var **binding**: ActivityMainBinding? = null\r\n    ##private val **itemList** = mutableListOf<Item>() %%// Ваши данные%%\r\n\r\n    ##override fun ^^onCreate^^(savedInstanceState: Bundle?) {\r\n        ##super.^^onCreate^^(savedInstanceState)\r\n        ##binding = ActivityMainBinding.inflate(layoutInflater)\r\n        ##setContentView(**binding**?.root)\r\n\r\n        ##val **recyclerView** = binding?.recyclerView\r\n        ##val **selectButton** = binding?.selectButton\r\n\r\n        ##val adapter = SelectableItemAdapter(itemList)\r\n        ##recyclerView?.layoutManager = LinearLayoutManager(this)\r\n        ##recyclerView?.adapter = adapter\r\n\r\n        ##selectButton?.setOnClickListener {\r\n            ##val **selectedItems** = adapter.getSelectedItems()\r\n\r\n            ##for (item in selectedItems) {\r\n                ##Log.d(\"SelectedItems\", \"Selected item: ${item.name}\")\r\n            ##}\r\n\r\n            ##%%// Выполните здесь другие действия с выбранными элементами%%\r\n        ##}\r\n\r\n        ##%%// Здесь вы можете инициализировать itemList и добавить элементы%%\r\n        ##**itemList**.add(Item(\"Item 1\"))\r\n        ##**itemList**.add(Item(\"Item 2\"))\r\n        ##**itemList**.add(Item(\"Item 3\"))\r\n        ##%%// ... добавьте остальные элементы%%\r\n    ##}\r\n\r\n    ##override fun ^^onDestroy^^() {\r\n        ##super.^^onDestroy^^()\r\n        ##**binding** = null\r\n    ##}\r\n##}',NULL,'Заключение\r\n\r\nТеперь у вас есть реализация выбора множества элементов в RecyclerView с использованием флажков.\r\n Пользователи могут выбирать и снимать выбор с элементов списка, а затем выполнять какие-либо действия с выбранными элементами, например, отправлять их на сервер или выполнять другие операции.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(100,2,10,100,119,100,13,'rus','2023-11-01',NULL,'=Обработка пустых списков и ошибок в RecyclerView=\r\n','Часто в Android-приложениях возникают ситуации, когда списки данных могут быть пустыми или произойти ошибка при загрузке данных. В этом уроке мы рассмотрим, как обрабатывать такие сценарии в RecyclerView.\r\n\r\n1. Создание макета\r\n\r\nСоздайте макет для вашей активности или фрагмента. Например, в макете activity_main.xml','##xml version=1.0 encoding=utf-8\r\n##androidx.constraintlayout.widget.ConstraintLayout xmlnsandroid=httpschemas.android.comapkresandroid\r\n    ##xmlnsapp=httpschemas.android.comapkres-auto\r\n    ##xmlnstools=httpschemas.android.comtools\r\n    ##androidlayout_width=match_parent\r\n    ##androidlayout_height=match_parent\r\n    ##toolscontext=.MainActivity\r\n\r\n    ##androidx.recyclerview.widget.RecyclerView\r\n        ##androidid=@+idrecyclerView\r\n        ##androidlayout_width=match_parent\r\n        ##androidlayout_height=match_parent \r\n\r\n    ##TextView\r\n        ##androidid=@+idemptyTextView\r\n        ##androidlayout_width=wrap_content\r\n        ##androidlayout_height=wrap_content\r\n        ##androidtext=No items to display\r\n        ##androidvisibility=gone\r\n        ##applayout_constraintTop_toTopOf=parent\r\n        ##applayout_constraintBottom_toBottomOf=parent\r\n        ##applayout_constraintStart_toStartOf=parent\r\n        ##applayout_constraintEnd_toEndOf=parent \r\n\r\n    ##ProgressBar\r\n        ##androidid=@+idloadingProgressBar\r\n        ##androidlayout_width=wrap_content\r\n        ##androidlayout_height=wrap_content\r\n        ##androidvisibility=gone\r\n        ##applayout_constraintTop_toTopOf=parent\r\n        ##applayout_constraintBottom_toBottomOf=parent\r\n        ##applayout_constraintStart_toStartOf=parent\r\n        ##applayout_constraintEnd_toEndOf=parent \r\n##androidx.constraintlayout.widget.ConstraintLayout',NULL,'2. В активности\r\n\r\nВ вашей активности настройте RecyclerView, текстовые представления для обработки пустых списков и ошибок, а также индикатор загрузки','##import android.os.Bundle\r\n##import androidx.appcompat.app.AppCompatActivity\r\n##import androidx.recyclerview.widget.LinearLayoutManager\r\n##import androidx.recyclerview.widget.RecyclerView\r\n\r\n##class MainActivity  AppCompatActivity() {\r\n\r\n    ##private lateinit var **recyclerView** RecyclerView\r\n    ##private lateinit var **emptyTextView** TextView\r\n    ##private lateinit var **loadingProgressBar** ProgressBar\r\n    ##private lateinit var **adapter** MyAdapter  Замените на свой адаптер\r\n    ##private val **itemList** = mutableListOfItem()  Ваши данные\r\n\r\n    ##override fun ^^onCreate^^(savedInstanceState Bundle) {\r\n        ##super.^^onCreate^^(savedInstanceState)\r\n        ##setContentView(R.layout.activity_main)\r\n\r\n        ##**recyclerView** = findViewById(R.id.recyclerView)\r\n        ##**emptyTextView** = findViewById(R.id.emptyTextView)\r\n        ##**loadingProgressBar** = findViewById(R.id.loadingProgressBar)\r\n\r\n        ##**adapter** = MyAdapter(itemList)\r\n        ##**recyclerView**.layoutManager = LinearLayoutManager(this)\r\n        ##**recyclerView**.**adapter** = adapter\r\n\r\n         Инициализируйте itemList и добавьте элементы\r\n\r\n        ##showLoading()\r\n\r\n         Моделируем задержку загрузки данных\r\n        ##Handler(Looper.getMainLooper()).postDelayed({\r\n            ##if (itemList.isEmpty()) {\r\n                ##showEmptyList()\r\n            ##} else {\r\n                ##showList()\r\n            ##}\r\n        ##}, 2000)  Замените на фактическую загрузку данных\r\n    ##}\r\n\r\n    ##private fun ^^showLoading^^() {\r\n        ##**loadingProgressBar**.visibility = View.VISIBLE\r\n        ##**emptyTextView**.visibility = View.GONE\r\n        ##**recyclerView**.visibility = View.GONE\r\n    ##}\r\n\r\n    ##private fun ^^showEmptyList^^() {\r\n        ##**loadingProgressBar**.visibility = View.GONE\r\n        ##**emptyTextView**.visibility = View.VISIBLE\r\n        ##**recyclerView**.visibility = View.GONE\r\n    ##}\r\n\r\n    ##private fun ^^showList^^() {\r\n        ##**loadingProgressBar**.visibility = View.GONE\r\n        ##**emptyTextView**.visibility = View.GONE\r\n        ##**recyclerView**.visibility = View.VISIBLE\r\n    ##}\r\n##}',NULL,'Заключение\r\n\r\nТеперь у вас есть реализация обработки пустых списков и ошибок в RecyclerView. Вам предоставлены текстовые представления для отображения соответствующих сообщений, а также индикатор загрузки для сценариев, когда данные загружаются.\r\n Это улучшит пользовательский опыт в случаях, когда списки пусты или произошла ошибка при загрузке данных.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(101,2,11,101,120,101,14,'rus','2023-11-01',NULL,'Навигация','Давайте создадим пример переходов между фрагментами с использованием Navigation Component.\r\n Допустим, у нас есть два фрагмента: HomeFragment и DetailsFragment, и мы хотим осуществить переход с главного экрана на экран деталей.\r\n\r\n1.Навигация\r\nдобавляем навигацию в интерактиве.\r\nПосле чего мы видим как преобразовывется код:','<fragment\r\n        android:id=\"@+id/homeFragment\"\r\n        android:name=\"com.example.myapp.HomeFragment\"\r\n        android:label=\"Home\" >\r\n  <action\r\n        android:id=\"@+id/action_homeFragment_to_detailsFragment\"\r\n        app:destination=\"@id/detailsFragment\" />\r\n </fragment>\r\n<fragment\r\n        android:id=\"@+id/detailsFragment\"\r\n        android:name=\"com.example.myapp.DetailsFragment\"\r\n        android:label=\"Details\" >\r\n<action\r\n    android:id=\"@+id/action_detailsFragment_to_homeFragment\"\r\n    app:destination=\"@id/homeFragment\" />\r\n </fragment>',NULL,'Тут мы добавили навигацию с homeFragment в detailsFragment и наоборот \r\nДля реализации навигации пишем код: ','class HomeFragment : Fragment() {\r\n\r\n    private var binding: FragmentHomeBinding? = null\r\n\r\n    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {\r\n        _binding = FragmentHomeBinding.inflate(inflater, container, false)\r\n        return binding.root\r\n    }\r\n\r\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\r\n        super.onViewCreated(view, savedInstanceState)\r\n\r\n        binding.navigateButton.setOnClickListener {\r\n            val action = HomeFragmentDirections.actionHomeFragmentToDetailsFragment(123)\r\n            findNavController().navigate(action)\r\n        }\r\n    }\r\n\r\n    override fun onDestroyView() {\r\n        super.onDestroyView()\r\n        binding = null\r\n    }\r\n}\r\nclass DetailsFragment : Fragment() {\r\n\r\n    private var binding: FragmentDetailsBinding? = null\r\n\r\n    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {\r\n        _binding = FragmentDetailsBinding.inflate(inflater, container, false)\r\n        return binding.root\r\n    }\r\n\r\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\r\n        super.onViewCreated(view, savedInstanceState)\r\n\r\n        binding.backButton.setOnClickListener {\r\n            navigateToHome()\r\n        }\r\n    }\r\n\r\n    override fun onDestroyView() {\r\n        super.onDestroyView()\r\n        binding = null\r\n    }\r\n\r\n    private fun navigateToHome() {\r\n        val action = DetailsFragmentDirections.actionDetailsFragmentToHomeFragment()\r\n        findNavController().navigate(action)\r\n    }\r\n}',NULL,'Класс Directions \r\nПри навигации мы используем классы, которые имеют названия фрагмента с добавлением Directions.\r\n Это класс, который автоматически генерируется в процессе компиляции при использовании Navigation Component.\r\n Он предоставляет безопасные и типобезопасные методы для создания действий (actions) и аргументов, связанных с переходами между фрагментами. \r\nВ этом уроке мы узнали, как реализовать навигацию, а в следующем мы рассмотрим, как передавать и получать различные данные',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(102,2,11,102,121,102,14,'rus','2023-11-01',NULL,'Bottom Navigation','Bottom Navigation - это паттерн навигации в Android-приложениях, который предоставляет пользователю доступ к основным разделам приложения через нижнюю навигационную панель.\r\n\r\n В этом уроке мы создадим Bottom Navigation с использованием Android Navigation Component.\r\n\r\nШаги для создания Bottom Navigation\r\n\r\n1. Создание Bottom Navigation Layout\r\n\r\nСначала создайте макет для Bottom Navigation. Добавьте в файл reslayout новый XML-файл, например, bottom_nav_layout.xml\r\n','xml version=1.0 encoding=utf-8\r\nandroidx.constraintlayout.widget.ConstraintLayout xmlnsandroid=httpschemas.android.comapkresandroid\r\n    xmlnsapp=httpschemas.android.comapkres-auto\r\n    xmlnstools=httpschemas.android.comtools\r\n    androidid=@+idcontainer\r\n    androidlayout_width=match_parent\r\n    androidlayout_height=match_parent\r\n    toolscontext=.MainActivity\r\n\r\n    !-- Основной контент приложения --\r\n    FrameLayout\r\n        androidid=@+idnavHostFragment\r\n        androidlayout_width=0dp\r\n        androidlayout_height=0dp\r\n        applayout_constraintBottom_toTopOf=@idbottomNavigationView\r\n        applayout_constraintTop_toTopOf=parent\r\n        applayout_constraintStart_toStartOf=parent\r\n        applayout_constraintEnd_toEndOf=parent \r\n\r\n    !-- Bottom Navigation --\r\n    com.google.android.material.bottomnavigation.BottomNavigationView\r\n        androidid=@+idbottomNavigationView\r\n        androidlayout_width=0dp\r\n        androidlayout_height=wrap_content\r\n        androidlayout_gravity=bottom\r\n        applayout_constraintBottom_toBottomOf=parent\r\n        applayout_constraintStart_toStartOf=parent\r\n        applayout_constraintEnd_toEndOf=parent\r\n        appmenu=@menubottom_nav_menu \r\n\r\nandroidx.constraintlayout.widget.ConstraintLayout',NULL,'2. Создание меню Bottom Navigation\r\n\r\nСоздайте меню для Bottom Navigation. В папке resmenu создайте XML-файл, например, bottom_nav_menu.xml, и добавьте пункты меню','menu xmlnsandroid=httpschemas.android.comapkresandroid\r\n    item\r\n        androidid=@+idnav_home\r\n        androidtitle=Home\r\n        androidicon=@drawableic_home \r\n    item\r\n        androidid=@+idnav_dashboard\r\n        androidtitle=Dashboard\r\n        androidicon=@drawableic_dashboard \r\n    item\r\n        androidid=@+idnav_notifications\r\n        androidtitle=Notifications\r\n        androidicon=@drawableic_notifications \r\nmenu',NULL,'3. Настройка Bottom Navigation в коде\r\n\r\nВ коде активити, где вы хотите добавить Bottom Navigation, настройте его\r\n','class MainActivity : AppCompatActivity() {\r\n\r\n    private var binding: BottomNavLayoutBinding? = null\r\n\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        binding = BottomNavLayoutBinding.inflate(layoutInflater)\r\n        setContentView(binding?.root)\r\n\r\n        val bottomNavigationView: BottomNavigationView? = binding?.bottomNavigationView\r\n\r\n        // Обработка нажатия на элементы Bottom Navigation\r\n        bottomNavigationView?.setOnNavigationItemSelectedListener { menuItem ->\r\n            when (menuItem.itemId) {\r\n                R.id.nav_home -> {\r\n                    showToast(\"Home clicked\")\r\n                    true\r\n                }\r\n                R.id.nav_dashboard -> {\r\n                    showToast(\"Dashboard clicked\")\r\n                    true\r\n                }\r\n                R.id.nav_notifications -> {\r\n                    showToast(\"Notifications clicked\")\r\n                    true\r\n                }\r\n                else -> false\r\n            }\r\n        }\r\n    }\r\n\r\n    private fun showToast(message: String) {\r\n        Toast.makeText(this, message, Toast.LENGTH_SHORT).show()\r\n    }\r\n\r\n    override fun onDestroy() {\r\n        super.onDestroy()\r\n        binding = null\r\n    }\r\n}',NULL,'Заключение\r\n\r\nСоздание Bottom Navigation с использованием Android Navigation Component делает навигацию в вашем приложении более удобной и интуитивной. Bottom Navigation позволяет быстро переключаться между различными разделами приложения, улучшая пользовательский опыт.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(103,2,11,103,122,103,14,'rus','2023-11-01',NULL,'BottomSheetDialogFragment','Bottom Sheet - это виджет, который обычно отображается снизу экрана и позволяет показать дополнительную информацию, опции или взаимодействие без необходимости перехода на новый экран. В этом уроке мы создадим Bottom Sheet с использованием Android BottomSheetDialogFragment.\r\n\r\nШаги для создания Bottom Sheet\r\n\r\n1. Создание Bottom Sheet Layout\r\n\r\nСначала создайте макет для Bottom Sheet. В файле reslayout добавьте новый XML-файл, например, bottom_sheet_layout.xml\r\n','LinearLayout xmlnsandroid=httpschemas.android.comapkresandroid\r\n    androidlayout_width=match_parent\r\n    androidlayout_height=wrap_content\r\n    androidorientation=vertical\r\n\r\n    !-- Контент Bottom Sheet --\r\n    TextView\r\n        androidlayout_width=match_parent\r\n        androidlayout_height=wrap_content\r\n        androidtext=Bottom Sheet Content\r\n        androidpadding=16dp\r\n        androidtextSize=18sp \r\n\r\n    !-- Дополнительные элементы, если нужно --\r\n\r\nLinearLayout',NULL,'2. Создание BottomSheetDialogFragment\r\n\r\nСоздайте класс для BottomSheetDialogFragment. Например, BottomSheetFragment.kt','class BottomSheetFragment  BottomSheetDialogFragment() {\r\n\r\n    override fun onCreateView(\r\n        inflater LayoutInflater, container ViewGroup,\r\n        savedInstanceState Bundle\r\n    ) View {\r\n        return inflater.inflate(R.layout.bottom_sheet_layout, container, false)\r\n    }\r\n}',NULL,'3. Отображение Bottom Sheet\r\n\r\nЧтобы отобразить Bottom Sheet, создайте экземпляр класса BottomSheetFragment и вызовите метод show\r\n','val bottomSheetFragment = BottomSheetFragment()\r\nbottomSheetFragment.show(supportFragmentManager, bottomSheetFragment.tag)',NULL,'Заключение\r\n\r\nСоздание Bottom Sheet с использованием Android BottomSheetDialogFragment позволяет легко добавлять дополнительные опции и информацию на экране без перехода на новый экран.\r\n Bottom Sheet обеспечивает удобное взаимодействие с пользователем и повышает удобство использования вашего приложения.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(104,2,11,104,123,104,14,'rus','2023-11-01',NULL,'Navigation Component','Navigation Component - это компонент, предоставляющий интуитивный и декларативный способ управления навигацией внутри приложения.\r\n Он помогает разработчикам упростить и улучшить управление переходами между разными экранами (фрагментами) и даже между различными активити.\r\n\r\nПреимущества Navigation Component:\r\n\r\nДекларативный подход: Navigation Component позволяет определить структуру навигации в виде графа в XML-файле, что делает код более понятным и легким для обслуживания.\r\n\r\nУпрощенная навигация: Он обеспечивает легкое управление навигацией между фрагментами и активити с использованием методов, таких как navigate().\r\n\r\nГлубокие ссылки: Navigation Component поддерживает глубокие ссылки, позволяя приложению открывать конкретный экран по определенному URL.\r\n\r\nАнимации и переходы: Он предоставляет встроенную поддержку анимаций и переходов между экранами.\r\n\r\nШаги для использования Navigation Component:\r\n\r\n1. Добавление зависимостей:\r\nДобавьте зависимости в файл build.gradle вашего модуля:\r\n','dependencies {\r\n    implementation \"androidx.navigation:navigation-fragment-ktx:2.4.0\"\r\n    implementation \"androidx.navigation:navigation-ui-ktx:2.4.0\"\r\n}',NULL,'2. Создание графа навигации:\r\nСоздайте XML-файл в папке res/navigation для определения структуры навигации. Например, nav_graph.xml:\r\nКак добавить фрагмент в nav_graph.xml.\r\nПосле того, как мы добавили фрагменты, мы можем увидеть код в nav_graph.xml:','<navigation xmlns:android=\"http://schemas.android.com/apk/res/android\"\r\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\r\n    app:startDestination=\"@id/homeFragment\">\r\n\r\n    <fragment\r\n        android:id=\"@+id/homeFragment\"\r\n        android:name=\"com.example.myapp.HomeFragment\"\r\n        android:label=\"Home\" />\r\n\r\n    <fragment\r\n        android:id=\"@+id/detailsFragment\"\r\n        android:name=\"com.example.myapp.DetailsFragment\"\r\n        android:label=\"Details\" />\r\n\r\n    <!-- Добавьте другие фрагменты и переходы по мере необходимости -->\r\n\r\n</navigation>',NULL,'3. Настройка навигации в активити:\r\nВ вашей активити добавьте NavHostFragment в макет:','<fragment\r\n    android:id=\"@+id/nav_host_fragment\"\r\n    android:name=\"androidx.navigation.fragment.NavHostFragment\"\r\n    android:layout_width=\"match_parent\"\r\n    android:layout_height=\"match_parent\"\r\n    app:navGraph=\"@navigation/nav_graph\" \r\n    app:defaultNavHost=\"true\" />',NULL,'Заключение:\r\n\r\nNavigation Component упрощает управление навигацией в Android-приложениях, предоставляя декларативный способ определения и управления переходами между экранами. \r\nЭто помогает улучшить читаемость кода, обеспечивает гибкость и удобство в разработке навигационной логики.\r\nВ следующем уроке мы рассмотрим, как реализовать навигацию между фрагментами.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(105,2,11,105,124,105,14,'rus','2023-11-01',NULL,'Navigation Drawer','Navigation Drawer - это популярный паттерн навигации в Android-приложениях, который позволяет открывать боковую панель с различными навигационными элементами. В этом уроке мы создадим Navigation Drawer с использованием Android Navigation Component.\r\n\r\nШаги для создания Navigation Drawer:\r\n\r\n1. Создание Navigation Drawer Layout:\r\n\r\nСначала создайте макет для Navigation Drawer. Добавьте в файл res/layout новый XML-файл, например, drawer_layout.xml:','<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<androidx.drawerlayout.widget.DrawerLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\r\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\r\n    xmlns:tools=\"http://schemas.android.com/tools\"\r\n    android:id=\"@+id/drawerLayout\"\r\n    android:layout_width=\"match_parent\"\r\n    android:layout_height=\"match_parent\"\r\n    android:fitsSystemWindows=\"true\"\r\n    tools:context=\".MainActivity\">\r\n\r\n    <!-- Основной контент приложения -->\r\n    <FrameLayout\r\n        android:id=\"@+id/navHostFragment\"\r\n        android:layout_width=\"match_parent\"\r\n        android:layout_height=\"match_parent\" >\r\n<Button\r\n    android:id=\"@+id/openDrawerButton\"\r\n    android:layout_width=\"wrap_content\"\r\n    android:layout_height=\"wrap_content\"\r\n    android:text=\"Open Drawer\"\r\n    android:layout_gravity=\"top\" />\r\n</<FrameLayout>\r\n\r\n    <!-- Боковая панель (NavigationView) -->\r\n    <com.google.android.material.navigation.NavigationView\r\n        android:id=\"@+id/navView\"\r\n        android:layout_width=\"wrap_content\"\r\n        android:layout_height=\"match_parent\"\r\n        android:layout_gravity=\"start\"\r\n        app:menu=\"@menu/nav_menu\" />\r\n\r\n</androidx.drawerlayout.widget.DrawerLayout>',NULL,'2. Создание меню Navigation Drawer:\r\n\r\nСоздайте меню для боковой панели. В папке res/menu создайте XML-файл, например, nav_menu.xml, и добавьте пункты меню:','<menu xmlns:android=\"http://schemas.android.com/apk/res/android\">\r\n    <group android:checkableBehavior=\"single\">\r\n        <item\r\n            android:id=\"@+id/nav_home\"\r\n            android:title=\"Home\" />\r\n        <item\r\n            android:id=\"@+id/nav_gallery\"\r\n            android:title=\"Gallery\" />\r\n        <item\r\n            android:id=\"@+id/nav_settings\"\r\n            android:title=\"Settings\" />\r\n    </group>\r\n</menu>',NULL,'3. Настройка Navigation Drawer в коде:\r\n\r\nВ коде активити, где вы хотите добавить Navigation Drawer, настройте его:','class MainActivity : AppCompatActivity() {\r\n\r\n    private var binding: DrawerLayoutBinding? = null\r\n\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        binding = DrawerLayoutBinding.inflate(layoutInflater)\r\n        setContentView(binding?.root)\r\n\r\n        val navController = findNavController(R.id.navHostFragment)\r\n        val navView: NavigationView? = binding?.navView\r\n\r\n        // Связываем NavigationView с NavController\r\n        navView?.setupWithNavController(navController)\r\n\r\n        // Добавляем обработчик для кнопки открытия Navigation Drawer\r\n        binding?.openDrawerButton?.setOnClickListener {\r\n            binding?.drawerLayout?.openDrawer(GravityCompat.START)\r\n        }\r\n\r\n        // Обработка нажатия на элементы Navigation Drawer\r\n        navView?.setNavigationItemSelectedListener { menuItem ->\r\n            when (menuItem.itemId) {\r\n                R.id.nav_home -> {\r\n                    showToast(\"Home clicked\")\r\n                    true\r\n                }\r\n                R.id.nav_gallery -> {\r\n                    showToast(\"Gallery clicked\")\r\n                    true\r\n                }\r\n                R.id.nav_settings -> {\r\n                    showToast(\"Settings clicked\")\r\n                    true\r\n                }\r\n                else -> false\r\n            }\r\n        }\r\n    }\r\n\r\n    private fun showToast(message: String) {\r\n        Toast.makeText(this, message, Toast.LENGTH_SHORT).show()\r\n    }\r\n\r\n    override fun onDestroy() {\r\n        super.onDestroy()\r\n        binding = null\r\n    }\r\n}',NULL,'Заключение:\r\n\r\nСоздание Navigation Drawer с использованием Android Navigation Component позволяет удобно организовать боковую навигацию в вашем приложении.\r\n Navigation Drawer позволяет пользователям переходить между различными разделами приложения, что делает навигацию более удобной и интуитивной.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(106,2,11,106,125,106,14,'rus','2023-11-01',NULL,'Custom Transition Animations','Android Navigation Component позволяет создавать пользовательские анимации переходов между фрагментами, что делает навигацию в приложении более интересной и привлекательной.\r\n В этом уроке мы создадим пользовательскую анимацию перехода между фрагментами с использованием Android Navigation Component.\r\n\r\nШаги для создания пользовательской анимации перехода:\r\n\r\n1. Создание анимаций:\r\n\r\nСначала создайте анимационные ресурсы для входящего и исходящего фрагментов. В папке res/anim создайте два XML-файла: slide_in.xml и slide_out.xml.\r\n\r\nslide_in.xml - анимация для входящего фрагмента (например, справа налево):','<set xmlns:android=\"http://schemas.android.com/apk/res/android\">\r\n    <translate\r\n        android:fromXDelta=\"100%p\"\r\n        android:toXDelta=\"0\"\r\n        android:duration=\"300\" />\r\n</set>',NULL,'slide_out.xml - анимация для исходящего фрагмента (например, слева направо):','<set xmlns:android=\"http://schemas.android.com/apk/res/android\">\r\n    <translate\r\n        android:fromXDelta=\"0\"\r\n        android:toXDelta=\"-100%p\"\r\n        android:duration=\"300\" />\r\n</set>',NULL,'2. Настройка анимаций в графе навигации:\r\n\r\nВ вашем графе навигации (например, в файле res/navigation/nav_graph.xml) добавьте атрибуты enterAnim и exitAnim для каждого перехода, указав анимацию, которую вы хотите использовать:','<fragment\r\n    android:id=\"@+id/firstFragment\"\r\n    android:name=\"com.example.myapp.FirstFragment\"\r\n    android:label=\"First Fragment\">\r\n    <action\r\n        android:id=\"@+id/action_firstFragment_to_secondFragment\"\r\n        app:destination=\"@id/secondFragment\"\r\n        app:enterAnim=\"@anim/slide_in\"\r\n        app:exitAnim=\"@anim/slide_out\" />\r\n</fragment>',NULL,'3. Запуск перехода:\r\n\r\nВ коде вашего фрагмента, где вы инициируете переход, используйте navigate для выполнения перехода между фрагментами:\r\n','class FirstFragment : Fragment() {\r\n\r\n    // ...\r\n\r\n    fun navigateToSecondFragment() {\r\n        val action = FirstFragmentDirections.actionFirstFragmentToSecondFragment()\r\n        findNavController().navigate(action)\r\n    }\r\n}',NULL,'Заключение:\r\n\r\nСоздание пользовательских анимаций переходов с использованием Android Navigation Component помогает сделать навигацию в вашем приложении более привлекательной и стильной. \r\nВы можете экспериментировать с различными анимациями и настроить их в соответствии с дизайном вашего приложения.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(107,2,11,107,126,107,14,'rus','2023-11-01',NULL,'Safe Args','Safe Args - это библиотека Android, предоставляющая безопасный и типобезопасный способ передачи аргументов между различными экранами (фрагментами) при использовании Navigation Component.\r\n Она устраняет необходимость вручную преобразовывать аргументы и позволяет избежать ошибок типов данных.\r\n\r\nНавигация :\r\n\r\nШаги для использования Safe Args\r\n\r\n1. Добавление плагина\r\n\r\nВ build.gradle добавьте плагин Safe Args','plugins {\r\n    id \'androidx.navigation.safeargs.kotlin\'\r\n}',NULL,'2. Передача аргументов\r\nДобавляем аргумент.\r\nПосле чего видим изменение кода в xml:','fragment\r\n    androidid=@+iddetailsFragment\r\n    androidname=com.example.myapp.DetailsFragment\r\n    androidlabel=Details\r\n    argument\r\n        androidname=itemId\r\n        appargType=integer \r\nfragment',NULL,'В коде отправляющего фрагмента используйте Safe Args для создания объекта DetailsFragmentArgs и передачи аргументов','val itemId=1\r\nval action = HomeFragmentDirections.actionHomeFragmentToDetailsFragment(itemId)\r\nfindNavController().navigate(action)',NULL,'3. Получение аргументов\r\n\r\nВ коде получающего фрагмента используйте DetailsFragmentArgs для получения аргументов','val args DetailsFragmentArgs by navArgs()\r\nval itemId = args.itemId//1',NULL,'Примечание:\r\nДля того чтобы в функции actionHomeFragmentToDetailsFragment у вас появился параметр itemId, вам нужно сначала пробилдить проект.\r\nЗаключение\r\n\r\nSafe Args -это удобный и безопасный способ передачи аргументов между экранами при использовании Navigation Component. \r\nОн автоматически генерирует классы для работы с аргументами, что упрощает код и снижает риск ошибок. ',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(108,2,12,108,127,108,15,'rus','2023-11-01',NULL,'Введение в Retrofit','Retrofit - это библиотека для работы с сетевыми запросами в Android-приложениях. Она упрощает взаимодействие с веб-серверами, обработку HTTP-запросов и ответов, а также преобразование данных между форматами (например, JSON). В этом уроке мы рассмотрим основы работы с Retrofit и как интегрировать ее в ваше Android-приложение.\r\n\r\nШаг 1: Подключение Retrofit\r\nДобавьте зависимость Retrofit в файл build.gradle вашего приложения:\r\ngradle','implementation \'com.squareup.retrofit2:retrofit:2.9.0\'',NULL,'Добавьте конвертер для преобразования JSON-данных (например, Gson):','implementation \'com.squareup.retrofit2:converter-gson:2.9.0\'',NULL,'(По желанию) Добавьте логгер для легкого отслеживания запросов и ответов:','implementation \'com.squareup.okhttp3:logging-interceptor:5.0.0\'',NULL,'Создайте интерфейс, который описывает методы для ваших сетевых запросов. \r\nКаждый метод должен быть аннотирован аннотацией @GET, @POST, и т. д., в зависимости от типа запроса.\r\n\r\nПример:','interface ApiService {\r\n    @GET(\"posts\")\r\n    suspend fun getPosts(): List<Post>\r\n}',NULL,'Шаг 3: Создание экземпляра Retrofit\r\nСоздайте экземпляр Retrofit, указав базовый URL вашего API и конвертер данных.\r\n\r\nПример:','val retrofit = Retrofit.Builder()\r\n    .baseUrl(\"https://api.example.com/\")//Ваша ссылка на сервер\r\n    .addConverterFactory(GsonConverterFactory.create())\r\n    .build()',NULL,'Шаг 4: Создание экземпляра API-сервиса\r\nСоздайте экземпляр вашего интерфейса API, используя созданный ранее Retrofit-экземпляр.\r\n\r\nПример:','val apiService = retrofit.create(ApiService::class.java)',NULL,'Шаг 5: Выполнение сетевого запроса\r\nИспользуйте методы вашего API-сервиса для выполнения сетевых запросов. \r\nRetrofit позволяет выполнять запросы асинхронно или с использованием корутин.\r\n\r\nПример (с корутинами):','viewModelScope.launch {\r\n    try {\r\n        val posts = apiService.getPosts()\r\n        // Обработка данных\r\n    } catch (e: Exception) {\r\n        // Обработка ошибок\r\n    }\r\n}',NULL,'Заключение\r\nRetrofit предоставляет мощный и гибкий способ взаимодействия с сетью в Android-приложениях. \r\nСледуя этому уроку, вы сможете подключить Retrofit к вашему проекту, создать интерфейс API, настроить экземпляр Retrofit, и выполнять сетевые запросы. \r\nЭто позволит вашему приложению взаимодействовать с внешними веб-сервисами и получать данные для отображения в приложении.',NULL,NULL,NULL,NULL,NULL,NULL,NULL),(109,2,12,109,128,109,15,'rus','2023-11-01',NULL,'Конвертация JSON в объекты','В этом уроке мы научимся конвертировать JSON-данные в объекты Kotlin, используя библиотеку Retrofit. Retrofit - это мощная библиотека для работы с HTTP-запросами и RESTful API, и она интегрируется удобно с библиотекой Gson для автоматической десериализации JSON-данных в объекты Kotlin.\r\n\r\nШаг 1: Добавление зависимостей\r\nСначала убедитесь, что вы добавили зависимости Gson и Retrofit в ваш проект. В файле build.gradle вашего проекта добавьте следующие зависимости:','dependencies {\r\n    implementation \'com.google.code.gson:gson:2.8.8\'\r\n    implementation \'com.squareup.retrofit2:retrofit:2.9.0\'\r\n    implementation \'com.squareup.retrofit2:converter-gson:2.9.0\'\r\n}',NULL,'После этого выполните синхронизацию проекта.\r\n\r\nШаг 2: Создание класса данных\r\nОпределите класс данных, который соответствует структуре JSON, которую вы планируете десериализовать. Например, предположим, что у нас есть следующая структура JSON для объекта \"Person\":','{\r\n    \"name\": \"Иван\",\r\n    \"age\": 30,\r\n    \"email\": \"ivan@example.com\"\r\n}',NULL,'Тогда класс данных может выглядеть так:','data class Person(\r\n    val name: String,\r\n    val age: Int,\r\n    val email: String\r\n)',NULL,'Шаг 3: Создание интерфейса API\r\nСоздайте интерфейс, который описывает методы для работы с вашим RESTful API. В этом интерфейсе вы будете использовать аннотации Retrofit для описания запросов.','import retrofit2.Call\r\nimport retrofit2.http.GET\r\n\r\ninterface MyApiService {\r\n    @GET(\"person\")\r\n    fun getPerson(): Call<Person>\r\n}',NULL,'Шаг 4: Создание объекта Retrofit\r\nСоздайте объект Retrofit с использованием Retrofit.Builder и настройте его, указав базовый URL и конвертер Gson.','import retrofit2.Retrofit\r\nimport retrofit2.converter.gson.GsonConverterFactory\r\n\r\nval retrofit = Retrofit.Builder()\r\n    .baseUrl(\"https://api.example.com/\")\r\n    .addConverterFactory(GsonConverterFactory.create())\r\n    .build()',NULL,'Шаг 5: Создание экземпляра службы API\r\nИспользуйте объект Retrofit для создания экземпляра вашего API-сервиса.','val apiService = retrofit.create(MyApiService::class.java)',NULL,'Шаг 6: Выполнение запроса\r\nИспользуйте методы вашего API-сервиса для выполнения запросов к серверу.\r\n Retrofit автоматически выполнит запрос, получит JSON-ответ и десериализирует его в объект Kotlin с использованием Gson.','val call = apiService.getPerson()\r\ncall.enqueue(object : Callback<Person> {\r\n    override fun onResponse(call: Call<Person>, response: Response<Person>) {\r\n        if (response.isSuccessful) {\r\n            val person = response.body()\r\n            if (person != null) {\r\n                // Десериализированный объект Kotlin\r\n                println(\"Имя: ${person.name}\")\r\n                println(\"Возраст: ${person.age}\")\r\n                println(\"Email: ${person.email}\")\r\n            }\r\n        }\r\n    }\r\n\r\n    override fun onFailure(call: Call<Person>, t: Throwable) {\r\n        // Обработка ошибки\r\n        println(\"Произошла ошибка при выполнении запроса: ${t.message}\")\r\n    }\r\n})',NULL,'В итоге, вы научились использовать Retrofit для конвертации JSON в объекты Kotlin. Убедитесь, что вы правильно настроили вашу службу API и обработали возможные ошибки.',NULL,NULL,NULL,NULL,NULL,NULL,NULL),(110,2,12,110,129,110,15,'rus','2023-11-01',NULL,'Отправка данных в теле запроса с Retrofit','В этом уроке мы рассмотрим, как отправлять данные в теле запроса (request body) с использованием библиотеки Retrofit в языке программирования Kotlin.\r\n Отправка данных в теле запроса широко используется при взаимодействии с RESTful API для создания, обновления и удаления ресурсов.\r\n\r\nШаг 1 Настройка зависимостей\r\nПрежде всего, убедитесь, что вы добавили зависимости Gson и Retrofit в ваш проект, как описано в предыдущих уроках.\r\n\r\nШаг 2 Создание интерфейса API\r\nСоздайте интерфейс, который описывает методы для работы с вашим RESTful API.\r\n В этом уроке мы будем использовать методы для создания и обновления ресурсов','import retrofit2.Call\r\nimport retrofit2.http.POST\r\nimport retrofit2.http.PUT\r\nimport retrofit2.http.Body\r\n\r\ninterface MyApiService {\r\n    @POST(\"person\")\r\n    fun createPerson(@Body person: Person): Call<Person>\r\n\r\n    @PUT(\"person/{id}\")\r\n    fun updatePerson(@Path(\"id\") id: Int, @Body person: Person): Call<Person>\r\n}',NULL,'В этом примере:\r\n\r\nМетод createPerson использует аннотацию @POST для отправки данных в теле запроса при создании нового \"person\".\r\nМетод updatePerson использует аннотацию @PUT для отправки данных в теле запроса при обновлении существующего \"person\".\r\nШаг 3: Создание объекта Retrofit\r\nСоздайте объект Retrofit, как обычно:','import retrofit2.Retrofit\r\nimport retrofit2.converter.gson.GsonConverterFactory\r\n\r\nval retrofit = Retrofit.Builder()\r\n    .baseUrl(\"https://api.example.com/\")\r\n    .addConverterFactory(GsonConverterFactory.create())\r\n    .build()',NULL,'Шаг 4: Создание экземпляра службы API\r\nСоздайте экземпляр вашего API-сервиса:','val apiService = retrofit.create(MyApiService::class.java)',NULL,'Шаг 5: Отправка данных в теле запроса при создании\r\nЧтобы отправить данные в теле запроса при создании нового ресурса, передайте объект, представляющий данный ресурс, в метод createPerson. Например:','val newPerson = Person(name = \"Новый Пользователь\", age = 25, email = \"new@example.com\")\r\nval call = apiService.createPerson(newPerson)\r\n\r\ncall.enqueue(object : Callback<Person> {\r\n    override fun onResponse(call: Call<Person>, response: Response<Person>) {\r\n        if (response.isSuccessful) {\r\n            val createdPerson = response.body()\r\n            if (createdPerson != null) {\r\n                // Обработка успешного ответа\r\n                println(\"Успешно создан пользователь с ID: ${createdPerson.id}\")\r\n            }\r\n        } else {\r\n            // Обработка неуспешного ответа\r\n            val errorCode = response.code()\r\n            println(\"Неуспешный ответ, код ошибки: $errorCode\")\r\n        }\r\n    }\r\n\r\n    override fun onFailure(call: Call<Person>, t: Throwable) {\r\n        // Обработка ошибки при выполнении запроса\r\n        println(\"Произошла ошибка при выполнении запроса: ${t.message}\")\r\n    }\r\n})',NULL,'Шаг 6: Отправка данных в теле запроса при обновлении\r\nДля отправки данных в теле запроса при обновлении ресурса, передайте идентификатор ресурса и объект с обновленными данными в метод updatePerson. Например:','val updatedPerson = Person(name = \"Обновленный Пользователь\", age = 30, email = \"updated@example.com\")\r\nval call = apiService.updatePerson(id = 123, person = updatedPerson)\r\n\r\ncall.enqueue(object : Callback<Person> {\r\n    override fun onResponse(call: Call<Person>, response: Response<Person>) {\r\n        if (response.isSuccessful) {\r\n            val updatedPerson = response.body()\r\n            if (updatedPerson != null) {\r\n                // Обработка успешного ответа\r\n                println(\"Успешно обновлен пользователь с ID: ${updatedPerson.id}\")\r\n            }\r\n        } else {\r\n            // Обработка неуспешного ответа\r\n            val errorCode = response.code()\r\n            println(\"Неуспешный ответ, код ошибки: $errorCode\")\r\n        }\r\n    }\r\n\r\n    override fun onFailure(call: Call<Person>, t: Throwable) {\r\n        // Обработка ошибки при выполнении запроса\r\n        println(\"Произошла ошибка при выполнении запроса: ${t.message}\")\r\n    }\r\n})',NULL,'В итоге, вы научились отправлять данные в теле запроса с библиотекой Retrofit в Kotlin. Это полезное умение при работе с RESTful API для создания и обновления ресурсов.\r\n Убедитесь, что вы правильно настроили вашу службу API и обработали возможные ошибки.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(111,2,12,111,130,111,15,'rus','2023-11-01',NULL,'Обработка ответов и ошибок ','В этом уроке мы рассмотрим, как правильно обрабатывать ответы и ошибки при работе с библиотекой Retrofit в языке программирования Kotlin. Retrofit - это мощная библиотека для выполнения HTTP-запросов и взаимодействия с RESTful API.\r\n\r\nШаг 1 Настройка зависимостей\r\nДля начала убедитесь, что вы добавили зависимости Gson и Retrofit в ваш проект. В файле build.gradle вашего проекта, добавьте следующие зависимости\r\n','dependencies {\r\n    implementation \'com.google.code.gson:gson:2.8.8\'\r\n    implementation \'com.squareup.retrofit2:retrofit:2.9.0\'\r\n    implementation \'com.squareup.retrofit2:converter-gson:2.9.0\'\r\n}',NULL,'После этого выполните синхронизацию проекта.\r\n\r\nШаг 2 Создание класса данных\r\nОпределите класс данных, который соответствует структуре JSON-ответа, который вы ожидаете от вашего RESTful API. Например, если ваш JSON-ответ представляет объект Person, класс данных может выглядеть так','data class Person(\r\n    val name: String,\r\n    val age: Int,\r\n    val email: String\r\n)',NULL,'Шаг 3 Создание интерфейса API\r\nСоздайте интерфейс, который описывает методы для работы с вашим RESTful API. Используйте аннотации Retrofit для описания запросов.','import retrofit2.Call\r\nimport retrofit2.http.GET\r\n\r\ninterface MyApiService {\r\n    @GET(\"person\")\r\n    fun getPerson(): Call<Person>\r\n}',NULL,'Шаг 4 Создание объекта Retrofit\r\nСоздайте объект Retrofit с использованием Retrofit.Builder и настройте его, указав базовый URL и конвертер Gson.','import retrofit2.Retrofit\r\nimport retrofit2.converter.gson.GsonConverterFactory\r\n\r\nval retrofit = Retrofit.Builder()\r\n    .baseUrl(\"https://api.example.com/\")\r\n    .addConverterFactory(GsonConverterFactory.create())\r\n    .build()',NULL,'Шаг 5: Создание экземпляра службы API\r\nИспользуйте объект Retrofit для создания экземпляра вашего API-сервиса.','val apiService = retrofit.create(MyApiService::class.java)',NULL,'Шаг 6: Выполнение запроса и обработка ответа\r\nВыполните запрос к серверу, используя методы вашего API-сервиса. Для обработки ответа, вы можете использовать метод enqueue и определить обработчики onResponse и onFailure.','val call = apiService.getPerson()\r\ncall.enqueue(object : Callback<Person> {\r\n    override fun onResponse(call: Call<Person>, response: Response<Person>) {\r\n        if (response.isSuccessful) {\r\n            val person = response.body()\r\n            if (person != null) {\r\n                // Обработка успешного ответа\r\n                println(\"Имя: ${person.name}\")\r\n                println(\"Возраст: ${person.age}\")\r\n                println(\"Email: ${person.email}\")\r\n            }\r\n        } else {\r\n            // Обработка неуспешного ответа (например, коды ошибок)\r\n            val errorCode = response.code()\r\n            println(\"Неуспешный ответ, код ошибки: $errorCode\")\r\n        }\r\n    }\r\n\r\n    override fun onFailure(call: Call<Person>, t: Throwable) {\r\n        // Обработка ошибки при выполнении запроса\r\n        println(\"Произошла ошибка при выполнении запроса: ${t.message}\")\r\n    }\r\n})',NULL,'В итоге, вы научились обрабатывать ответы и ошибки при работе с Retrofit. Убедитесь, что вы правильно настроили вашу службу API и обработали возможные ошибки.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(112,2,12,112,131,111,15,'rus','2023-10-31',NULL,'Использование Kotlin Coroutines с Retrofit','В этом уроке мы рассмотрим, как использовать Kotlin Coroutines с библиотекой Retrofit для выполнения асинхронных HTTP-запросов.\n\n=Настройка зависимостей=\n\nДля начала, убедитесь, что вы добавили зависимости Gson, Retrofit и библиотеку для работы с Kotlin Coroutines в ваш проект. В файле build.gradle вашего проекта, добавьте следующие зависимости\n','dependencies {\n    implementation \"com.google.code.gson:gson:2.8.8\"\n    implementation \"com.squareup.retrofit2:retrofit:2.9.0\"\n    implementation \"com.squareup.retrofit2:converter-gson:2.9.0\"\n    implementation \"org.jetbrains.kotlinx:kotlinx-coroutines-core:1.5.2\"\n    implementation \"org.jetbrains.kotlinx:kotlinx-coroutines-android:1.5.2\"\n}',NULL,'Затем выполните синхронизацию проекта.\n\n=Создание интерфейса API=\n\nСоздайте интерфейс, который описывает методы для работы с вашим RESTful API, как описано в предыдущих уроках.','import retrofit2.Call\nimport retrofit2.http.GET\n\ninterface MyApiService {\n    @GET(\"data\")\n    fun getData(): Call<Data>\n}',NULL,'=Создание объекта Retrofit с поддержкой Coroutines=\n\nДля использования Kotlin Coroutines с Retrofit, вам понадобится создать объект Retrofit и добавить адаптер для Coroutines.\n\n','import retrofit2.Retrofit\nimport retrofit2.converter.gson.GsonConverterFactory\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.runBlocking\nimport retrofit2.await\n\nval retrofit = Retrofit.Builder()\n    .baseUrl(\"https://api.example.com/\")\n    .addConverterFactory(GsonConverterFactory.create())\n    .build()\n\nval apiService = retrofit.create(MyApiService::class.java)',NULL,'=Выполнение асинхронного запроса с Coroutines=\n\nТеперь, для выполнения асинхронного запроса с Retrofit и Coroutines, используйте ключевое слово suspend. В этом примере, мы выполняем асинхронный запрос и обрабатываем результат:\n','import kotlinx.coroutines.launch\nimport kotlinx.coroutines.runBlocking\nimport retrofit2.await\n\nrunBlocking {\n    launch(Dispatchers.IO) {\n        try {\n            val response = apiService.getData().await()\n            if (response.isSuccessful) {\n                val data = response.body()\n                if (data != null) {\n                    // Обработка успешного ответа\n                    println(\"Данные: $data\")\n                }\n            } else {\n                // Обработка неуспешного ответа\n                val errorCode = response.code()\n                println(\"Неуспешный ответ, код ошибки: $errorCode\")\n            }\n        } catch (e: Exception) {\n            // Обработка ошибки\n            println(\"Произошла ошибка: ${e.message}\")\n        }\n    }\n}',NULL,'В этом примере мы использовали runBlocking и launch для выполнения запроса в корутине, и await для ожидания ответа от Retrofit.\n\nТеперь у вас есть полноценный асинхронный запрос с Retrofit и Kotlin Coroutines.\n\nЭто позволяет сделать асинхронные запросы более удобными и понятными, чем использование enqueue с обработчиками колбэков.\n Кроме того, Coroutines предоставляют удобные способы обработки ошибок и выполнения асинхронных операций.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(113,2,12,113,133,112,15,'rus','2023-10-31',NULL,'Загрузка файлов с Retrofit в Kotlin','В этом уроке мы рассмотрим, как использовать библиотеку Retrofit в языке программирования Kotlin для загрузки файлов с RESTful API. Загрузка файлов может включать в себя изображения, аудио, видео и другие типы данных.\n\n=Настройка зависимостей=\nПрежде всего, убедитесь, что вы добавили зависимости Gson и Retrofit в ваш проект, как описано в предыдущих уроках.\n\n=Создание интерфейса API=\nСоздайте интерфейс, который описывает методы для работы с вашим RESTful API. Для загрузки файла вам потребуется метод с аннотацией @Multipart.','import okhttp3.MultipartBody\nimport okhttp3.ResponseBody\nimport retrofit2.Call\nimport retrofit2.http.Multipart\nimport retrofit2.http.POST\nimport retrofit2.http.Part\n\ninterface MyApiService {\n    @Multipart\n    @POST(\"upload\")\n    fun uploadFile(@Part file: MultipartBody.Part): Call<ResponseBody>\n}',NULL,'В этом примере, метод uploadFile принимает MultipartBody.Part, который представляет файл для загрузки.\n\n=Создание объекта Retrofit=\nСоздайте объект Retrofit, как обычно:\n','import retrofit2.Retrofit\nimport retrofit2.converter.gson.GsonConverterFactory\n\nval retrofit = Retrofit.Builder()\n    .baseUrl(\"https://api.example.com/\")\n    .addConverterFactory(GsonConverterFactory.create())\n    .build()',NULL,'=Создание экземпляра службы API=\nСоздайте экземпляр вашего API-сервиса:\n','val apiService = retrofit.create(MyApiService::class.java)',NULL,'Загрузка файла\nДля загрузки файла, создайте MultipartBody.Part, который представляет файл, который вы хотите загрузить. Затем вызовите метод uploadFile вашего API-сервиса с этим объектом. Ниже приведен пример загрузки файла:\n','import okhttp3.MediaType\nimport okhttp3.MultipartBody\nimport okhttp3.RequestBody\nimport retrofit2.Callback\nimport retrofit2.Call\nimport retrofit2.Response\n\nval fileUri = \"путь_к_файлу\" // Замените на путь к вашему файлу\nval file = File(fileUri)\nval requestFile = RequestBody.create(MediaType.parse(\"multipart/form-data\"), file)\nval body = MultipartBody.Part.createFormData(\"file\", file.name, requestFile)\n\nval call = apiService.uploadFile(body)\n\ncall.enqueue(object : Callback<ResponseBody> {\n    override fun onResponse(call: Call<ResponseBody>, response: Response<ResponseBody>) {\n        if (response.isSuccessful) {\n            // Обработка успешной загрузки файла\n            println(\"Файл успешно загружен\")\n        } else {\n            // Обработка неуспешной загрузки\n            val errorCode = response.code()\n            println(\"Неуспешная загрузка, код ошибки: $errorCode\")\n        }\n    }\n\n    override fun onFailure(call: Call<ResponseBody>, t: Throwable) {\n        // Обработка ошибки при выполнении запроса\n        println(\"Произошла ошибка при загрузке файла: ${t.message}\")\n    }\n})',NULL,'Замените \"путь_к_файлу\" на путь к файлу, который вы хотите загрузить.\n=Заключение=\nВ итоге, вы научились загружать файлы с библиотекой Retrofit в Kotlin. Убедитесь, что вы правильно настроили вашу службу API и обработали возможные ошибки при загрузке.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(114,2,12,114,134,113,15,'rus','2023-10-31',NULL,'Использование Query-параметров и путей с Retrofit в Kotlin','В этом уроке мы рассмотрим, как использовать Query-параметры и пути (path parameters) при отправке HTTP-запросов с библиотекой Retrofit в языке программирования Kotlin.\n Query-параметры и пути часто используются при работе с RESTful API для передачи данных и фильтрации результатов.\n\n=Настройка зависимостей=\nПрежде всего, убедитесь, что вы добавили зависимости Gson и Retrofit в ваш проект, как описано в предыдущих уроках.\n\n=Создание интерфейса API=\nСоздайте интерфейс, который описывает методы для работы с вашим RESTful API. \nВ этом уроке мы будем использовать Query-параметры и пути для демонстрации\n','import retrofit2.Call\nimport retrofit2.http.GET\nimport retrofit2.http.Path\nimport retrofit2.http.Query\n\ninterface MyApiService {\n    @GET(\"persons\")\n    fun getPersons(@Query(\"age\") age: Int, @Query(\"gender\") gender: String): Call<List<Person>>\n\n    @GET(\"person/{id}\")\n    fun getPersonById(@Path(\"id\") id: Int): Call<Person>\n}',NULL,'=В этом примере:=\n\nМетод getPersons использует Query-параметры для фильтрации списка \"persons\" по возрасту и полу.\nМетод getPersonById использует путь (path parameter) для получения информации о конкретном \"person\" по его идентификатору.\n=Создание объекта Retrofit=\nСоздайте объект Retrofit, как обычно:','import retrofit2.Retrofit\nimport retrofit2.converter.gson.GsonConverterFactory\n\nval retrofit = Retrofit.Builder()\n    .baseUrl(\"https://api.example.com/\")\n    .addConverterFactory(GsonConverterFactory.create())\n    .build()',NULL,'=Создание экземпляра службы API=\nСоздайте экземпляр вашего API-сервиса:\n','val apiService = retrofit.create(MyApiService::class.java)',NULL,'=Выполнение запросов с Query-параметрами=\nДля выполнения запросов с Query-параметрами, передайте значения этих параметров в метод, как показано ниже:\n','val call = apiService.getPersons(age = 30, gender = \"male\")\ncall.enqueue(object : Callback<List<Person>> {\n    override fun onResponse(call: Call<List<Person>>, response: Response<List<Person>>) {\n        if (response.isSuccessful) {\n            val persons = response.body()\n            if (persons != null) {\n                for (person in persons) {\n                    // Обработка успешного ответа\n                    println(\"Имя: ${person.name}\")\n                    println(\"Возраст: ${person.age}\")\n                    println(\"Email: ${person.email}\")\n                }\n            }\n        } else {\n            // Обработка неуспешного ответа\n            val errorCode = response.code()\n            println(\"Неуспешный ответ, код ошибки: $errorCode\")\n        }\n    }\n\n    override fun onFailure(call: Call<List<Person>>, t: Throwable) {\n        // Обработка ошибки при выполнении запроса\n        println(\"Произошла ошибка при выполнении запроса: ${t.message}\")\n    }\n})',NULL,'=Выполнение запроса с путем=\nДля выполнения запроса с путем (path parameter), передайте значение этого параметра в метод:\n','val call = apiService.getPersonById(id = 123)\ncall.enqueue(object : Callback<Person> {\n    override fun onResponse(call: Call<Person>, response: Response<Person>) {\n        if (response.isSuccessful) {\n            val person = response.body()\n            if (person != null) {\n                // Обработка успешного ответа\n                println(\"Имя: ${person.name}\")\n                println(\"Возраст: ${person.age}\")\n                println(\"Email: ${person.email}\")\n            }\n        } else {\n            // Обработка неуспешного ответа\n            val errorCode = response.code()\n            println(\"Неуспешный ответ, код ошибки: $errorCode\")\n        }\n    }\n\n    override fun onFailure(call: Call<Person>, t: Throwable) {\n        // Обработка ошибки при выполнении запроса\n        println(\"Произошла ошибка при выполнении запроса: ${t.message}\")\n    }\n})',NULL,'В итоге, вы научились использовать Query-параметры и пути с библиотекой Retrofit в Kotlin. \nЭти инструменты позволяют взаимодействовать с RESTful API и получать данные с учетом фильтров и параметров. \nУбедитесь, что вы правильно настроили вашу службу API и обработали возможные ошибки.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(115,2,12,115,135,114,15,'rus','2023-10-31',NULL,'Кеширование и работа с кэшем в Retrofit с Kotlin','Кеширование позволяет сохранять и повторно использовать ответы от сервера, чтобы улучшить производительность и уменьшить нагрузку на сеть. В этом уроке мы рассмотрим, как настроить кеширование и работу с кэшем при использовании библиотеки Retrofit в языке программирования Kotlin.\n\n=Настройка зависимостей=\n\nПеред тем как начать, убедитесь, что вы добавили зависимости Gson и Retrofit в ваш проект, как описано в предыдущих уроках.\n\n=Создание объекта Retrofit с кэшированием=\nДля включения кеширования, вам нужно создать кэш и добавить его в объект Retrofit.','import okhttp3.Cache\nimport okhttp3.OkHttpClient\nimport retrofit2.Retrofit\nimport retrofit2.converter.gson.GsonConverterFactory\nimport java.io.File\n\nval cacheDir = File(\"путь_к_кэшу\") // Замените на путь к директории для кеширования\nval cacheSize = 10 * 1024 * 1024 // 10 МБ\n\nval cache = Cache(cacheDir, cacheSize.toLong())\n\nval retrofit = Retrofit.Builder()\n    .baseUrl(\"https://api.example.com/\")\n    .addConverterFactory(GsonConverterFactory.create())\n    .client(OkHttpClient.Builder()\n        .cache(cache)\n        .build())\n    .build()',NULL,'В этом примере мы создали кэш директории \"путь_к_кэшу\" и настроили его на 10 МБ. Замените путь к директории на желаемый путь к вашему кэшу.\n\n=Установка максимального возраста кеширования=\n\nЧтобы настроить максимальный возраст, на который ответы будут возвращаться из кэша, вы можете добавить интерцептор. В этом примере мы устанавливаем максимальный возраст в 30 секунд:\n','import okhttp3.CacheControl\nimport okhttp3.Interceptor\nimport okhttp3.Response\n\nval maxAge = 30\n\nval maxAgeInterceptor = Interceptor { chain ->\n    val originalResponse = chain.proceed(chain.request())\n    val cacheControl = CacheControl.Builder()\n        .maxAge(maxAge, TimeUnit.SECONDS)\n        .build()\n    originalResponse.newBuilder()\n        .header(\"Cache-Control\", cacheControl.toString())\n        .build()\n}\n\nval client = OkHttpClient.Builder()\n    .cache(cache)\n    .addNetworkInterceptor(maxAgeInterceptor)\n    .build()\n\nval retrofit = Retrofit.Builder()\n    .baseUrl(\"https://api.example.com/\")\n    .addConverterFactory(GsonConverterFactory.create())\n    .client(client)\n    .build()',NULL,'В этом примере мы создали интерцептор, который устанавливает максимальный возраст кеширования в 30 секунд.\n\n=Использование кеширования в запросах=\n\nТеперь, когда у вас есть настроенный кэш, Retrofit будет автоматически использовать его для кеширования ответов от сервера.\n По умолчанию, Retrofit будет кешировать ответы только при наличии заголовка Cache-Control от сервера.\n\nВы можете использовать методы addHeader(\"Cache-Control\", \"public, max-age=60\") для управления кешированием при отправке запроса:\n','import okhttp3.CacheControl\nimport okhttp3.Request\nimport retrofit2.Call\nimport retrofit2.Callback\nimport retrofit2.Response\n\nval apiService = retrofit.create(MyApiService::class.java)\nval request = apiService.getSomeData()\n    .request()\n    .newBuilder()\n    .cacheControl(CacheControl.Builder().maxAge(60, TimeUnit.SECONDS).build())\n    .build()\n\napiService.getSomeData(request).enqueue(object : Callback<Data> {\n    override fun onResponse(call: Call<Data>, response: Response<Data>) {\n        if (response.isSuccessful) {\n            val data = response.body()\n            if (data != null) {\n                // Обработка успешного ответа\n                println(\"Данные: $data\")\n            }\n        } else {\n            // Обработка неуспешного ответа\n            val errorCode = response.code()\n            println(\"Неуспешный ответ, код ошибки: $errorCode\")\n        }\n    }\n\n    override fun onFailure(call: Call<Data>, t: Throwable) {\n        // Обработка ошибки при выполнении запроса\n        println(\"Произошла ошибка при выполнении запроса: ${t.message}\")\n    }\n})',NULL,'В этом примере мы установили максимальный возраст кеширования в 60 секунд для данного запроса.\n\nТаким образом, вы научились использовать кеширование и работу с кэшем в Retrofit с Kotlin.\n Кеширование позволяет улучшить производительность и уменьшить нагрузку на сеть при выполнении запросов к серверу.\n\n',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(116,2,12,116,136,115,15,'rus','2023-10-31',NULL,'Тестирование с Retrofit в Kotlin','В этом уроке мы рассмотрим, как тестировать запросы, ответы и работу с библиотекой Retrofit в языке программирования Kotlin. Тестирование помогает убедиться, что ваш код взаимодействует с API корректно и обрабатывает различные сценарии.\n\n=Настройка зависимостей для тестирования=\n\nДля начала, убедитесь, что вы добавили библиотеки для тестирования в ваш проект. В файле build.gradle вашего проекта, добавьте следующие зависимости\n','dependencies {\n    testImplementation \"junit:junit:4.13.2\"\n    testImplementation \"org.mockito:mockito-core:3.11.2\"\n    testImplementation \"org.jetbrains.kotlinx:kotlinx-coroutines-test:1.5.2\"\n    androidTestImplementation \"androidx.test.ext:junit:1.1.3\"\n}',NULL,'Затем выполните синхронизацию проекта.\n\n=Создание заглушек для Retrofit=\n\nДля тестирования запросов и ответов Retrofit, создайте заглушки (mocks) для интерфейса API. Вы можете использовать библиотеку Mockito для этого.\n','import org.mockito.Mockito\nimport retrofit2.Call\nimport retrofit2.mock.Calls\n\nval apiServiceMock = Mockito.mock(MyApiService::class.java)',NULL,'Теперь у вас есть заглушка для вашего API-сервиса, которую вы можете использовать в тестах.\n\n=Написание тестов=\n\nТеперь вы можете написать тесты для запросов и обработки ответов. Например, если у вас есть метод для получения данных из API, вы можете написать тест следующим образом:\n','import kotlinx.coroutines.runBlocking\nimport org.junit.Test\nimport org.mockito.Mockito.`when`\nimport retrofit2.Response\n\n@Test\nfun testGetData() {\n    runBlocking {\n        // Создаем фейковые данные\n        val fakeData = Data(id = 1, name = \"Тестовые данные\")\n\n        // Создаем фейковый ответ\n        val fakeResponse = Response.success(fakeData)\n\n        // Устанавливаем, что при вызове метода getData() должен возвращаться fakeResponse\n        `when`(apiServiceMock.getData()).thenReturn(Calls.response(fakeResponse))\n\n        // Вызываем метод, который использует apiServiceMock\n        val result = myFunctionThatUsesApiService()\n\n        // Проверяем, что результат соответствует ожиданиям\n        assert(result == fakeData)\n    }\n}',NULL,'В этом примере мы создаем фейковый ответ и устанавливаем его для метода getData вашего заглушенного API-сервиса. Затем мы вызываем функцию, которая использует этот сервис, и проверяем, что результат соответствует ожиданиям.\n\n=Запуск тестов=\n\nТеперь вы можете запустить ваши тесты, чтобы убедиться, что ваш код взаимодействует с Retrofit корректно. В Android Studio, выберите \"Run\" -> \"Run Tests in YourTestClassName\" .\n\nТестирование помогает обнаружить и устранить ошибки и проблемы в вашем коде, связанные с взаимодействием с сервером и обработкой ответов.\n\nЭто основы тестирования с Retrofit в Kotlin. Для более сложных сценариев, вы можете использовать дополнительные библиотеки и практики, такие как тестирование с помощью стабов (stubs) и тестирование с помощью правил (rules) в Android.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(117,2,12,117,137,116,15,'rus','2023-10-31',NULL,'Интерцепторы и авторизация в Retrofit с Kotlin','В этом уроке мы рассмотрим, как использовать интерцепторы и реализовать авторизацию при работе с библиотекой Retrofit в языке программирования Kotlin. Интерцепторы позволяют манипулировать запросами и ответами, а авторизация позволяет выполнить защищенные запросы к RESTful API.\n\n=Настройка зависимостей=\nУбедитесь, что вы добавили зависимости Gson и Retrofit в ваш проект, как описано в предыдущих уроках.\n\n=Создание класса для авторизации=\nСоздайте класс для выполнения авторизации и генерации токена (например, Bearer Token), который будет использоваться при отправке защищенных запросов.\n ','class AuthInterceptor(private val authToken: String) : Interceptor {\n    override fun intercept(chain: Interceptor.Chain): Response {\n        val originalRequest = chain.request()\n        val authenticatedRequest = originalRequest.newBuilder()\n            .header(\"Authorization\", \"Bearer $authToken\")\n            .build()\n        return chain.proceed(authenticatedRequest)\n    }\n}',NULL,'В этом примере, AuthInterceptor принимает authToken и добавляет заголовок \"Authorization\" с токеном к исходному запросу.\n\n=Создание объекта Retrofit с интерцептором=\nСоздайте объект Retrofit и добавьте интерцептор, который будет использоваться для авторизации.','import retrofit2.Retrofit\nimport retrofit2.converter.gson.GsonConverterFactory\n\nval authToken = \"ваш_токен\" // Замените на ваш реальный токен\nval authInterceptor = AuthInterceptor(authToken)\n\nval retrofit = Retrofit.Builder()\n    .baseUrl(\"https://api.example.com/\")\n    .addConverterFactory(GsonConverterFactory.create())\n    .client(OkHttpClient.Builder().addInterceptor(authInterceptor).build())\n    .build()',NULL,'Замените \"ваш_токен\" на ваш реальный авторизационный токен.\n\n=Создание интерфейса API и выполнение защищенных запросов=\nСоздайте интерфейс API и методы для выполнения защищенных запросов, как описано в предыдущих уроках. Теперь Retrofit будет автоматически добавлять заголовок \"Authorization\" с вашим токеном к каждому запросу, выполненному через этот интерфейс.\n','import retrofit2.Call\nimport retrofit2.http.GET\n\ninterface MyApiService {\n    @GET(\"protected/resource\")\n    fun getProtectedResource(): Call<ResponseBody>\n}',NULL,'=Далее, выполните защищенный запрос, как показано в предыдущих уроках:=\n','val apiService = retrofit.create(MyApiService::class.java)\nval call = apiService.getProtectedResource()\n\ncall.enqueue(object : Callback<ResponseBody> {\n    override fun onResponse(call: Call<ResponseBody>, response: Response<ResponseBody>) {\n        if (response.isSuccessful) {\n            val responseBody = response.body()\n            if (responseBody != null) {\n                // Обработка успешного ответа\n                val data = responseBody.string()\n                println(\"Защищенный ресурс: $data\")\n            }\n        } else {\n            // Обработка неуспешного ответа\n            val errorCode = response.code()\n            println(\"Неуспешный ответ, код ошибки: $errorCode\")\n        }\n    }\n\n    override fun onFailure(call: Call<ResponseBody>, t: Throwable) {\n        // Обработка ошибки при выполнении запроса\n        println(\"Произошла ошибка при выполнении защищенного запроса: ${t.message}\")\n    }\n})',NULL,'Теперь вы научились использовать интерцепторы и авторизацию с библиотекой Retrofit в Kotlin. Интерцепторы могут быть использованы для различных целей, включая добавление заголовков, логирование и многие другие. \nУбедитесь, что вы правильно настроили интерцепторы и обработали возможные ошибки в вашем коде.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(118,2,13,118,138,117,16,'rus','2023-10-31',NULL,'Работа с галереей устройства','Работа с камерой устройства в Android позволяет вам создавать приложения, которые могут захватывать фотографии и видео непосредственно с камеры устройства. В этом уроке мы рассмотрим, как создать простое приложение для захвата фотографии с использованием камеры устройства.\r\n\r\nШаг 1: Добавление разрешений\r\n\r\nПрежде всего, убедитесь, что вы добавили необходимые разрешения в файле AndroidManifest.xml. Для работы с камерой вам понадобятся следующие разрешения:','<uses-permission android:name=\"android.permission.CAMERA\" />\r\n<uses-feature android:name=\"android.hardware.camera\" />\r\n<uses-feature android:name=\"android.hardware.camera.autofocus\" />',NULL,'Шаг 2: Создание макета\r\n\r\nСоздайте макет для вашей активности, включая кнопку, которая будет использоваться для запуска камеры и захвата фотографии. Например, создайте файл activity_main.xml с кнопкой:','<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\r\n    android:layout_width=\"match_parent\"\r\n    android:layout_height=\"match_parent\">\r\n\r\n    <Button\r\n        android:id=\"@+id/cameraButton\"\r\n        android:layout_width=\"wrap_content\"\r\n        android:layout_height=\"wrap_content\"\r\n        android:text=\"Сделать фото\"\r\n        android:layout_centerInParent=\"true\" />\r\n</RelativeLayout>',NULL,'Шаг 3: Написание кода для работы с камерой\r\n\r\nСоздайте активность и добавьте следующий код для работы с камерой:','import android.app.Activity\r\nimport android.content.Intent\r\nimport android.net.Uri\r\nimport android.os.Bundle\r\nimport android.provider.MediaStore\r\nimport android.widget.Button\r\nimport androidx.appcompat.app.AppCompatActivity\r\n\r\nclass MainActivity : AppCompatActivity() {\r\n\r\n    private val REQUEST_IMAGE_CAPTURE = 1\r\n\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        setContentView(R.layout.activity_main)\r\n\r\n        val cameraButton = findViewById<Button>(R.id.cameraButton)\r\n        cameraButton.setOnClickListener {\r\n            dispatchTakePictureIntent()\r\n        }\r\n    }\r\n\r\n    private fun dispatchTakePictureIntent() {\r\n        val takePictureIntent = Intent(MediaStore.ACTION_IMAGE_CAPTURE)\r\n        if (takePictureIntent.resolveActivity(packageManager) != null) {\r\n            startActivityForResult(takePictureIntent, REQUEST_IMAGE_CAPTURE)\r\n        }\r\n    }\r\n\r\n    override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {\r\n        if (requestCode == REQUEST_IMAGE_CAPTURE && resultCode == Activity.RESULT_OK) {\r\n            val imageUri: Uri? = data?.data\r\n            // Теперь у вас есть URI фотографии, которую вы можете использовать для отображения или сохранения\r\n        }\r\n    }\r\n}',NULL,'Когда пользователь нажимает на кнопку \"Сделать фото\", вызывается метод dispatchTakePictureIntent(), который запускает камеру устройства для захвата фотографии. Результат захвата фотографии будет обработан в методе onActivityResult(), где вы получите URI фотографии.\r\n\r\nЗаключение\r\n\r\nЭтот урок демонстрирует базовый способ работы с камерой устройства для захвата фотографий. Вы можете дополнить этот код, добавив функциональность для сохранения фотографии, обработки изображений и другие возможности в зависимости от ваших потребностей.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(119,2,13,119,139,118,16,'rus','2023-10-31',NULL,'Работа с камерой устройства','Работа с камерой устройства в Android позволяет вам создавать приложения, которые могут захватывать фотографии и видео непосредственно с камеры устройства. В этом уроке мы рассмотрим, как создать простое приложение для захвата фотографии с использованием камеры устройства.\r\n\r\nШаг 1: Добавление разрешений\r\n\r\nПрежде всего, убедитесь, что вы добавили необходимые разрешения в файле AndroidManifest.xml. Для работы с камерой вам понадобятся следующие разрешения:','<uses-permission android:name=\"android.permission.CAMERA\" />\r\n<uses-feature android:name=\"android.hardware.camera\" />\r\n<uses-feature android:name=\"android.hardware.camera.autofocus\" />',NULL,'Шаг 2: Создание макета\r\n\r\nСоздайте макет для вашей активности, включая кнопку, которая будет использоваться для запуска камеры и захвата фотографии. Например, создайте файл activity_main.xml с кнопкой:','<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\r\n    android:layout_width=\"match_parent\"\r\n    android:layout_height=\"match_parent\">\r\n\r\n    <Button\r\n        android:id=\"@+id/cameraButton\"\r\n        android:layout_width=\"wrap_content\"\r\n        android:layout_height=\"wrap_content\"\r\n        android:text=\"Сделать фото\"\r\n        android:layout_centerInParent=\"true\" />\r\n</RelativeLayout>',NULL,'Шаг 3: Написание кода для работы с камерой\r\n\r\nСоздайте активность и добавьте следующий код для работы с камерой:','import android.app.Activity\r\nimport android.content.Intent\r\nimport android.net.Uri\r\nimport android.os.Bundle\r\nimport android.provider.MediaStore\r\nimport android.widget.Button\r\nimport androidx.appcompat.app.AppCompatActivity\r\n\r\nclass MainActivity : AppCompatActivity() {\r\n\r\n    private val REQUEST_IMAGE_CAPTURE = 1\r\n\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        setContentView(R.layout.activity_main)\r\n\r\n        val cameraButton = findViewById<Button>(R.id.cameraButton)\r\n        cameraButton.setOnClickListener {\r\n            dispatchTakePictureIntent()\r\n        }\r\n    }\r\n\r\n    private fun dispatchTakePictureIntent() {\r\n        val takePictureIntent = Intent(MediaStore.ACTION_IMAGE_CAPTURE)\r\n        if (takePictureIntent.resolveActivity(packageManager) != null) {\r\n            startActivityForResult(takePictureIntent, REQUEST_IMAGE_CAPTURE)\r\n        }\r\n    }\r\n\r\n    override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {\r\n        if (requestCode == REQUEST_IMAGE_CAPTURE && resultCode == Activity.RESULT_OK) {\r\n            val imageUri: Uri? = data?.data\r\n            // Теперь у вас есть URI фотографии, которую вы можете использовать для отображения или сохранения\r\n        }\r\n    }\r\n}',NULL,'Когда пользователь нажимает на кнопку \"Сделать фото\", вызывается метод dispatchTakePictureIntent(), который запускает камеру устройства для захвата фотографии. Результат захвата фотографии будет обработан в методе onActivityResult(), где вы получите URI фотографии.\r\n\r\nЗаключение\r\n\r\nЭтот урок демонстрирует базовый способ работы с камерой устройства для захвата фотографий. Вы можете дополнить этот код, добавив функциональность для сохранения фотографии, обработки изображений и другие возможности в зависимости от ваших потребностей.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(120,2,13,120,140,119,16,'rus','2023-10-31',NULL,'Работа с форматами изображений\r\n','Работа с форматами изображений в Android позволяет вам выполнить разнообразные операции с изображениями, такие как конвертация, масштабирование, сжатие и другие. В этом уроке мы рассмотрим, как работать с форматами изображений в Android.\r\n\r\nШаг 1: Загрузка изображения\r\n\r\nДля начала нам понадобится изображение для работы. Вы можете загрузить изображение из ресурсов, с сервера или из другого источника. Для примера, предположим, что у вас есть изображение в ресурсах.\r\n\r\nШаг 2: Работа с изображением\r\n\r\nДля работы с изображением, вы можете использовать классы из библиотеки Android или сторонние библиотеки. Вот пример работы с изображением с использованием стандартных средств Android:','import android.graphics.Bitmap\r\nimport android.graphics.BitmapFactory\r\nimport android.os.Bundle\r\nimport androidx.appcompat.app.AppCompatActivity\r\nimport android.widget.ImageView\r\n\r\nclass MainActivity : AppCompatActivity() {\r\n\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        setContentView(R.layout.activity_main)\r\n\r\n        val imageView = findViewById<ImageView>(R.id.imageView)\r\n\r\n        // Загрузка изображения из ресурсов\r\n        val imageResId = R.drawable.sample_image\r\n        val bitmap = BitmapFactory.decodeResource(resources, imageResId)\r\n\r\n        // Отображение изображения в ImageView\r\n        imageView.setImageBitmap(bitmap)\r\n\r\n        // Можно также выполнить другие операции с изображением, например, масштабирование:\r\n        val scaledBitmap = Bitmap.createScaledBitmap(bitmap, newWidth, newHeight, true)\r\n    }\r\n}',NULL,'В этом коде мы загружаем изображение из ресурсов и отображаем его в ImageView. Вы также можете выполнить другие операции с изображением, такие как масштабирование или конвертацию в другие форматы.\r\n\r\nЗаключение\r\n\r\nРабота с форматами изображений в Android может включать в себя разнообразные операции, в зависимости от ваших потребностей. Важно помнить об оптимизации и управлении памятью при работе с изображениями, чтобы избежать утечек памяти. Android предоставляет множество инструментов для работы с изображениями, и вы можете также использовать сторонние библиотеки для более продвинутых задач.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(121,2,13,121,141,120,16,'rus','2023-10-31',NULL,'Загрузка фотографий из сети','Загрузка фотографий из сети - распространенная задача в разработке Android-приложений. В этом уроке мы рассмотрим, как загрузить и отобразить фотографии из сети в вашем Android-приложении с использованием библиотеки Glide.\r\n\r\nШаг 1: Добавление зависимостей\r\n\r\nПрежде всего, убедитесь, что вы добавили зависимость библиотеки Glide в файле build.gradle вашего приложения, как описано в предыдущем уроке.\r\n\r\nШаг 2: Создание макета\r\n\r\nСначала создайте макет для вашей активности или фрагмента, в котором будет отображаться фотография. Например, создайте файл activity_main.xml с ImageView для отображения фотографии:','<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\r\n    android:layout_width=\"match_parent\"\r\n    android:layout_height=\"match_parent\"\r\n    android:orientation=\"vertical\"\r\n    android:gravity=\"center\">\r\n\r\n    <ImageView\r\n        android:id=\"@+id/photoImageView\"\r\n        android:layout_width=\"200dp\"\r\n        android:layout_height=\"200dp\"\r\n        android:scaleType=\"centerCrop\"\r\n        android:src=\"@drawable/placeholder\" />\r\n</LinearLayout>',NULL,'Здесь @drawable/placeholder - это изображение, которое будет отображаться в ImageView во время загрузки фотографии.\r\n\r\nШаг 3: Загрузка и отображение фотографии\r\n\r\nТеперь создайте активность или фрагмент и добавьте следующий код для загрузки и отображения фотографии:\r\n','import android.os.Bundle\r\nimport androidx.appcompat.app.AppCompatActivity\r\nimport com.bumptech.glide.Glide\r\n\r\nclass MainActivity : AppCompatActivity() {\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        setContentView(R.layout.activity_main)\r\n\r\n        val photoImageView = findViewById<ImageView>(R.id.photoImageView)\r\n        val photoUrl = \"URL_ФОТОГРАФИИ\"\r\n\r\n        // Загрузка и отображение фотографии из сети\r\n        Glide.with(this)\r\n            .load(photoUrl)\r\n            .placeholder(R.drawable.placeholder)\r\n            .error(R.drawable.error)\r\n            .into(photoImageView)\r\n    }\r\n}',NULL,'Замените \"URL_ФОТОГРАФИИ\" на актуальный URL фотографии, которую вы хотите загрузить.\r\n\r\nPlaceholder и error изображения - это опциональные изображения, которые отображаются во время загрузки и при ошибке загрузки соответственно.\r\n\r\nТеперь, когда вы запустите приложение, оно загрузит фотографию из указанного URL и отобразит ее в ImageView.\r\n\r\nЗаключение\r\n\r\nЗагрузка фотографий из сети в Android - это распространенная задача, и библиотека Glide облегчает этот процесс. Она обеспечивает высокую производительность и поддержку кэширования изображений, делая процесс загрузки фотографий быстрым и эффективным. Надеюсь, этот урок поможет вам успешно реализовать загрузку фотографий в ваших Android-приложениях.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(122,2,13,122,142,121,16,'rus','2023-10-31',NULL,'Glide','Библиотека Glide - это мощный инструмент для загрузки и отображения изображений в Android-приложениях. В этом уроке мы рассмотрим, как использовать библиотеку Glide для этой задачи.\r\n\r\nШаг 1: Добавление зависимостей\r\n\r\nПрежде всего, убедитесь, что вы добавили зависимость библиотеки Glide в файле build.gradle вашего приложения:','implementation \'com.github.bumptech.glide:glide:4.12.0\'\r\nannotationProcessor \'com.github.bumptech.glide:compiler:4.12.0\'',NULL,'Шаг 2: Использование Glide\r\n\r\nТеперь давайте рассмотрим, как использовать библиотеку Glide для загрузки и отображения изображений:','import com.bumptech.glide.Glide\r\n\r\nval context = applicationContext // Получить контекст приложения (или используйте контекст активити)\r\nval imageView = findViewById<ImageView>(R.id.imageView) // Получите ссылку на ImageView\r\n\r\n// Загрузка и отображение изображения\r\nGlide.with(context)\r\n    .load(\"URL_ИЗОБРАЖЕНИЯ\")\r\n    .placeholder(R.drawable.placeholder) // Опционально: изображение, отображаемое во время загрузки\r\n    .error(R.drawable.error) // Опционально: изображение, отображаемое при ошибке загрузки\r\n    .into(imageView)',NULL,'В этом коде мы используем библиотеку Glide для загрузки изображения из указанного URL и отображения его в imageView. Мы также можем установить изображения для отображения во время загрузки и при ошибке, используя .placeholder() и .error().\r\n\r\nВажные моменты:\r\n\r\nУбедитесь, что контекст доступен и не равен null, прежде чем использовать его для загрузки изображений.\r\n\r\nЗамените \"URL_ИЗОБРАЖЕНИЯ\" на актуальный URL изображения, которое вы хотите загрузить.\r\n\r\nPlaceholder и error изображения являются опциональными и используются для улучшения пользовательского опыта при загрузке изображений.\r\n\r\nВы также можете настраивать Glide для выполнения других действий, таких как обрезка изображения или масштабирование. Подробности можно найти в документации Glide.\r\n\r\nЗаключение\r\n\r\nИспользование библиотеки Glide делает процесс загрузки и отображения изображений в Android-приложениях гораздо проще и эффективнее. Она обеспечивает автоматическое управление кэшированием и загрузкой изображений, а также предоставляет множество настроек для улучшения пользовательского опыта.\r\n Надеюсь, этот урок поможет вам успешно интегрировать Glide в ваши проекты Android.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(123,2,13,123,143,122,16,'rus','2023-10-31',NULL,'Picasso','Библиотека Picasso - это простой и мощный инструмент для загрузки и отображения изображений в Android-приложениях. В этом уроке мы рассмотрим, как использовать библиотеку Picasso для этой задачи.\r\n\r\nШаг 1: Добавление зависимостей\r\n\r\nПрежде всего, убедитесь, что вы добавили зависимость библиотеки Picasso в файле build.gradle вашего приложения:','implementation \'com.squareup.picasso:picasso:2.71828\'',NULL,'Шаг 2: Использование Picasso\r\n\r\nТеперь давайте рассмотрим, как использовать библиотеку Picasso для загрузки и отображения изображений:','import com.squareup.picasso.Picasso\r\n\r\nval context = applicationContext // Получить контекст приложения (или используйте контекст активити)\r\nval imageView = findViewById<ImageView>(R.id.imageView) // Получите ссылку на ImageView\r\n\r\n// Загрузка и отображение изображения\r\nPicasso.with(context)\r\n    .load(\"URL_ИЗОБРАЖЕНИЯ\")\r\n    .placeholder(R.drawable.placeholder) // Опционально: изображение, отображаемое во время загрузки\r\n    .error(R.drawable.error) // Опционально: изображение, отображаемое при ошибке загрузки\r\n    .into(imageView)',NULL,'В этом коде мы используем библиотеку Picasso для загрузки изображения из указанного URL и отображения его в imageView. Мы также можем установить изображения для отображения во время загрузки и при ошибке, используя .placeholder() и .error().\r\n\r\nВажные моменты:\r\n\r\nУбедитесь, что контекст доступен и не равен null, прежде чем использовать его для загрузки изображений.\r\n\r\nЗамените \"URL_ИЗОБРАЖЕНИЯ\" на актуальный URL изображения, которое вы хотите загрузить.\r\n\r\nPlaceholder и error изображения являются опциональными и используются для улучшения пользовательского опыта при загрузке изображений.\r\n\r\nВы также можете настраивать Picasso для выполнения других действий, таких как обрезка изображения или масштабирование. Подробности можно найти в документации Picasso.\r\n\r\nЗаключение\r\n\r\nИспользование библиотеки Picasso упрощает процесс загрузки и отображения изображений в Android-приложениях. Она предоставляет интуитивно понятный и легкий в использовании API, а также поддерживает кэширование изображений, что способствует улучшению производительности. Надеюсь, этот урок поможет вам успешно интегрировать Picasso в ваши проекты Android.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(124,2,13,124,144,123,16,'rus','2023-10-31',NULL,'Coil','Coil - это современная и компактная библиотека, разработанная с использованием языка Kotlin для загрузки и отображения изображений в Android-приложениях. В этом уроке мы рассмотрим, как использовать библиотеку Coil для этой задачи.\r\n\r\nШаг 1: Добавление зависимостей\r\n\r\nПрежде всего, убедитесь, что вы добавили зависимость библиотеки Coil в файле build.gradle вашего приложения:','implementation \'io.coil-kt:coil:1.5.1\'',NULL,'Шаг 2: Использование Coil\r\n\r\nТеперь давайте рассмотрим, как использовать библиотеку Coil для загрузки и отображения изображений:','import android.os.Bundle\r\nimport androidx.appcompat.app.AppCompatActivity\r\nimport coil.load\r\nimport kotlinx.android.synthetic.main.activity_main.*\r\n\r\nclass MainActivity : AppCompatActivity() {\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        setContentView(R.layout.activity_main)\r\n\r\n        // Загрузка и отображение изображения\r\n        val imageUrl = \"URL_ИЗОБРАЖЕНИЯ\"\r\n        imageView.load(imageUrl) {\r\n            placeholder(R.drawable.placeholder) // Опционально: изображение, отображаемое во время загрузки\r\n            error(R.drawable.error) // Опционально: изображение, отображаемое при ошибке загрузки\r\n        }\r\n    }\r\n}',NULL,'В этом коде мы используем библиотеку Coil для загрузки изображения из указанного URL и отображения его в imageView. Мы также можем установить изображения для отображения во время загрузки и при ошибке, используя .placeholder() и .error().\r\n\r\nВажные моменты:\r\n\r\nЗамените \"URL_ИЗОБРАЖЕНИЯ\" на актуальный URL изображения, которое вы хотите загрузить.\r\n\r\nPlaceholder и error изображения являются опциональными и используются для улучшения пользовательского опыта при загрузке изображений.\r\n\r\nБиблиотека Coil автоматически управляет кэшированием и другими деталями загрузки, что упрощает использование.\r\n\r\nЗаключение\r\n\r\nБиблиотека Coil предоставляет удобный и современный способ загрузки и отображения изображений в Android-приложениях. Она разработана с использованием языка Kotlin и предлагает простой и интуитивно понятный API. Coil также поддерживает различные форматы изображений, включая GIF и WebP, что делает ее полезной для оптимизации производительности и использования интернет-трафика.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(125,2,13,125,145,124,16,'rus','2023-10-31',NULL,'Выбор между библиотеками Glide, Picasso и Coil','Вот сравнение этих трех библиотек:\r\n\r\n1. Glide:\r\n\r\nПроизводительность: Glide славится своей производительностью и оптимизацией для загрузки и отображения изображений. Она имеет хорошую систему кэширования и загрузки.\r\n\r\nГибкость: Glide предоставляет множество настроек для настройки загрузки и отображения изображений, включая обрезку, масштабирование и анимации.\r\n\r\nУправление кэшированием: Одним из основных преимуществ Glide является его мощный механизм кэширования, который может кэшировать изображения как в памяти, так и на диске.\r\n\r\nАктивное сообщество: Glide имеет большое сообщество пользователей и активную поддержку.\r\n\r\n2. Picasso:\r\n\r\nПростота использования: Picasso предоставляет простой и интуитивно понятный API для загрузки и отображения изображений, что делает ее отличным выбором для начинающих разработчиков.\r\n\r\nКэширование: Picasso также поддерживает кэширование изображений в памяти и на диске.\r\n\r\nАвтоматическая отмена запросов: Picasso автоматически управляет отменой запросов при уничтожении активити или фрагмента, предотвращая утечки памяти.\r\n\r\n3. Coil:\r\n\r\nКомпактность: Coil - современная и компактная библиотека, разработанная с использованием Kotlin. Она предоставляет легковесную интеграцию с простым API.\r\n\r\nПоддержка GIF и WebP: Coil поддерживает разные форматы изображений, включая GIF и WebP, что полезно для оптимизации производительности и использования интернет-трафика.\r\n\r\nАктивное развитие: Coil продолжает развиваться и обновляться, учитывая современные технологии и требования.\r\n\r\nКакую выбрать?\r\n\r\nЕсли вам нужна максимальная производительность и большая гибкость настройки, Glide может быть хорошим выбором.\r\n\r\nЕсли вам нужна простота использования и вам не требуются многочисленные настройки, Picasso может быть подходящей библиотекой.\r\n\r\nЕсли вы хотите использовать современные Kotlin-ориентированные технологии и поддерживать разные форматы изображений, Coil может быть полезной.\r\n\r\nОбратите внимание, что каждая из библиотек обладает своими уникальными особенностями и преимуществами, поэтому выбор зависит от конкретных требований вашего проекта и ваших предпочтений.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(126,2,14,126,146,125,17,'rus','2023-10-31',NULL,'Что такое утечка памяти','В этом уроке мы рассмотрим, что такое утечка памяти (memory leak) в приложениях, почему она важна и как она может повлиять на производительность и стабильность вашего приложения.\r\n\r\nЧто такое утечка памяти:\r\n\r\nУтечка памяти - это ситуация, когда ваше приложение неправильно управляет памятью, и не используемые ресурсы или объекты продолжают занимать оперативную память устройства. Это может происходить, когда приложение создает объекты и не освобождает их, когда они больше не нужны.\r\n\r\nПочему утечка памяти важна:\r\n\r\nУтечка памяти может иметь серьезные последствия для вашего приложения:\r\n\r\nПадение приложения: Постепенное накопление утечек памяти может привести к увеличению использования оперативной памяти. В конечном итоге это может вызвать сбой приложения из-за нехватки памяти.\r\n\r\nУхудшение производительности: Приложение становится менее отзывчивым и медленным из-за избыточной нагрузки на систему и неэффективного использования ресурсов.\r\n\r\nОтрицательное влияние на жизненный цикл батареи: Утечка памяти может вызвать увеличенное использование энергии и, следовательно, укоротить время работы устройства от батареи.\r\n\r\nПлохой пользовательский опыт: Пользователи часто сталкиваются с зависаниями и падениями приложений из-за утечек, что создает негативное впечатление о качестве приложения.\r\nПримеры утечек памяти:\r\n\r\nВот некоторые примеры ситуаций, которые могут вызвать утечку памяти в приложении:\r\n\r\nСсылки на контекст: Ссылки на контекст (например, Activity или Context) могут привести к утечкам памяти, так как они могут удерживать ссылки на объекты, которые должны быть уничтожены.\r\n\r\nЗабытые ссылки на объекты: Если вы создаете объекты, но забываете их уничтожить, они будут продолжать занимать память.\r\n\r\nЦиклические зависимости: Когда объекты взаимно ссылкуются друг на друга, это может привести к невозможности сборки мусора и утечке памяти.\r\n\r\nПлохое управление ресурсами: Не закрытие ресурсов, таких как базы данных, сетевые соединения и файлы, может вызвать утечку памяти.\r\n\r\nКак бороться с утечками памяти:\r\n\r\nЧтобы предотвратить и бороться с утечками памяти, разработчики должны следить за правильным управлением жизненным циклом объектов, использовать слабые ссылки (Weak References), внимательно работать с ресурсами и использовать инструменты для обнаружения утечек.\r\n\r\nБорьба с утечками памяти - важная часть процесса разработки, и недопустимо игнорировать этот аспект, особенно при разработке мобильных приложений.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(127,2,14,127,147,126,17,'rus','2023-10-31',NULL,'Понимание сборки мусора','Сборка мусора (Garbage Collection) в языке программирования Kotlin аналогична сборке мусора в языке Java, так как Kotlin работает поверх Java Virtual Machine (JVM). В этом уроке мы рассмотрим, как работает сборка мусора в Kotlin и почему она важна.\r\n\r\nЧто такое сборка мусора в Kotlin\r\n\r\nСборка мусора в Kotlin - это процесс автоматического освобождения памяти, занятой объектами, которые больше не доступны для вашей программы. Это важная часть управления памятью в Kotlin и предотвращает утечки памяти.\r\nПочему сборка мусора важна:\r\n\r\nПредотвращение утечек памяти: Без сборки мусора, объекты, которые больше не нужны, могли бы накапливаться в памяти и вызвать утечки.\r\n\r\nУдобство разработки: Разработчикам не нужно вручную управлять памятью, что упрощает процесс разработки и снижает риск ошибок.\r\n\r\nУлучшение производительности: Эффективная сборка мусора помогает уменьшить фрагментацию памяти и повысить производительность программы.\r\n\r\nКак работает сборка мусора в Kotlin:\r\n\r\nОтслеживание ссылок: Система сборки мусора отслеживает все ссылки на объекты в программе.\r\n\r\nОпределение неиспользуемых объектов: Система сборки мусора определяет, какие объекты больше не доступны из программы. Это могут быть объекты, на которые больше нет ссылок, или объекты, которые недоступны из основного потока выполнения программы.\r\n\r\nСборка мусора: Когда система сборки мусора определяет, что объект больше не нужен, он удаляется, и память освобождается для будущего использования.\r\n\r\nПрименение вручную:\r\n\r\nВ Kotlin разработчики редко вмешиваются в процесс сборки мусора, так как он автоматизирован. Однако иногда можно использовать системные вызовы или API, чтобы дать подсказки сборщику мусора относительно времени сборки или явного запроса на сборку.\r\n\r\nЗаключение:\r\n\r\nСборка мусора - это важный аспект управления памятью в Kotlin. Понимание того, как она работает, и почему она важна, помогает создавать эффективные и стабильные приложения, освобождая разработчиков от необходимости вручную управлять памятью.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(128,2,14,128,148,127,17,'rus','2023-10-31',NULL,'Популярные источники утечек памяти',' Ссылки на контекст:\r\n\r\nОдин из наиболее распространенных источников утечек памяти в Android-приложениях - это удержание ссылок на контекст (Context). Если активность (Activity) или другой компонент приложения удерживает ссылку на контекст, это может привести к утечкам памяти. Чтобы избежать этой проблемы, используйте слабые ссылки (Weak References) или обращайтесь к контексту внимательно и обоснованно.\r\n\r\n2. Неосвобожденные ресурсы:\r\n\r\nЗабытые или неосвобожденные ресурсы, такие как сетевые соединения, файловые дескрипторы, базы данных и другие, могут вызвать утечки памяти. Важно всегда закрывать и освобождать ресурсы после их использования, используя блоки try-catch-finally или use для автоматического закрытия ресурсов.\r\n\r\n3. Зависимости жизненных циклов:\r\n\r\nЦиклические зависимости между объектами, такие как активности и фрагменты, могут вызвать утечки памяти. Объекты могут удерживать ссылки друг на друга, что препятствует сборке мусора. Для избегания этой проблемы используйте слабые ссылки или вручную управляйте жизненным циклом объектов.\r\n\r\n4. Ненужные слушатели и обработчики:\r\n\r\nНеудаленные слушатели и обработчики событий могут привести к утечкам памяти, так как объекты, которые зарегистрировались для прослушивания событий, могут оставаться в памяти, даже когда они больше не нужны. Важно правильно удалять слушателей при завершении их использования.\r\n\r\n5. Неосвобожденные ресурсы UI:\r\n\r\nИспользование графических ресурсов, таких как изображения и битмапы, требует аккуратного управления памятью. Если вы не освобождаете эти ресурсы, они могут вызвать утечки памяти. В Kotlin можно использовать WeakReference для хранения ссылок на UI-ресурсы, которые могут быть освобождены, когда они больше не нужны.\r\n\r\n6. Долгоживущие объекты:\r\n\r\nНекоторые объекты могут иметь долгий срок службы, и если они не уничтожаются или не освобождаются, они могут вызвать утечки памяти. Важно внимательно следить за долгоживущими объектами и убеждаться, что они правильно уничтожаются или очищаются после использования.\r\n\r\nЗаключение:\r\n\r\nИзбегание утечек памяти - важная часть разработки. Понимание популярных источников утечек памяти и использование правильных практик и инструментов для их предотвращения позволяют создавать стабильные и производительные приложения.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(129,2,14,129,149,128,17,'rus','2023-10-31',NULL,'Примеры утечек и их решения','В этом уроке мы рассмотрим несколько примеров типичных утечек памяти, с которыми можно столкнуться при разработке приложений на языке Kotlin, и предложим способы их решения.\r\n\r\nПример 1: Утечка памяти из-за ссылок на контекст:','class MyActivity : AppCompatActivity() {\r\n    private val someObject = SomeObject()\r\n\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        setContentView(R.layout.activity_main)\r\n        someObject.doSomethingWith(this)\r\n    }\r\n}',NULL,'В этом примере объект someObject хранит ссылку на активность MyActivity, что может вызвать утечку памяти.\r\n\r\nРешение 1:\r\n\r\nИспользуйте слабые ссылки (Weak References) для хранения ссылок на контекст и активности. Таким образом, сборщик мусора сможет уничтожить объект, когда он больше не нужен:','class MyActivity : AppCompatActivity() {\r\n    private val someObject = SomeObject(WeakReference(this))\r\n\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        setContentView(R.layout.activity_main)\r\n        someObject.doSomethingWith()\r\n    }\r\n}',NULL,'Пример 2: Утечка памяти из-за неосвобожденных ресурсов:','class DatabaseHelper(context: Context) {\r\n    private val database: SQLiteDatabase = context.openOrCreateDatabase(\"mydb\", Context.MODE_PRIVATE, null)\r\n    \r\n    fun insertData(data: String) {\r\n        // Вставка данных в базу данных\r\n    }\r\n}',NULL,'В этом примере база данных database не закрывается, что может вызвать утечку памяти.\r\n\r\nРешение 2:\r\n\r\nЗакройте ресурсы, когда они больше не нужны, например, в методе onDestroy активности:','class MyActivity : AppCompatActivity() {\r\n    private lateinit var databaseHelper: DatabaseHelper\r\n\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        setContentView(R.layout.activity_main)\r\n        databaseHelper = DatabaseHelper(this)\r\n    }\r\n\r\n    override fun onDestroy() {\r\n        databaseHelper.close()\r\n        super.onDestroy()\r\n    }\r\n}',NULL,'Пример 3: Утечка памяти из-за неудаленных слушателей:','class MyListener {\r\n    fun startListening(view: View) {\r\n        view.setOnClickListener {\r\n            // Обработка события\r\n        }\r\n    }\r\n}',NULL,'В этом примере слушатель OnClickListener привязан к представлению View, но он никогда не удаляется.\r\n\r\nРешение 3:\r\n\r\nУдалите слушатели, когда они больше не нужны, например, в методе onDestroy активности:','class MyActivity : AppCompatActivity() {\r\n    private val myListener = MyListener()\r\n\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        setContentView(R.layout.activity_main)\r\n        myListener.startListening(findViewById(R.id.myView))\r\n    }\r\n\r\n    override fun onDestroy() {\r\n        findViewById<View>(R.id.myView).setOnClickListener(null)\r\n        super.onDestroy()\r\n    }\r\n}',NULL,'Пример 4: Утечка памяти из-за долгоживущего объекта:','class LongLivedObject {\r\n    private val data = ByteArray(10 * 1024 * 1024) // Создание большого массива байт\r\n}',NULL,'В этом примере объект LongLivedObject создает большой массив байт, который остается в памяти.\r\n\r\nРешение 4:\r\n\r\nОсвобождайте ресурсы, когда они больше не нужны. В данном случае, LongLivedObject должен предоставить метод для освобождения массива байт при завершении его использования.','class LongLivedObject {\r\n    private val data = ByteArray(10 * 1024 * 1024) // Создание большого массива байт\r\n\r\n    fun releaseData() {\r\n        data = null\r\n    }\r\n}',NULL,'Заключение:\r\n\r\nУтечки памяти могут быть проблемой в приложениях на языке Kotlin, но они могут быть предотвращены и устранены с помощью правильного управления жизненным циклом объектов, закрытием ресурсов, удалением слушателей и уничтожением объектов при их завершении использования. \r\nВнимательное следование этим принципам поможет создавать стабильные и производительные приложения.',NULL,NULL,NULL,NULL),(130,2,14,130,150,129,17,'rus','2023-10-31',NULL,'Инструменты для обнаружения утечек памяти','1. LeakCanary:\r\n\r\nLeakCanary - это популярная библиотека для обнаружения утечек памяти в Android-приложениях. Она автоматически анализирует приложение и оповещает о любых обнаруженных утечках. LeakCanary интегрируется легко и предоставляет детальные отчеты о утечках.\r\n\r\n2. Android Profiler:\r\n\r\nAndroid Profiler - это инструмент, встроенный в Android Studio, предоставляющий информацию о производительности и использовании памяти. С помощью Android Profiler вы можете отслеживать изменения в использовании памяти в реальном времени и идентифицировать потенциальные утечки.\r\n\r\n3. Memory Profiler:\r\n\r\nMemory Profiler также доступен в Android Studio и предоставляет подробную информацию о использовании памяти вашим приложением. Вы можете анализировать кучу (heap), находить объекты, которые могут вызывать утечки, и следить за изменениями в памяти во времени.\r\n\r\n4. Allocation Tracker:\r\n\r\nAllocation Tracker - это инструмент Android Profiler, который позволяет отслеживать, какие объекты создаются и освобождаются во время выполнения приложения. Это может помочь выявить утечки памяти, связанные с созданием лишних объектов.\r\n\r\n5. MAT (Memory Analyzer Tool):\r\n\r\nMemory Analyzer Tool - это независимый инструмент для анализа памяти, который может использоваться для анализа дампов памяти, созданных Android приложением. Он предоставляет мощные инструменты для выявления утечек памяти и поиска источников проблем.\r\n\r\n6. HPROF:\r\n\r\nHPROF - это формат дампов памяти, который можно создавать в Android с помощью команды ADB или с использованием Android Studio. Получив HPROF-файл, вы можете анализировать его с помощью инструментов, таких как MAT или Android Profiler.\r\n\r\n7. Кастомные инструменты:\r\n\r\nИногда разработчики создают собственные инструменты и механизмы для обнаружения утечек памяти, такие как профилировщики или мониторинговые сервисы, адаптированные к их конкретным потребностям.\r\n\r\nЗаключение:\r\n\r\nИспользование инструментов для обнаружения утечек памяти - важный аспект разработки в языке Kotlin. Эти инструменты помогают выявлять и устранять проблемы с памятью, обеспечивая стабильную и производительную работу вашего приложения.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(131,2,14,131,151,130,17,'rus','2023-10-31',NULL,'Принципы устранения утечек памяти','В этом уроке мы рассмотрим принципы и лучшие практики для предотвращения и устранения утечек памяти.\r\n\r\n1. Правильное управление жизненным циклом объектов:\r\n\r\nУбедитесь, что объекты уничтожаются или очищаются, когда они больше не нужны. Это особенно важно для объектов, связанных с активностями, фрагментами и другими компонентами Android. Используйте методы жизненного цикла, такие как onDestroy или onDetach, для очистки ресурсов.\r\n\r\n2. Использование слабых ссылок (Weak References):\r\n\r\nВ Kotlin вы можете использовать слабые ссылки, такие как WeakReference, чтобы избежать утечек памяти. Слабые ссылки позволяют объектам быть собраны сборщиком мусора, даже если на них есть ссылки. Они особенно полезны для хранения ссылок на объекты, которые могут стать ненужными.','val weakReference = WeakReference<MyObject>(myObject)\r\nval retrievedObject = weakReference.get()',NULL,'3. Закрытие ресурсов:\r\n\r\nВнимательно управляйте ресурсами, такими как базы данных, сетевые соединения и файлы. Всегда закрывайте ресурсы после их использования. Для обеспечения правильного закрытия ресурсов используйте блоки try-catch-finally или use (для автоматического закрытия ресурсов).','val file = File(\"example.txt\")\r\ntry {\r\n    val input = FileInputStream(file)\r\n    // Используйте input\r\n} finally {\r\n    input.close()\r\n}',NULL,'4. Осторожное использование статических ссылок:\r\n\r\nСтатические ссылки могут долго удерживать объекты в памяти. Используйте их осторожно и убедитесь, что они обнуляются, когда объект больше не нужен. Особенно актуально это для ссылок на активности и контексты.\r\n\r\n5. Использование инструментов для обнаружения утечек:\r\n\r\nИспользуйте инструменты, такие как LeakCanary и Android Profiler, для обнаружения утечек памяти в вашем приложении. Они могут автоматически находить и предостерегать вас от потенциальных проблем.\r\n\r\n6. Тестирование:\r\n\r\nПроводите тестирование вашего приложения с целью выявления утечек памяти. Создавайте сценарии, которые могли бы вызвать утечки, и проверяйте, что ваше приложение правильно управляет памятью.\r\n\r\n7. Периодическая проверка кода:\r\n\r\nРегулярно проверяйте свой код на предмет утечек памяти, особенно при внесении изменений и добавлении новых функциональных возможностей. Оценивайте его под углом зрения правильного управления памятью.\r\n\r\n8. Используйте ресурсы разумно:\r\n\r\nИзбегайте загрузки больших объемов данных в память или создания большого количества объектов, если это необходимо. Оптимизируйте использование памяти и следите за производительностью вашего приложения.\r\n\r\nЗаключение:\r\n\r\nУстранение утечек памяти - важная часть разработки на Kotlin. Следуя правильным принципам и лучшим практикам, вы можете создавать стабильные и производительные приложения, избегая проблем с утечками памяти.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(132,2,14,132,152,131,17,'rus','2023-10-31',NULL,'Работа с изображениями и памятью','Работа с изображениями - распространенная задача при разработке приложений на языке Kotlin. Она также связана с правильным управлением памятью, чтобы избежать утечек и обеспечить производительность вашего приложения. В этом уроке мы рассмотрим, как работать с изображениями и эффективно управлять памятью.\r\n\r\n1. Загрузка и отображение изображений:\r\n\r\nИспользуйте библиотеки загрузки изображений: Вместо написания собственного кода для загрузки и отображения изображений, используйте библиотеки, такие как Picasso, Glide или Coil. Они облегчают работу с кэшированием, обработкой изображений и загрузкой.\r\nПример с использованием библиотеки Glide:','Glide.with(this)\r\n    .load(\"https://example.com/image.jpg\")\r\n    .into(imageView)',NULL,'2. Управление памятью:\r\n\r\nОсвобождайте память после использования: Если вы работаете с большими изображениями или ресурсами, убедитесь, что память освобождается после использования. Вызовите метод recycle() для Bitmap или используйте средства библиотек загрузки изображений для автоматической очистки.\r\nПример освобождения памяти после использования Bitmap:','val bitmap: Bitmap = ...\r\nbitmap.recycle()',NULL,'Используйте слабые ссылки: Если вам нужно хранить ссылки на изображения, используйте слабые ссылки, чтобы сборщик мусора мог уничтожить объекты, когда они больше не нужны.\r\nПример использования слабой ссылки:','val weakReference = WeakReference<Bitmap>(bitmap)\r\nval retrievedBitmap = weakReference.get()',NULL,'3. Оптимизация изображений:\r\n\r\nУменьшайте размер изображений: Если возможно, уменьшайте размер изображений до тех размеров, которые действительно требуются для отображения на экране. Это позволит уменьшить использование памяти и улучшить производительность.\r\n\r\nОптимизируйте форматы изображений: Используйте форматы изображений с потерей качества, такие как WebP, для сжатия изображений с минимальной потерей качества.\r\n\r\n4. Кэширование изображений:\r\n\r\nИспользуйте кэширование изображений: Кэширование позволяет сохранять загруженные изображения, чтобы не загружать их повторно. Многие библиотеки загрузки изображений включают встроенную поддержку кэширования.\r\n5. Освобождение памяти при завершении активности:\r\n\r\nОсвобождайте память в методе onDestroy активности: Если ваша активность больше не нужна, освобождайте ресурсы, такие как загруженные изображения или кэш, в методе onDestroy.\r\n6. Профилирование приложения:\r\n\r\nИспользуйте инструменты профилирования: Профилирование приложения позволяет выявить утечки памяти и оптимизировать его производительность. В Android Studio используйте Android Profiler для анализа использования памяти и CPU.\r\nЗаключение:\r\n\r\nРабота с изображениями и управление памятью - важные аспекты разработки приложений на языке Kotlin. Правильное управление памятью и использование библиотек для загрузки и отображения изображений помогут вам создать производительное приложение с высоким качеством отображения изображений.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),(133,2,14,133,153,132,17,'rus','2023-10-31',NULL,'Оптимизация и профилирование','Оптимизация и профилирование приложения - важные этапы разработки, позволяющие создать стабильное и производительное приложение. В этом уроке мы рассмотрим основные принципы оптимизации и инструменты для профилирования приложений на языке Kotlin.\r\n\r\n1. Принципы оптимизации:\r\n\r\nОптимизация приложения в Kotlin начинается с понимания и учета ключевых принципов:\r\n\r\nНе оптимизируйте заранее: Не старайтесь оптимизировать каждую строку кода заранее. Сначала создайте работающее приложение, затем профилируйте и оптимизируйте те участки, которые действительно нуждаются в улучшениях.\r\n\r\nИзбегайте избыточных вычислений: Избегайте избыточных вычислений, лишних запросов к базе данных и обращений в сеть. Кэшируйте результаты и минимизируйте нагрузку на ресурсы.\r\n\r\nОптимизация алгоритмов: Пересмотрите алгоритмы и структуры данных, используемые в вашем приложении. Некоторые операции могут быть улучшены с помощью более эффективных алгоритмов.\r\n\r\nОптимизация работы с памятью: Управляйте памятью осторожно. Избегайте утечек памяти, уменьшайте использование памяти и обеспечивайте быстрое высвобождение неиспользуемых ресурсов.\r\n\r\nЛенивая загрузка: Загружайте данные и ресурсы только по мере необходимости. Это позволяет сэкономить память и ускорить инициализацию приложения.\r\n\r\n2. Инструменты для профилирования:\r\n\r\nДля профилирования приложений на языке Kotlin можно использовать различные инструменты:\r\n\r\nAndroid Profiler: В Android Studio предоставляется Android Profiler, который позволяет отслеживать использование центрального процессора (CPU), памяти и сети, а также анализировать производительность приложения.\r\n\r\nLeakCanary: Этот инструмент был упомянут ранее и используется для обнаружения утечек памяти в Android-приложениях. Он может помочь выявить и устранить утечки.\r\n\r\nMAT (Memory Analyzer Tool): MAT - это мощный инструмент для анализа дампов памяти Java и Android-приложений. Он может помочь идентифицировать утечки памяти и оптимизировать использование памяти.\r\n\r\nSystrace: Systrace - инструмент для анализа производительности на уровне системы Android. Он может помочь выявить узкие места в работе приложения.\r\n\r\nAndroid Vitals: Используйте Android Vitals в консоли разработчика Google Play, чтобы мониторить ключевые показатели производительности вашего приложения и получать рекомендации по оптимизации.\r\n\r\n3. Профилирование в Kotlin:\r\n\r\nДля профилирования кода на Kotlin можно использовать встроенные средства разработки, такие как Android Profiler и отладочные инструменты Android Studio. Эти инструменты позволяют анализировать использование памяти и CPU, отслеживать вызовы методов и определять, где возникают узкие места производительности.\r\n\r\nЗаключение:\r\n\r\nОптимизация и профилирование - важные этапы разработки приложений на языке Kotlin. Следуя принципам оптимизации, используя инструменты для профилирования и внимательно анализируя производительность вашего приложения, вы сможете создать стабильное и быстродействующее приложение, которое удовлетворит пользовательские ожидания.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
/*!40000 ALTER TABLE `lesson_content` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2023-11-29 17:15:49
