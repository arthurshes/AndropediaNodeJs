-- MySQL dump 10.13  Distrib 8.0.34, for macos13 (arm64)
--
-- Host: localhost    Database: andropedia_db
-- ------------------------------------------------------
-- Server version	8.0.32

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!50503 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `victorines_clue`
--

DROP TABLE IF EXISTS `victorines_clue`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `victorines_clue` (
  `id` int NOT NULL AUTO_INCREMENT,
  `vicotineTestId` int NOT NULL,
  `uniqueThemeId` int NOT NULL,
  `questionId` int NOT NULL,
  `lastUpdateDate` date NOT NULL,
  `clueText` text NOT NULL,
  `language` text NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=9106 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `victorines_clue`
--

LOCK TABLES `victorines_clue` WRITE;
/*!40000 ALTER TABLE `victorines_clue` DISABLE KEYS */;
INSERT INTO `victorines_clue` VALUES (1,2008,6,26,'2023-11-01','Пометка \"Deprecated\" служит предупреждением о возможном удалении элемента в будущих версиях, поэтому она не указывает на неопределенные элементы в коде. \n','rus'),(2,2008,6,27,'2023-11-01','Вместо удаления или игнорирования устаревших элементов, рекомендуется искать альтернативы в документации или онлайн. \n','rus'),(3,2008,6,28,'2023-11-01','Null Safety в Kotlin включает в себя два типа переменных: nullable (допускающие null) и non-nullable (не допускающие null). \n','rus'),(4,2008,6,29,'2023-11-01','Elvis operator позволяет устанавливать значение по умолчанию для nullable переменных.','rus'),(5,2008,6,30,'2023-11-01','В Kotlin, when оператор позволяет заменить множество условных операторов, таких как if-else и switch в других языках. \n','rus'),(6,2008,6,31,'2023-11-01','Для создания диапазона чисел, включая верхнюю границу, используется оператор диапазона \'..\' в Kotlin. \n','rus'),(7,2008,6,32,'2023-11-01','Оператор \'>\' используется для проверки, является ли значение слева от него больше значения справа. \n','rus'),(8,2008,6,33,'2023-11-01','Логический оператор \'&&\' возвращает true, если оба условия истинны. \n','rus'),(9,2008,6,34,'2023-11-01','Тернарный оператор в Kotlin помогает сделать код более читабельным и компактным. \n','rus'),(10,2008,6,35,'2023-11-01','Тернарный оператор не подходит, когда требуется выполнение нескольких действий в различных ветках. \n','rus'),(11,2008,6,36,'2023-11-01','Для создания условных выражений в Kotlin используются ключевые слова if, else if и else. \n','rus'),(12,2008,6,37,'2023-11-01','Код внутри условного выражения if выполняется только в случае истинности условия.','rus'),(13,2009,7,38,'2023-11-01','В Kotlin для переопределения методов и свойств из родительских классов или интерфейсов используется ключевое слово \"override\".','rus'),(14,2009,7,39,'2023-11-01','В родительском классе или интерфейсе, чтобы указать, что метод или свойство можно переопределить, используется ключевое слово \"open\".','rus'),(15,2009,7,40,'2023-11-01','Для предотвращения дальнейшего переопределения метода или свойства в классах-наследниках используется ключевое слово \"final\".','rus'),(16,2009,7,41,'2023-11-01','В Kotlin можно переопределять как методы, так и свойства с использованием ключевого слова \"override\".','rus'),(17,2009,7,42,'2023-11-01','Вложенные циклы - это циклы, которые находятся внутри другого цикла и могут быть использованы для обхода двумерных структур данных.','rus'),(18,2009,7,43,'2023-11-01','Вложенные циклы часто используются для обхода двумерных массивов и выполнения операций над элементами.','rus'),(19,2009,7,44,'2023-11-01','Для создания вложенных циклов в Kotlin используются операторы \"for\" и \"while\".','rus'),(20,2009,7,45,'2023-11-01','Основное преимущество использования вложенных циклов - обход двумерных структур данных и выполнение повторяющихся операций.','rus'),(21,2009,7,46,'2023-11-01','Ключевое слово \"break\" используется для немедленного выхода из цикла, даже если условие продолжения остается истинным.','rus'),(22,2009,7,47,'2023-11-01','Ключевое слово \"continue\" используется для пропуска текущей итерации цикла и перехода к следующей итерации.','rus'),(23,2009,7,48,'2023-11-01','Цикл do-while выполняет блок кода хотя бы один раз, даже если условие с самого начала ложно.','rus'),(24,2009,7,49,'2023-11-01','Цикл \"while\" проверяет условие перед выполнением блока кода.','rus'),(25,2009,7,50,'2023-11-01','Синтаксис цикла \"while\" в Kotlin выглядит как \"while (условие) { }\".','rus'),(26,2010,8,52,'2023-11-01','View Binding - это механизм для связывания компонентов пользовательского интерфейса с кодом.','rus'),(27,2010,8,53,'2023-11-01','Для подключения View Binding в проекте Android нужно добавить зависимость к проекту с использованием Gradle.','rus'),(28,2010,8,54,'2023-11-01','Метод для освобождения ресурсов View Binding при уничтожении активности - это onDestroy().','rus'),(29,2010,8,55,'2023-11-01','Использование View Binding уменьшает вероятность ошибок, связанных с неправильными ID элементов в пользовательском интерфейсе.','rus'),(30,2010,8,56,'2023-11-01','Множество (Set) в Kotlin - это коллекция, которая содержит только уникальные элементы без повторений.','rus'),(47,2011,9,72,'2023-11-01','Жизненный цикл Activity в Android представляет собой серию событий, происходящих с момента создания Activity до его удаления.','rus'),(48,2011,9,73,'2023-11-01','Метод, вызываемый при создании Activity в Android, - это onCreate().','rus'),(49,2011,9,74,'2023-11-01','Метод, вызываемый в такой ситуации, - это onStart().','rus'),(50,2011,9,75,'2023-11-01','Метод, вызываемый в этой ситуации, - это onPause().','rus'),(51,2011,9,76,'2023-11-01','В этом случае Activity автоматически восстанавливает свое состояние без потерь.','rus'),(52,2011,9,77,'2023-11-01','Метод, вызываемый перед уничтожением Activity, - это onDestroy().','rus'),(53,2011,9,78,'2023-11-01','Это важно для эффективного управления состоянием и взаимодействием приложений с пользователем.','rus'),(54,2011,9,79,'2023-11-01','Намерения позволяют запускать действия (Activities, Services, Broadcast Receivers) в Android.','rus'),(55,2011,9,80,'2023-11-01','Для передачи данных между Activity используется намерение (Intent) с методом putExtra().','rus'),(56,2011,9,81,'2023-11-01','Метод, вызываемый при создании Activity в Android, - это onCreate().','rus'),(57,2011,9,82,'2023-11-01','Это важно для правильной работы приложения и сохранения данных при переходах между Activity.','rus'),(58,2011,9,83,'2023-11-01','Для сохранения и восстановления состояния используются методы onSaveInstanceState() и onRestoreInstanceState().','rus'),(59,2011,9,84,'2023-11-01','Метод, в котором можно остановить выполнение задачи при уходе Activity в фоновый режим, - это onPause().','rus'),(60,2011,9,85,'2023-11-01','Метод, вызываемый при уничтожении Activity перед закрытием приложения, - это onDestroy().','rus'),(61,2012,10,86,'2023-11-01','Абстрактные классы позволяют создавать классы, но не являются концепцией, которая позволяет создавать новый класс на основе существующего и повторно использовать код. Этой концепцией является наследование.','rus'),(62,2012,10,87,'2023-11-01','Абстрактные классы могут содержать поля и иметь конкретные методы, но они не могут быть созданы напрямую, и могут содержать абстрактные методы, которые должны быть реализованы в подклассах.','rus'),(63,2012,10,88,'2023-11-01','Интерфейсы в первую очередь определяют контракты для классов, указывая на методы, которые должны быть реализованы, а не предоставляют доступ к закрытым полям класса.','rus'),(64,2012,10,89,'2023-11-01','Этот ответ верен, полиморфизм действительно позволяет использовать один и тот же интерфейс для разных классов.','rus'),(65,2012,10,90,'2023-11-01','Перегрузка методов означает, что вы можете иметь методы с одним именем в одном классе, но с разными параметрами.','rus'),(66,2012,10,91,'2023-11-01','Вопрос указывает, что данная концепция не была упомянута в лекции, и правильным ответом на это утверждение является \"Инкапсуляция\".','rus'),(67,2012,10,92,'2023-11-01','Наследование в основном используется для того, чтобы классы могли наследовать свойства и методы от других классов, а не для определения абстрактных методов.','rus'),(68,2012,10,93,'2023-11-01','В Kotlin, чтобы можно было наследовать класс, его класс-родитель должен быть открытым (с модификатором доступа \"open\").','rus'),(69,2012,10,94,'2023-11-01','Наследование позволяет повторно использовать код, что является одним из его преимуществ, и не увеличивает сложность кода.','rus'),(70,2012,10,95,'2023-11-01','Абстрактные классы могут содержать и нести базовую логику для других классов, а также могут содержать абстрактные методы, которые должны быть реализованы в подклассах.','rus'),(71,2012,10,96,'2023-11-01','Интерфейсы в первую очередь определяют контракты для классов, указывая на методы, которые должны быть реализованы, а не объекты классов.','rus'),(72,2012,10,97,'2023-11-01','Перегрузка методов означает определение методов с разными параметрами в одном классе, а не удаление методов из класса.','rus'),(73,2012,10,98,'2023-11-01','Фрагменты в Kotlin для Android представляют собой части кода, которые можно многократно использовать в разных частях приложения, а не метаданные.','rus'),(74,2012,10,99,'2023-11-01','Чтобы создать фрагмент в Kotlin, нужно наследовать класс Fragment, а не какой-либо \"Layout\".','rus'),(75,2012,10,100,'2023-11-01','Обычно связывание макета (разметки) с фрагментом происходит в методе onCreateView фрагмента, где определяется макет для фрагмента.','rus'),(76,2013,19,101,'2023-11-01','Clean Architecture на самом деле нацелена на обеспечение независимости от фреймворков и внешних ресурсов, а не библиотек.','rus'),(77,2013,19,102,'2023-11-01','Frameworks & Drivers в Clean Architecture представляют внешние фреймворки и драйверы, но не оркестрируют работу Use Cases и Entities.','rus'),(78,2013,19,103,'2023-11-01','Flow в Android не связан с RxJava и предоставляет альтернативный способ работы с асинхронными данными.','rus'),(79,2013,19,104,'2023-11-01','Для наблюдения за изменениями в Flow в Android используется оператор \"observe\".','rus'),(80,2013,19,105,'2023-11-01','LiveData в Android не предоставляет автоматической конвертации данных в JSON.','rus'),(81,2013,19,106,'2023-11-01','В паттерне MVI отсутствует компонент \"Presenter,\" а вместо него используется \"ViewModel.\"','rus'),(82,2013,19,107,'2023-11-01','Состояние приложения в паттерне MVI представляет собой данные, необходимые для отображения, а не интерфейс пользователя.','rus'),(83,2013,19,108,'2023-11-01','Запрос на загрузку задач в паттерне MVI обычно представляется в виде \"LoadTasks,\" а не \"UpdateTasks.\"','rus'),(84,2013,19,109,'2023-11-01','В архитектурном паттерне MVVM компоненты включают Model, View и ViewModel, но не Intent.','rus'),(85,2013,19,110,'2023-11-01','В архитектуре MVVM компонент Model отвечает за обработку бизнес-логики и взаимодействие с данными.','rus'),(86,2013,19,111,'2023-11-01','ViewModel в архитектуре MVVM не занимается напрямую отображением данных на экране.','rus'),(87,2013,19,112,'2023-11-01','В архитектуре MVVM взаимодействие происходит между Model и ViewModel, а не с Presenter.','rus'),(88,2013,19,113,'2023-11-01','MVVM обычно используется в проектах средней и высокой сложности для более структурированного и поддерживаемого кода. В проектах с небольшой сложностью можно предпочесть более простые архитектурные паттерны.','rus'),(90,2013,19,114,'2023-11-01','Паттерн MVI обычно рекомендуется для проектов с высокой сложностью, где важно более четкое определение действий пользователя и состояний приложения.','rus'),(91,2013,19,115,'2023-11-01','В архитектуре MVVM ViewModel отвечает за предоставление данных и логику для отображения.','rus'),(92,2013,19,116,'2023-11-01','В архитектуре MVI намерение пользователя представлено компонентом Intent, который обрабатывается другими компонентами для изменения состояния приложения.','rus'),(93,2013,19,117,'2023-11-01','В паттерне MVVM View обычно автоматически обновляется в соответствии с жизненным циклом компонента (Activity, Fragment).','rus'),(94,2013,19,118,'2023-11-01','Паттерн MVI обычно используется, когда необходима более структурированная и предсказуемая обработка действий пользователя.','rus'),(95,2013,19,119,'2023-11-01','Паттерн MVVM предоставляет более широкий спектр операторов для манипулирования данными и подходит для обработки асинхронных операций.','rus'),(96,2014,20,120,'2023-11-01','Этот антипаттерн связан с копированием и вставкой кода.','rus'),(97,2014,20,121,'2023-11-01','Этот антипаттерн характеризуется объектом, содержащим слишком много функциональности.','rus'),(98,2014,20,122,'2023-11-01','Для эффективного управления задачами, которые могут блокировать выполнение кода, используется асинхронное программирование.','rus'),(99,2014,20,123,'2023-11-01','Kotlin Coroutines предоставляют более эффективный и понятный способ асинхронного программирования в Kotlin.','rus'),(100,2014,20,124,'2023-11-01','Kotlin Coroutines упрощают работу с асинхронными операциями.','rus'),(101,2014,20,125,'2023-11-01','Колбэки используются в асинхронном программировании.','rus'),(102,2014,20,126,'2023-11-01','ViewModel предназначен для хранения и управления данными, связанными с пользовательским интерфейсом.','rus'),(103,2014,20,127,'2023-11-01','Observables/Reactive Programming предоставляют инструменты для создания и обработки потоков данных и событий.','rus'),(104,2014,20,128,'2023-11-01','Вопрос касается типов многозадачности на уровне операционной системы, а не уровня видеокарты.','rus'),(106,2014,20,129,'2023-11-01','Отсутствие синхронизации при работе с разделяемыми ресурсами приводит к состоянию гонки и непредсказуемым результатам.','rus'),(107,2014,20,130,'2023-11-01','Корутины в Kotlin предоставляют более простой и гибкий способ управления потоками.','rus'),(108,2014,20,131,'2023-11-01','Пулы потоков представляют собой наборы заранее созданных потоков для выполнения задач.','rus'),(110,2015,20,132,'2023-11-01','Задачи представляют собой единицы работы, которые нужно выполнить.','rus'),(111,2015,20,133,'2023-11-01','Задачи оптимизируют нагрузку и предоставляют удобное описание работы.','rus'),(112,2015,20,134,'2023-11-01','Для завершения пула потоков используется метод, начинающийся с \"shutdown.\"','rus'),(113,2015,20,135,'2023-11-01','Пулы потоков и задачи способствуют оптимизации производительности приложений.','rus'),(114,2015,20,136,'2023-11-01','Пулы потоков позволяют контролировать количество параллельно выполняющихся задач.','rus'),(115,2015,20,137,'2023-11-01','В примере использования задач в Kotlin для получения результата задачи используется метод, начинающийся с \"get.\"','rus'),(116,2015,20,138,'2023-11-01','Вопрос касается инструментов многозадачности, а не уровня процессора.','rus'),(117,2015,21,139,'2023-11-01','Koin на самом деле помогает упростить код и избежать избыточного бойлерплейта.','rus'),(118,2015,21,140,'2023-11-01','В Koin используются компоненты, связанные с Dependency Injection, а не компоненты связанные с Android-разработкой.','rus'),(119,2015,21,141,'2023-11-01','В Koin используется функция get() для получения зависимостей в конструкторе.','rus'),(120,2015,21,142,'2023-11-01','Scopes в Koin используются для управления временем жизни зависимостей и упрощения тестирования.','rus'),(121,2015,21,143,'2023-11-01','В JUnit метод, который выполняется перед каждым тестовым методом, обозначается с помощью аннотации @Before.','rus'),(122,2015,21,144,'2023-11-01','Для интеграции Koin в тестовом окружении используется класс KoinTest.','rus'),(123,2015,21,145,'2023-11-01','Метод setup() с startKoin используется для настройки зависимостей перед каждым тестом, а не для выполнения тестовых методов.','rus'),(124,2015,21,146,'2023-11-01','Для создания модульных тестов с Koin используется библиотека JUnit.','rus'),(125,2016,21,147,'2023-11-01','Koin позволяет обрабатывать ошибки и исключения внутри функции inject().','rus'),(126,2016,21,148,'2023-11-01','Для создания фейковой зависимости используется определение фейковой зависимости в тестовом модуле.','rus'),(127,2016,21,149,'2023-11-01','Увеличение сложности тестирования.','rus'),(128,2016,21,150,'2023-11-01','Создавать синглтоны для всех зависимостей.','rus'),(129,2016,21,151,'2023-11-01','Используя функцию get() для получения зависимости.','rus'),(130,2016,21,152,'2023-11-01','Ленивая инициализация зависимости в Koin достигается с использованием ключевого слова \"lazy\" при объявлении зависимости.','rus'),(131,2016,21,153,'2023-11-01','Ленивая инициализация с by lazy полезна для оптимизации производительности, так как зависимости создаются только при первом использовании.','rus'),(132,2016,22,154,'2023-11-01','Dagger Hilt предоставляет минимальную конфигурацию для внедрения зависимостей.','rus'),(133,2016,22,155,'2023-11-01','Основные компоненты - Hilt Modules и Hilt Components.','rus'),(134,2016,22,156,'2023-11-01','Для класса Application используется аннотация @HiltAndroidApp.','rus'),(135,2016,22,157,'2023-11-01','Внедрение зависимостей происходит автоматически после onCreate().','rus'),(136,2016,22,158,'2023-11-01','@Qualifier используется для разрешения конфликтов при наличии нескольких зависимостей одного типа.','rus'),(137,2016,22,159,'2023-11-01','Динамическая настройка компонентов достигается в Dagger Hilt другим способом.','rus'),(138,2016,22,160,'2023-11-01','@HiltViewModel указывает, что класс ViewModel должен быть внедрен в Dagger Hilt.','rus'),(139,2016,22,161,'2023-11-01','Перед внедрением ViewModel необходимо аннотировать активность или фрагмент с @AndroidEntryPoint.','rus'),(140,2016,22,162,'2023-11-01','Зависимости с аннотацией @Singleton создаются один раз при запуске приложения и уничтожаются вместе с ним.','rus'),(141,2016,22,163,'2023-11-01','Для внедрения ViewModel используется аннотация @ViewModelInject.','rus'),(142,2016,22,164,'2023-11-01','ViewModel используется для хранения и управления данными, связанными с пользовательским интерфейсом.','rus'),(143,2016,22,165,'2023-11-01','Область видимости указывается с помощью других аннотаций.','rus'),(144,2016,22,166,'2023-11-01','@HiltAndroidApp указывает, что приложение является приложением Dagger Hilt.','rus'),(145,2017,22,167,'2023-11-01','Для указания классов, использующих внедрение зависимостей, используется аннотация @AndroidEntryPoint.','rus'),(146,2017,22,168,'2023-11-01','Для предоставления зависимостей должны быть созданы компоненты Dagger Hilt.','rus'),(147,2017,22,169,'2023-11-01','Модули используются для предоставления зависимостей с помощью методов @Provides.','rus'),(148,2017,22,170,'2023-11-01','Перед внедрением зависимостей в юнит-тесты необходимо подключить библиотеку Dagger Hilt в проект.','rus'),(149,2017,22,171,'2023-11-01','Для инициализации компонентов Dagger Hilt в юнит-тестах можно использовать HiltTestRule.','rus'),(150,2017,22,172,'2023-11-01','@HiltAndroidApp должны быть аннотированы приложение и его Application класс.','rus'),(151,2017,22,173,'2023-11-01','Для автоматического внедрения зависимостей в ViewModel используется аннотация @ViewModelInject.','rus'),(152,2017,23,174,'2023-11-01','Моки и стабы - это техники для изоляции тестируемого кода от внешних зависимостей.','rus'),(153,2017,23,175,'2023-11-01','Моки используются для имитации реальных объектов и компонентов в тестах.','rus'),(154,2017,23,176,'2023-11-01','Моки и стабы предоставляют более точные и предсказуемые результаты тестов.','rus'),(155,2017,23,177,'2023-11-01','Необходимо добавить зависимость testImplementation(\"io.mockk:mockk:1.12.0\") в файл build.gradle.','rus'),(156,2017,23,178,'2023-11-01','Unit-тестирование - это процесс проверки отдельных компонентов кода.','rus'),(157,2017,23,179,'2023-11-01','Unit-тестирование снижает затраты на исправление ошибок в будущем.','rus'),(158,2017,23,180,'2023-11-01','Структура теста в подходе AAA включает в себя шаги Arrange, Act и Assert.','rus'),(159,2017,23,181,'2023-11-01','В Unit-тестировании могут быть проверены различные граничные случаи, включая нулевые и пустые коллекции, отрицательные значения, крайние значения и переполнение типов.','rus'),(160,2017,23,182,'2023-11-01','Интеграционное тестирование представляет собой проверку взаимодействия между различными компонентами системы или модулями кода.','rus'),(161,2017,23,183,'2023-11-01','Цель интеграционного тестирования - проверить, как компоненты взаимодействуют друг с другом и что весь код работает вместе как ожидается.','rus'),(162,2017,23,184,'2023-11-01','В материале приведен пример интеграционного тестирования API.','rus'),(163,2017,23,185,'2023-11-01','Интеграционное тестирование снижает затраты на исправление ошибок в будущем.','rus'),(164,2017,23,186,'2023-11-01','Различные модули кода могут подвергаться интеграционному тестированию.','rus'),(165,2017,23,187,'2023-11-01','Цель интеграционного тестирования API - проверка взаимодействия между компонентами системы.','rus'),(166,2017,23,188,'2023-11-01','Для интеграционного тестирования могут использоваться библиотеки JUnit, Kotest и MockK.','rus'),(167,2017,23,189,'2023-11-01','Рекомендуется разделять код тестов на три части: подготовка, выполнение действия и проверка результата.','rus'),(168,2017,23,190,'2023-11-01','Тестирование REST API включает в себя проверку функциональности, надежности и соответствия стандартам веб-сервиса, использующего архитектуру REST.','rus'),(169,2017,23,191,'2023-11-01','Тестирование REST API нужно для обеспечения надежности и стабильности веб-сервиса.','rus'),(170,2017,23,192,'2023-11-01','Для тестирования REST API можно использовать инструменты Postman, RestAssured и JUnit.','rus'),(171,2017,23,193,'2023-11-01','Инструмент с графическим интерфейсом для тестирования REST API - Postman.','rus'),(172,2017,23,194,'2023-11-01','При тестировании REST API проводятся тесты функциональности, надежности и соответствия стандартам.','rus'),(173,2017,23,195,'2023-11-01','Тестирование REST API предоставляет преимущества в обеспечении надежности и стабильности веб-сервиса.','rus'),(174,2017,23,196,'2023-11-01','Тестирование исключений нужно для убеждения в том, что код корректно обрабатывает исключительные ситуации.','rus'),(175,2017,23,197,'2023-11-01','Для ожидания и проверки исключений в юнит-тестах можно использовать assertThrows.','rus');
/*!40000 ALTER TABLE `victorines_clue` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2023-11-29 17:15:49
